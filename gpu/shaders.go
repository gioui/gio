// Code generated by build.go. DO NOT EDIT.

package gpu

import "gioui.org/gpu/internal/driver"

var (
	shader_backdrop_comp = driver.ShaderSources{
		Name: "backdrop.comp",
		GLSL310ES: `#version 310 es
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Alloc
{
    uint offset;
};

struct AnnotatedRef
{
    uint offset;
};

struct AnnotatedTag
{
    uint tag;
    uint flags;
};

struct PathRef
{
    uint offset;
};

struct TileRef
{
    uint offset;
};

struct Path
{
    uvec4 bbox;
    TileRef tiles;
};

struct Config
{
    uint n_elements;
    uint n_pathseg;
    uint width_in_tiles;
    uint height_in_tiles;
    Alloc tile_alloc;
    Alloc bin_alloc;
    Alloc ptcl_alloc;
    Alloc pathseg_alloc;
    Alloc anno_alloc;
    Alloc trans_alloc;
};

layout(binding = 0, std430) buffer Memory
{
    uint mem_offset;
    uint mem_error;
    uint memory[];
} _77;

layout(binding = 1, std430) readonly buffer ConfigBuf
{
    Config conf;
} _191;

shared uint sh_row_width[128];
shared Alloc sh_row_alloc[128];
shared uint sh_row_count[128];

bool touch_mem(Alloc alloc, uint offset)
{
    return true;
}

uint read_mem(Alloc alloc, uint offset)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return 0u;
    }
    uint v = _77.memory[offset];
    return v;
}

AnnotatedTag Annotated_tag(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint tag_and_flags = read_mem(param, param_1);
    return AnnotatedTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));
}

uint fill_mode_from_flags(uint flags)
{
    return flags & 1u;
}

Path Path_read(Alloc a, PathRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Path s;
    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));
    s.tiles = TileRef(raw2);
    return s;
}

Alloc new_alloc(uint offset, uint size)
{
    Alloc a;
    a.offset = offset;
    return a;
}

void write_mem(Alloc alloc, uint offset, uint val)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return;
    }
    _77.memory[offset] = val;
}

void main()
{
    if (_77.mem_error != 0u)
    {
        return;
    }
    uint th_ix = gl_LocalInvocationID.x;
    uint element_ix = gl_GlobalInvocationID.x;
    AnnotatedRef ref = AnnotatedRef(_191.conf.anno_alloc.offset + (element_ix * 32u));
    uint row_count = 0u;
    if (element_ix < _191.conf.n_elements)
    {
        Alloc param;
        param.offset = _191.conf.anno_alloc.offset;
        AnnotatedRef param_1 = ref;
        AnnotatedTag tag = Annotated_tag(param, param_1);
        switch (tag.tag)
        {
            case 2u:
            case 3u:
            case 1u:
            {
                uint param_2 = tag.flags;
                if (fill_mode_from_flags(param_2) != 0u)
                {
                    break;
                }
                PathRef path_ref = PathRef(_191.conf.tile_alloc.offset + (element_ix * 12u));
                Alloc param_3;
                param_3.offset = _191.conf.tile_alloc.offset;
                PathRef param_4 = path_ref;
                Path path = Path_read(param_3, param_4);
                sh_row_width[th_ix] = path.bbox.z - path.bbox.x;
                row_count = path.bbox.w - path.bbox.y;
                bool _267 = row_count == 1u;
                bool _273;
                if (_267)
                {
                    _273 = path.bbox.y > 0u;
                }
                else
                {
                    _273 = _267;
                }
                if (_273)
                {
                    row_count = 0u;
                }
                uint param_5 = path.tiles.offset;
                uint param_6 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;
                Alloc path_alloc = new_alloc(param_5, param_6);
                sh_row_alloc[th_ix] = path_alloc;
                break;
            }
        }
    }
    sh_row_count[th_ix] = row_count;
    for (uint i = 0u; i < 7u; i++)
    {
        barrier();
        if (th_ix >= uint(1 << int(i)))
        {
            row_count += sh_row_count[th_ix - uint(1 << int(i))];
        }
        barrier();
        sh_row_count[th_ix] = row_count;
    }
    barrier();
    uint total_rows = sh_row_count[127];
    uint _395;
    for (uint row = th_ix; row < total_rows; row += 128u)
    {
        uint el_ix = 0u;
        for (uint i_1 = 0u; i_1 < 7u; i_1++)
        {
            uint probe = el_ix + uint(64 >> int(i_1));
            if (row >= sh_row_count[probe - 1u])
            {
                el_ix = probe;
            }
        }
        uint width = sh_row_width[el_ix];
        if (width > 0u)
        {
            Alloc tiles_alloc = sh_row_alloc[el_ix];
            if (el_ix > 0u)
            {
                _395 = sh_row_count[el_ix - 1u];
            }
            else
            {
                _395 = 0u;
            }
            uint seq_ix = row - _395;
            uint tile_el_ix = ((tiles_alloc.offset >> uint(2)) + 1u) + ((seq_ix * 2u) * width);
            Alloc param_7 = tiles_alloc;
            uint param_8 = tile_el_ix;
            uint sum = read_mem(param_7, param_8);
            for (uint x = 1u; x < width; x++)
            {
                tile_el_ix += 2u;
                Alloc param_9 = tiles_alloc;
                uint param_10 = tile_el_ix;
                sum += read_mem(param_9, param_10);
                Alloc param_11 = tiles_alloc;
                uint param_12 = tile_el_ix;
                uint param_13 = sum;
                write_mem(param_11, param_12, param_13);
            }
        }
    }
}

`,
	}
	shader_binning_comp = driver.ShaderSources{
		Name: "binning.comp",
		GLSL310ES: `#version 310 es
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Alloc
{
    uint offset;
};

struct MallocResult
{
    Alloc alloc;
    bool failed;
};

struct AnnoEndClipRef
{
    uint offset;
};

struct AnnoEndClip
{
    vec4 bbox;
};

struct AnnotatedRef
{
    uint offset;
};

struct AnnotatedTag
{
    uint tag;
    uint flags;
};

struct BinInstanceRef
{
    uint offset;
};

struct BinInstance
{
    uint element_ix;
};

struct Config
{
    uint n_elements;
    uint n_pathseg;
    uint width_in_tiles;
    uint height_in_tiles;
    Alloc tile_alloc;
    Alloc bin_alloc;
    Alloc ptcl_alloc;
    Alloc pathseg_alloc;
    Alloc anno_alloc;
    Alloc trans_alloc;
};

layout(binding = 0, std430) buffer Memory
{
    uint mem_offset;
    uint mem_error;
    uint memory[];
} _88;

layout(binding = 1, std430) readonly buffer ConfigBuf
{
    Config conf;
} _254;

shared uint bitmaps[4][128];
shared bool sh_alloc_failed;
shared uint count[4][128];
shared Alloc sh_chunk_alloc[128];

bool touch_mem(Alloc alloc, uint offset)
{
    return true;
}

uint read_mem(Alloc alloc, uint offset)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return 0u;
    }
    uint v = _88.memory[offset];
    return v;
}

AnnotatedTag Annotated_tag(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint tag_and_flags = read_mem(param, param_1);
    return AnnotatedTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));
}

AnnoEndClip AnnoEndClip_read(Alloc a, AnnoEndClipRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 3u;
    uint raw3 = read_mem(param_6, param_7);
    AnnoEndClip s;
    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    return s;
}

AnnoEndClip Annotated_EndClip_read(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    AnnoEndClipRef param_1 = AnnoEndClipRef(ref.offset + 4u);
    return AnnoEndClip_read(param, param_1);
}

Alloc new_alloc(uint offset, uint size)
{
    Alloc a;
    a.offset = offset;
    return a;
}

MallocResult malloc(uint size)
{
    MallocResult r;
    r.failed = false;
    uint _94 = atomicAdd(_88.mem_offset, size);
    uint offset = _94;
    uint param = offset;
    uint param_1 = size;
    r.alloc = new_alloc(param, param_1);
    if ((offset + size) > uint(int(uint(_88.memory.length())) * 4))
    {
        r.failed = true;
        uint _115 = atomicMax(_88.mem_error, 1u);
        return r;
    }
    return r;
}

void write_mem(Alloc alloc, uint offset, uint val)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return;
    }
    _88.memory[offset] = val;
}

void BinInstance_write(Alloc a, BinInstanceRef ref, BinInstance s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = s.element_ix;
    write_mem(param, param_1, param_2);
}

void main()
{
    if (_88.mem_error != 0u)
    {
        return;
    }
    uint my_n_elements = _254.conf.n_elements;
    uint my_partition = gl_WorkGroupID.x;
    for (uint i = 0u; i < 4u; i++)
    {
        bitmaps[i][gl_LocalInvocationID.x] = 0u;
    }
    if (gl_LocalInvocationID.x == 0u)
    {
        sh_alloc_failed = false;
    }
    barrier();
    uint element_ix = (my_partition * 128u) + gl_LocalInvocationID.x;
    AnnotatedRef ref = AnnotatedRef(_254.conf.anno_alloc.offset + (element_ix * 32u));
    uint tag = 0u;
    if (element_ix < my_n_elements)
    {
        Alloc param;
        param.offset = _254.conf.anno_alloc.offset;
        AnnotatedRef param_1 = ref;
        tag = Annotated_tag(param, param_1).tag;
    }
    int x0 = 0;
    int y0 = 0;
    int x1 = 0;
    int y1 = 0;
    switch (tag)
    {
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        {
            Alloc param_2;
            param_2.offset = _254.conf.anno_alloc.offset;
            AnnotatedRef param_3 = ref;
            AnnoEndClip clip = Annotated_EndClip_read(param_2, param_3);
            x0 = int(floor(clip.bbox.x * 0.001953125));
            y0 = int(floor(clip.bbox.y * 0.00390625));
            x1 = int(ceil(clip.bbox.z * 0.001953125));
            y1 = int(ceil(clip.bbox.w * 0.00390625));
            break;
        }
    }
    uint width_in_bins = ((_254.conf.width_in_tiles + 16u) - 1u) / 16u;
    uint height_in_bins = ((_254.conf.height_in_tiles + 8u) - 1u) / 8u;
    x0 = clamp(x0, 0, int(width_in_bins));
    x1 = clamp(x1, x0, int(width_in_bins));
    y0 = clamp(y0, 0, int(height_in_bins));
    y1 = clamp(y1, y0, int(height_in_bins));
    if (x0 == x1)
    {
        y1 = y0;
    }
    int x = x0;
    int y = y0;
    uint my_slice = gl_LocalInvocationID.x / 32u;
    uint my_mask = uint(1 << int(gl_LocalInvocationID.x & 31u));
    while (y < y1)
    {
        uint _438 = atomicOr(bitmaps[my_slice][(uint(y) * width_in_bins) + uint(x)], my_mask);
        x++;
        if (x == x1)
        {
            x = x0;
            y++;
        }
    }
    barrier();
    uint element_count = 0u;
    for (uint i_1 = 0u; i_1 < 4u; i_1++)
    {
        element_count += uint(bitCount(bitmaps[i_1][gl_LocalInvocationID.x]));
        count[i_1][gl_LocalInvocationID.x] = element_count;
    }
    uint param_4 = 0u;
    uint param_5 = 0u;
    Alloc chunk_alloc = new_alloc(param_4, param_5);
    if (element_count != 0u)
    {
        uint param_6 = element_count * 4u;
        MallocResult _487 = malloc(param_6);
        MallocResult chunk = _487;
        chunk_alloc = chunk.alloc;
        sh_chunk_alloc[gl_LocalInvocationID.x] = chunk_alloc;
        if (chunk.failed)
        {
            sh_alloc_failed = true;
        }
    }
    uint out_ix = (_254.conf.bin_alloc.offset >> uint(2)) + (((my_partition * 128u) + gl_LocalInvocationID.x) * 2u);
    Alloc param_7;
    param_7.offset = _254.conf.bin_alloc.offset;
    uint param_8 = out_ix;
    uint param_9 = element_count;
    write_mem(param_7, param_8, param_9);
    Alloc param_10;
    param_10.offset = _254.conf.bin_alloc.offset;
    uint param_11 = out_ix + 1u;
    uint param_12 = chunk_alloc.offset;
    write_mem(param_10, param_11, param_12);
    barrier();
    if (sh_alloc_failed)
    {
        return;
    }
    x = x0;
    y = y0;
    while (y < y1)
    {
        uint bin_ix = (uint(y) * width_in_bins) + uint(x);
        uint out_mask = bitmaps[my_slice][bin_ix];
        if ((out_mask & my_mask) != 0u)
        {
            uint idx = uint(bitCount(out_mask & (my_mask - 1u)));
            if (my_slice > 0u)
            {
                idx += count[my_slice - 1u][bin_ix];
            }
            Alloc out_alloc = sh_chunk_alloc[bin_ix];
            uint out_offset = out_alloc.offset + (idx * 4u);
            Alloc param_13 = out_alloc;
            BinInstanceRef param_14 = BinInstanceRef(out_offset);
            BinInstance param_15 = BinInstance(element_ix);
            BinInstance_write(param_13, param_14, param_15);
        }
        x++;
        if (x == x1)
        {
            x = x0;
            y++;
        }
    }
}

`,
	}
	shader_blit_frag = [...]driver.ShaderSources{
		{
			Name:   "blit.frag",
			Inputs: []driver.InputLocation{{Name: "vUV", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}},
			Uniforms: driver.UniformsReflection{
				Blocks:    []driver.UniformBlock{{Name: "Color", Binding: 0}},
				Locations: []driver.UniformLocation{{Name: "_color.color", Type: 0x0, Size: 4, Offset: 0}},
				Size:      16,
			},
			GLSL100ES: `#version 100
precision mediump float;
precision highp int;

struct Color
{
    vec4 color;
};

uniform Color _color;

varying vec2 vUV;

void main()
{
    gl_FragData[0] = _color.color;
}

`,
			GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform Color
{
    vec4 color;
} _color;

layout(location = 0) out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = _color.color;
}

`,
			GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct Color
{
    vec4 color;
};

uniform Color _color;

out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = _color.color;
}

`,
			GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0, std140) uniform Color
{
    vec4 color;
} _color;

out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = _color.color;
}

`,
			HLSL: "DXBC,\xc1\x9c\x85P\xbc\xab\x8a.\x9e\b\xdd\xf7\xd2\x18\xa2\x01\x00\x00\x00t\x02\x00\x00\x06\x00\x00\x008\x00\x00\x00\x84\x00\x00\x00\xcc\x00\x00\x00H\x01\x00\x00\f\x02\x00\x00@\x02\x00\x00Aon9D\x00\x00\x00D\x00\x00\x00\x00\x02\xff\xff\x14\x00\x00\x000\x00\x00\x00\x01\x00$\x00\x00\x000\x00\x00\x000\x00\x00\x00$\x00\x00\x000\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x02\xff\xff\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\xa0\xff\xff\x00\x00SHDR@\x00\x00\x00@\x00\x00\x00\x10\x00\x00\x00Y\x00\x00\x04F\x8e \x00\x00\x00\x00\x00\x01\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x006\x00\x00\x06\xf2 \x10\x00\x00\x00\x00\x00F\x8e \x00\x00\x00\x00\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\xbc\x00\x00\x00\x01\x00\x00\x00D\x00\x00\x00\x01\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00\x94\x00\x00\x00<\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00Color\x00\xab\xab<\x00\x00\x00\x01\x00\x00\x00\\\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00t\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\x84\x00\x00\x00\x00\x00\x00\x00_color_color\x00\xab\xab\xab\x01\x00\x03\x00\x01\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
		},
		{
			Name:   "blit.frag",
			Inputs: []driver.InputLocation{{Name: "vUV", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}},
			Uniforms: driver.UniformsReflection{
				Blocks:    []driver.UniformBlock{{Name: "Gradient", Binding: 0}},
				Locations: []driver.UniformLocation{{Name: "_gradient.color1", Type: 0x0, Size: 4, Offset: 0}, {Name: "_gradient.color2", Type: 0x0, Size: 4, Offset: 16}},
				Size:      32,
			},
			GLSL100ES: `#version 100
precision mediump float;
precision highp int;

struct Gradient
{
    vec4 color1;
    vec4 color2;
};

uniform Gradient _gradient;

varying vec2 vUV;

void main()
{
    gl_FragData[0] = mix(_gradient.color1, _gradient.color2, vec4(clamp(vUV.x, 0.0, 1.0)));
}

`,
			GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform Gradient
{
    vec4 color1;
    vec4 color2;
} _gradient;

layout(location = 0) out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = mix(_gradient.color1, _gradient.color2, vec4(clamp(vUV.x, 0.0, 1.0)));
}

`,
			GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct Gradient
{
    vec4 color1;
    vec4 color2;
};

uniform Gradient _gradient;

out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = mix(_gradient.color1, _gradient.color2, vec4(clamp(vUV.x, 0.0, 1.0)));
}

`,
			GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0, std140) uniform Gradient
{
    vec4 color1;
    vec4 color2;
} _gradient;

out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = mix(_gradient.color1, _gradient.color2, vec4(clamp(vUV.x, 0.0, 1.0)));
}

`,
			HLSL: "DXBCdZ\xb9AA\xb2\xa5-Σc\xb9\xdc\xfd]\xae\x01\x00\x00\x00P\x03\x00\x00\x06\x00\x00\x008\x00\x00\x00\xcc\x00\x00\x00t\x01\x00\x00\xf0\x01\x00\x00\xe8\x02\x00\x00\x1c\x03\x00\x00Aon9\x8c\x00\x00\x00\x8c\x00\x00\x00\x00\x02\xff\xff\\\x00\x00\x000\x00\x00\x00\x01\x00$\x00\x00\x000\x00\x00\x000\x00\x00\x00$\x00\x00\x000\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x02\xff\xff\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x03\xb0\x01\x00\x00\x02\x00\x00\x18\x80\x00\x00\x00\xb0\x01\x00\x00\x02\x01\x00\x0f\x80\x00\x00\xe4\xa0\x02\x00\x00\x03\x01\x00\x0f\x80\x01\x00\xe4\x81\x01\x00\xe4\xa0\x04\x00\x00\x04\x00\x00\x0f\x80\x00\x00\xff\x80\x01\x00\xe4\x80\x00\x00\xe4\xa0\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00SHDR\xa0\x00\x00\x00@\x00\x00\x00(\x00\x00\x00Y\x00\x00\x04F\x8e \x00\x00\x00\x00\x00\x02\x00\x00\x00b\x10\x00\x03\x12\x10\x10\x00\x00\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00h\x00\x00\x02\x02\x00\x00\x006 \x00\x05\x12\x00\x10\x00\x00\x00\x00\x00\n\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\n\xf2\x00\x10\x00\x01\x00\x00\x00F\x8e \x80A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00F\x8e \x00\x00\x00\x00\x00\x01\x00\x00\x002\x00\x00\n\xf2 \x10\x00\x00\x00\x00\x00\x06\x00\x10\x00\x00\x00\x00\x00F\x0e\x10\x00\x01\x00\x00\x00F\x8e \x00\x00\x00\x00\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\x04\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\xf0\x00\x00\x00\x01\x00\x00\x00H\x00\x00\x00\x01\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00\xc5\x00\x00\x00<\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00Gradient\x00\xab\xab\xab<\x00\x00\x00\x02\x00\x00\x00`\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xa4\x00\x00\x00\x00\x00\x00\x00\xb4\x00\x00\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xa4\x00\x00\x00\x00\x00\x00\x00_gradient_color1\x00\xab\xab\xab\x01\x00\x03\x00\x01\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00_gradient_color2\x00Microsoft (R) HLSL Shader Compiler 10.1\x00\xab\xab\xabISGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x01\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
		},
		{
			Name:     "blit.frag",
			Inputs:   []driver.InputLocation{{Name: "vUV", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}},
			Textures: []driver.TextureBinding{{Name: "tex", Binding: 0}},
			GLSL100ES: `#version 100
precision mediump float;
precision highp int;

uniform mediump sampler2D tex;

varying vec2 vUV;

void main()
{
    gl_FragData[0] = texture2D(tex, vUV);
}

`,
			GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

uniform mediump sampler2D tex;

layout(location = 0) out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = texture(tex, vUV);
}

`,
			GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D tex;

out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = texture(tex, vUV);
}

`,
			GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D tex;

out vec4 fragColor;
in vec2 vUV;

void main()
{
    fragColor = texture(tex, vUV);
}

`,
			HLSL: "DXBC\xb7?\x1d\xb1\x80̀\xa3W\t\xfbZ\x9fV\xd6\xda\x01\x00\x00\x00\x94\x02\x00\x00\x06\x00\x00\x008\x00\x00\x00\xa4\x00\x00\x00\x10\x01\x00\x00\x8c\x01\x00\x00,\x02\x00\x00`\x02\x00\x00Aon9d\x00\x00\x00d\x00\x00\x00\x00\x02\xff\xff<\x00\x00\x00(\x00\x00\x00\x00\x00(\x00\x00\x00(\x00\x00\x00(\x00\x01\x00$\x00\x00\x00(\x00\x00\x00\x00\x00\x00\x02\xff\xff\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x03\xb0\x1f\x00\x00\x02\x00\x00\x00\x90\x00\b\x0f\xa0B\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\xb0\x00\b\xe4\xa0\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00SHDRd\x00\x00\x00@\x00\x00\x00\x19\x00\x00\x00Z\x00\x00\x03\x00`\x10\x00\x00\x00\x00\x00X\x18\x00\x04\x00p\x10\x00\x00\x00\x00\x00UU\x00\x00b\x10\x00\x032\x10\x10\x00\x00\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00E\x00\x00\t\xf2 \x10\x00\x00\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x00F~\x10\x00\x00\x00\x00\x00\x00`\x10\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\x98\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00m\x00\x00\x00\\\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00i\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\r\x00\x00\x00_tex_sampler\x00tex\x00Microsoft (R) HLSL Shader Compiler 10.1\x00\xab\xab\xabISGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
		},
	}
	shader_blit_vert = driver.ShaderSources{
		Name:   "blit.vert",
		Inputs: []driver.InputLocation{{Name: "pos", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}},
		Uniforms: driver.UniformsReflection{
			Blocks:    []driver.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []driver.UniformLocation{{Name: "_block.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_block.uvTransformR1", Type: 0x0, Size: 4, Offset: 16}, {Name: "_block.uvTransformR2", Type: 0x0, Size: 4, Offset: 32}, {Name: "_block.z", Type: 0x0, Size: 1, Offset: 48}},
			Size:      52,
		},
		GLSL100ES: `#version 100

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

struct Block
{
    vec4 transform;
    vec4 uvTransformR1;
    vec4 uvTransformR2;
    float z;
};

uniform Block _block;

attribute vec2 pos;
varying vec2 vUV;
attribute vec2 uv;

vec4 toClipSpace(vec4 pos_1)
{
    return pos_1;
}

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    vec2 p = (pos * _block.transform.xy) + _block.transform.zw;
    vec4 param = vec4(p, _block.z, 1.0);
    gl_Position = toClipSpace(param);
    m3x2 param_1 = m3x2(_block.uvTransformR1.xyz, _block.uvTransformR2.xyz);
    vec3 param_2 = vec3(uv, 1.0);
    vUV = transform3x2(param_1, param_2).xy;
}

`,
		GLSL300ES: `#version 300 es

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

layout(std140) uniform Block
{
    vec4 transform;
    vec4 uvTransformR1;
    vec4 uvTransformR2;
    float z;
} _block;

layout(location = 0) in vec2 pos;
out vec2 vUV;
layout(location = 1) in vec2 uv;

vec4 toClipSpace(vec4 pos_1)
{
    return pos_1;
}

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    vec2 p = (pos * _block.transform.xy) + _block.transform.zw;
    vec4 param = vec4(p, _block.z, 1.0);
    gl_Position = toClipSpace(param);
    m3x2 param_1 = m3x2(_block.uvTransformR1.xyz, _block.uvTransformR2.xyz);
    vec3 param_2 = vec3(uv, 1.0);
    vUV = transform3x2(param_1, param_2).xy;
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

struct Block
{
    vec4 transform;
    vec4 uvTransformR1;
    vec4 uvTransformR2;
    float z;
};

uniform Block _block;

in vec2 pos;
out vec2 vUV;
in vec2 uv;

vec4 toClipSpace(vec4 pos_1)
{
    return pos_1;
}

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    vec2 p = (pos * _block.transform.xy) + _block.transform.zw;
    vec4 param = vec4(p, _block.z, 1.0);
    gl_Position = toClipSpace(param);
    m3x2 param_1 = m3x2(_block.uvTransformR1.xyz, _block.uvTransformR2.xyz);
    vec3 param_2 = vec3(uv, 1.0);
    vUV = transform3x2(param_1, param_2).xy;
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

layout(binding = 0, std140) uniform Block
{
    vec4 transform;
    vec4 uvTransformR1;
    vec4 uvTransformR2;
    float z;
} _block;

in vec2 pos;
out vec2 vUV;
in vec2 uv;

vec4 toClipSpace(vec4 pos_1)
{
    return pos_1;
}

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    vec2 p = (pos * _block.transform.xy) + _block.transform.zw;
    vec4 param = vec4(p, _block.z, 1.0);
    gl_Position = toClipSpace(param);
    m3x2 param_1 = m3x2(_block.uvTransformR1.xyz, _block.uvTransformR2.xyz);
    vec3 param_2 = vec3(uv, 1.0);
    vUV = transform3x2(param_1, param_2).xy;
}

`,
		HLSL: "DXBC\x80\xa7\xa0\x9e\xbb\xa1\xa3\x1b\x85\xac\xb6\xe9\xfb\xe6W\x03\x01\x00\x00\x00\xc8\x04\x00\x00\x06\x00\x00\x008\x00\x00\x00$\x01\x00\x00T\x02\x00\x00\xd0\x02\x00\x00$\x04\x00\x00p\x04\x00\x00Aon9\xe4\x00\x00\x00\xe4\x00\x00\x00\x00\x02\xfe\xff\xb0\x00\x00\x004\x00\x00\x00\x01\x00$\x00\x00\x000\x00\x00\x000\x00\x00\x00$\x00\x01\x000\x00\x00\x00\x00\x00\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xfe\xffQ\x00\x00\x05\x05\x00\x0f\xa0\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00?\x00\x00\x00\x00\x1f\x00\x00\x02\x05\x00\x00\x80\x00\x00\x0f\x90\x1f\x00\x00\x02\x05\x00\x01\x80\x01\x00\x0f\x90\x04\x00\x00\x04\x00\x00\a\x80\x01\x00Đ\x05\x00Р\x05\x00Š\b\x00\x00\x03\x00\x00\x01\xe0\x02\x00\xe4\xa0\x00\x00\xe4\x80\b\x00\x00\x03\x00\x00\x02\xe0\x03\x00\xe4\xa0\x00\x00\xe4\x80\x04\x00\x00\x04\x00\x00\x03\x80\x00\x00\xe4\x90\x01\x00\xe4\xa0\x01\x00\xee\xa0\x02\x00\x00\x03\x00\x00\x03\xc0\x00\x00\xe4\x80\x00\x00\xe4\xa0\x01\x00\x00\x02\x00\x00\a\x80\x05\x00\xe4\xa0\x04\x00\x00\x04\x00\x00\f\xc0\x04\x00\x00\xa0\x00\x00d\x80\x00\x00$\x80\xff\xff\x00\x00SHDR(\x01\x00\x00@\x00\x01\x00J\x00\x00\x00Y\x00\x00\x04F\x8e \x00\x00\x00\x00\x00\x04\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x00\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x01\x00\x00\x00e\x00\x00\x032 \x10\x00\x00\x00\x00\x00g\x00\x00\x04\xf2 \x10\x00\x01\x00\x00\x00\x01\x00\x00\x00h\x00\x00\x02\x01\x00\x00\x006\x00\x00\x052\x00\x10\x00\x00\x00\x00\x00F\x10\x10\x00\x01\x00\x00\x006\x00\x00\x05B\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x80?\x10\x00\x00\b\x12 \x10\x00\x00\x00\x00\x00F\x82 \x00\x00\x00\x00\x00\x01\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x00\x10\x00\x00\b\" \x10\x00\x00\x00\x00\x00F\x82 \x00\x00\x00\x00\x00\x02\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x002\x00\x00\v2 \x10\x00\x01\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x00F\x80 \x00\x00\x00\x00\x00\x00\x00\x00\x00\xe6\x8a \x00\x00\x00\x00\x00\x00\x00\x00\x002\x00\x00\nB \x10\x00\x01\x00\x00\x00\n\x80 \x00\x00\x00\x00\x00\x03\x00\x00\x00\x01@\x00\x00\x00\x00\x00?\x01@\x00\x00\x00\x00\x00?6\x00\x00\x05\x82 \x10\x00\x01\x00\x00\x00\x01@\x00\x00\x00\x00\x80?>\x00\x00\x01STATt\x00\x00\x00\b\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEFL\x01\x00\x00\x01\x00\x00\x00D\x00\x00\x00\x01\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xfe\xff\x00\x01\x00\x00$\x01\x00\x00<\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00Block\x00\xab\xab<\x00\x00\x00\x04\x00\x00\x00\\\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbc\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xd0\x00\x00\x00\x00\x00\x00\x00\xe0\x00\x00\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xd0\x00\x00\x00\x00\x00\x00\x00\xf5\x00\x00\x00 \x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xd0\x00\x00\x00\x00\x00\x00\x00\n\x01\x00\x000\x00\x00\x00\x04\x00\x00\x00\x02\x00\x00\x00\x14\x01\x00\x00\x00\x00\x00\x00_block_transform\x00\xab\xab\xab\x01\x00\x03\x00\x01\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00_block_uvTransformR1\x00_block_uvTransformR2\x00_block_z\x00\xab\x00\x00\x03\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGND\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x008\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGNP\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\f\x00\x00A\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x0f\x00\x00\x00TEXCOORD\x00SV_Position\x00\xab\xab\xab",
	}
	shader_coarse_comp = driver.ShaderSources{
		Name: "coarse.comp",
		GLSL310ES: `#version 310 es
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Alloc
{
    uint offset;
};

struct MallocResult
{
    Alloc alloc;
    bool failed;
};

struct AnnoImageRef
{
    uint offset;
};

struct AnnoImage
{
    vec4 bbox;
    float linewidth;
    uint index;
    ivec2 offset;
};

struct AnnoColorRef
{
    uint offset;
};

struct AnnoColor
{
    vec4 bbox;
    float linewidth;
    uint rgba_color;
};

struct AnnoBeginClipRef
{
    uint offset;
};

struct AnnoBeginClip
{
    vec4 bbox;
    float linewidth;
};

struct AnnotatedRef
{
    uint offset;
};

struct AnnotatedTag
{
    uint tag;
    uint flags;
};

struct BinInstanceRef
{
    uint offset;
};

struct BinInstance
{
    uint element_ix;
};

struct PathRef
{
    uint offset;
};

struct TileRef
{
    uint offset;
};

struct Path
{
    uvec4 bbox;
    TileRef tiles;
};

struct TileSegRef
{
    uint offset;
};

struct Tile
{
    TileSegRef tile;
    int backdrop;
};

struct CmdStrokeRef
{
    uint offset;
};

struct CmdStroke
{
    uint tile_ref;
    float half_width;
};

struct CmdFillRef
{
    uint offset;
};

struct CmdFill
{
    uint tile_ref;
    int backdrop;
};

struct CmdColorRef
{
    uint offset;
};

struct CmdColor
{
    uint rgba_color;
};

struct CmdImageRef
{
    uint offset;
};

struct CmdImage
{
    uint index;
    ivec2 offset;
};

struct CmdJumpRef
{
    uint offset;
};

struct CmdJump
{
    uint new_ref;
};

struct CmdRef
{
    uint offset;
};

struct Config
{
    uint n_elements;
    uint n_pathseg;
    uint width_in_tiles;
    uint height_in_tiles;
    Alloc tile_alloc;
    Alloc bin_alloc;
    Alloc ptcl_alloc;
    Alloc pathseg_alloc;
    Alloc anno_alloc;
    Alloc trans_alloc;
};

layout(binding = 0, std430) buffer Memory
{
    uint mem_offset;
    uint mem_error;
    uint memory[];
} _276;

layout(binding = 1, std430) readonly buffer ConfigBuf
{
    Config conf;
} _1066;

shared uint sh_bitmaps[4][128];
shared Alloc sh_part_elements[128];
shared uint sh_part_count[128];
shared uint sh_elements[128];
shared uint sh_tile_stride[128];
shared uint sh_tile_width[128];
shared uint sh_tile_x0[128];
shared uint sh_tile_y0[128];
shared uint sh_tile_base[128];
shared uint sh_tile_count[128];

Alloc new_alloc(uint offset, uint size)
{
    Alloc a;
    a.offset = offset;
    return a;
}

Alloc slice_mem(Alloc a, uint offset, uint size)
{
    uint param = a.offset + offset;
    uint param_1 = size;
    return new_alloc(param, param_1);
}

bool touch_mem(Alloc alloc, uint offset)
{
    return true;
}

uint read_mem(Alloc alloc, uint offset)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return 0u;
    }
    uint v = _276.memory[offset];
    return v;
}

BinInstanceRef BinInstance_index(BinInstanceRef ref, uint index)
{
    return BinInstanceRef(ref.offset + (index * 4u));
}

BinInstance BinInstance_read(Alloc a, BinInstanceRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    BinInstance s;
    s.element_ix = raw0;
    return s;
}

AnnotatedTag Annotated_tag(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint tag_and_flags = read_mem(param, param_1);
    return AnnotatedTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));
}

Path Path_read(Alloc a, PathRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Path s;
    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));
    s.tiles = TileRef(raw2);
    return s;
}

void write_tile_alloc(uint el_ix, Alloc a)
{
}

Alloc read_tile_alloc(uint el_ix)
{
    uint param = 0u;
    uint param_1 = uint(int(uint(_276.memory.length())) * 4);
    return new_alloc(param, param_1);
}

Tile Tile_read(Alloc a, TileRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Tile s;
    s.tile = TileSegRef(raw0);
    s.backdrop = int(raw1);
    return s;
}

AnnoColor AnnoColor_read(Alloc a, AnnoColorRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 3u;
    uint raw3 = read_mem(param_6, param_7);
    Alloc param_8 = a;
    uint param_9 = ix + 4u;
    uint raw4 = read_mem(param_8, param_9);
    Alloc param_10 = a;
    uint param_11 = ix + 5u;
    uint raw5 = read_mem(param_10, param_11);
    AnnoColor s;
    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.linewidth = uintBitsToFloat(raw4);
    s.rgba_color = raw5;
    return s;
}

AnnoColor Annotated_Color_read(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    AnnoColorRef param_1 = AnnoColorRef(ref.offset + 4u);
    return AnnoColor_read(param, param_1);
}

MallocResult malloc(uint size)
{
    MallocResult r;
    r.failed = false;
    uint _282 = atomicAdd(_276.mem_offset, size);
    uint offset = _282;
    uint param = offset;
    uint param_1 = size;
    r.alloc = new_alloc(param, param_1);
    if ((offset + size) > uint(int(uint(_276.memory.length())) * 4))
    {
        r.failed = true;
        uint _303 = atomicMax(_276.mem_error, 1u);
        return r;
    }
    return r;
}

void write_mem(Alloc alloc, uint offset, uint val)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return;
    }
    _276.memory[offset] = val;
}

void CmdJump_write(Alloc a, CmdJumpRef ref, CmdJump s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = s.new_ref;
    write_mem(param, param_1, param_2);
}

void Cmd_Jump_write(Alloc a, CmdRef ref, CmdJump s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 9u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    CmdJumpRef param_4 = CmdJumpRef(ref.offset + 4u);
    CmdJump param_5 = s;
    CmdJump_write(param_3, param_4, param_5);
}

bool alloc_cmd(inout Alloc cmd_alloc, inout CmdRef cmd_ref, inout uint cmd_limit)
{
    if (cmd_ref.offset < cmd_limit)
    {
        return true;
    }
    uint param = 1024u;
    MallocResult _968 = malloc(param);
    MallocResult new_cmd = _968;
    if (new_cmd.failed)
    {
        return false;
    }
    CmdJump jump = CmdJump(new_cmd.alloc.offset);
    Alloc param_1 = cmd_alloc;
    CmdRef param_2 = cmd_ref;
    CmdJump param_3 = jump;
    Cmd_Jump_write(param_1, param_2, param_3);
    cmd_alloc = new_cmd.alloc;
    cmd_ref = CmdRef(cmd_alloc.offset);
    cmd_limit = (cmd_alloc.offset + 1024u) - 36u;
    return true;
}

uint fill_mode_from_flags(uint flags)
{
    return flags & 1u;
}

void CmdFill_write(Alloc a, CmdFillRef ref, CmdFill s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = s.tile_ref;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = uint(s.backdrop);
    write_mem(param_3, param_4, param_5);
}

void Cmd_Fill_write(Alloc a, CmdRef ref, CmdFill s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 1u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    CmdFillRef param_4 = CmdFillRef(ref.offset + 4u);
    CmdFill param_5 = s;
    CmdFill_write(param_3, param_4, param_5);
}

void Cmd_Solid_write(Alloc a, CmdRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 3u;
    write_mem(param, param_1, param_2);
}

void CmdStroke_write(Alloc a, CmdStrokeRef ref, CmdStroke s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = s.tile_ref;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = floatBitsToUint(s.half_width);
    write_mem(param_3, param_4, param_5);
}

void Cmd_Stroke_write(Alloc a, CmdRef ref, CmdStroke s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 2u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    CmdStrokeRef param_4 = CmdStrokeRef(ref.offset + 4u);
    CmdStroke param_5 = s;
    CmdStroke_write(param_3, param_4, param_5);
}

void write_fill(Alloc alloc, inout CmdRef cmd_ref, uint flags, Tile tile, float linewidth)
{
    uint param = flags;
    if (fill_mode_from_flags(param) == 0u)
    {
        if (tile.tile.offset != 0u)
        {
            CmdFill cmd_fill = CmdFill(tile.tile.offset, tile.backdrop);
            Alloc param_1 = alloc;
            CmdRef param_2 = cmd_ref;
            CmdFill param_3 = cmd_fill;
            Cmd_Fill_write(param_1, param_2, param_3);
            cmd_ref.offset += 12u;
        }
        else
        {
            Alloc param_4 = alloc;
            CmdRef param_5 = cmd_ref;
            Cmd_Solid_write(param_4, param_5);
            cmd_ref.offset += 4u;
        }
    }
    else
    {
        CmdStroke cmd_stroke = CmdStroke(tile.tile.offset, 0.5 * linewidth);
        Alloc param_6 = alloc;
        CmdRef param_7 = cmd_ref;
        CmdStroke param_8 = cmd_stroke;
        Cmd_Stroke_write(param_6, param_7, param_8);
        cmd_ref.offset += 12u;
    }
}

void CmdColor_write(Alloc a, CmdColorRef ref, CmdColor s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = s.rgba_color;
    write_mem(param, param_1, param_2);
}

void Cmd_Color_write(Alloc a, CmdRef ref, CmdColor s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 5u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    CmdColorRef param_4 = CmdColorRef(ref.offset + 4u);
    CmdColor param_5 = s;
    CmdColor_write(param_3, param_4, param_5);
}

AnnoImage AnnoImage_read(Alloc a, AnnoImageRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 3u;
    uint raw3 = read_mem(param_6, param_7);
    Alloc param_8 = a;
    uint param_9 = ix + 4u;
    uint raw4 = read_mem(param_8, param_9);
    Alloc param_10 = a;
    uint param_11 = ix + 5u;
    uint raw5 = read_mem(param_10, param_11);
    Alloc param_12 = a;
    uint param_13 = ix + 6u;
    uint raw6 = read_mem(param_12, param_13);
    AnnoImage s;
    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.linewidth = uintBitsToFloat(raw4);
    s.index = raw5;
    s.offset = ivec2(int(raw6 << uint(16)) >> 16, int(raw6) >> 16);
    return s;
}

AnnoImage Annotated_Image_read(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    AnnoImageRef param_1 = AnnoImageRef(ref.offset + 4u);
    return AnnoImage_read(param, param_1);
}

void CmdImage_write(Alloc a, CmdImageRef ref, CmdImage s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = s.index;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = (uint(s.offset.x) & 65535u) | (uint(s.offset.y) << uint(16));
    write_mem(param_3, param_4, param_5);
}

void Cmd_Image_write(Alloc a, CmdRef ref, CmdImage s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 6u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    CmdImageRef param_4 = CmdImageRef(ref.offset + 4u);
    CmdImage param_5 = s;
    CmdImage_write(param_3, param_4, param_5);
}

AnnoBeginClip AnnoBeginClip_read(Alloc a, AnnoBeginClipRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 3u;
    uint raw3 = read_mem(param_6, param_7);
    Alloc param_8 = a;
    uint param_9 = ix + 4u;
    uint raw4 = read_mem(param_8, param_9);
    AnnoBeginClip s;
    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.linewidth = uintBitsToFloat(raw4);
    return s;
}

AnnoBeginClip Annotated_BeginClip_read(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    AnnoBeginClipRef param_1 = AnnoBeginClipRef(ref.offset + 4u);
    return AnnoBeginClip_read(param, param_1);
}

void Cmd_BeginClip_write(Alloc a, CmdRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 7u;
    write_mem(param, param_1, param_2);
}

void Cmd_EndClip_write(Alloc a, CmdRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 8u;
    write_mem(param, param_1, param_2);
}

void Cmd_End_write(Alloc a, CmdRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 0u;
    write_mem(param, param_1, param_2);
}

void alloc_write(Alloc a, uint offset, Alloc alloc)
{
    Alloc param = a;
    uint param_1 = offset >> uint(2);
    uint param_2 = alloc.offset;
    write_mem(param, param_1, param_2);
}

void main()
{
    if (_276.mem_error != 0u)
    {
        return;
    }
    uint width_in_bins = ((_1066.conf.width_in_tiles + 16u) - 1u) / 16u;
    uint bin_ix = (width_in_bins * gl_WorkGroupID.y) + gl_WorkGroupID.x;
    uint partition_ix = 0u;
    uint n_partitions = ((_1066.conf.n_elements + 128u) - 1u) / 128u;
    uint th_ix = gl_LocalInvocationID.x;
    uint bin_tile_x = 16u * gl_WorkGroupID.x;
    uint bin_tile_y = 8u * gl_WorkGroupID.y;
    uint tile_x = gl_LocalInvocationID.x % 16u;
    uint tile_y = gl_LocalInvocationID.x / 16u;
    uint this_tile_ix = (((bin_tile_y + tile_y) * _1066.conf.width_in_tiles) + bin_tile_x) + tile_x;
    Alloc param;
    param.offset = _1066.conf.ptcl_alloc.offset;
    uint param_1 = this_tile_ix * 1024u;
    uint param_2 = 1024u;
    Alloc cmd_alloc = slice_mem(param, param_1, param_2);
    CmdRef cmd_ref = CmdRef(cmd_alloc.offset);
    uint cmd_limit = (cmd_ref.offset + 1024u) - 36u;
    uint clip_depth = 0u;
    uint clip_zero_depth = 0u;
    uint clip_one_mask = 0u;
    uint rd_ix = 0u;
    uint wr_ix = 0u;
    uint part_start_ix = 0u;
    uint ready_ix = 0u;
    Alloc param_3 = cmd_alloc;
    uint param_4 = 0u;
    uint param_5 = 8u;
    Alloc scratch_alloc = slice_mem(param_3, param_4, param_5);
    cmd_ref.offset += 8u;
    uint num_begin_slots = 0u;
    uint begin_slot = 0u;
    Alloc param_6;
    Alloc param_8;
    uint _1354;
    uint element_ix;
    AnnotatedRef ref;
    Alloc param_16;
    Alloc param_18;
    uint tile_count;
    Alloc param_24;
    uint _1667;
    bool include_tile;
    Alloc param_29;
    Tile tile_1;
    Alloc param_34;
    Alloc param_50;
    Alloc param_66;
    while (true)
    {
        for (uint i = 0u; i < 4u; i++)
        {
            sh_bitmaps[i][th_ix] = 0u;
        }
        bool _1406;
        for (;;)
        {
            if ((ready_ix == wr_ix) && (partition_ix < n_partitions))
            {
                part_start_ix = ready_ix;
                uint count = 0u;
                bool _1204 = th_ix < 128u;
                bool _1212;
                if (_1204)
                {
                    _1212 = (partition_ix + th_ix) < n_partitions;
                }
                else
                {
                    _1212 = _1204;
                }
                if (_1212)
                {
                    uint in_ix = (_1066.conf.bin_alloc.offset >> uint(2)) + ((((partition_ix + th_ix) * 128u) + bin_ix) * 2u);
                    param_6.offset = _1066.conf.bin_alloc.offset;
                    uint param_7 = in_ix;
                    count = read_mem(param_6, param_7);
                    param_8.offset = _1066.conf.bin_alloc.offset;
                    uint param_9 = in_ix + 1u;
                    uint offset = read_mem(param_8, param_9);
                    uint param_10 = offset;
                    uint param_11 = count * 4u;
                    sh_part_elements[th_ix] = new_alloc(param_10, param_11);
                }
                for (uint i_1 = 0u; i_1 < 7u; i_1++)
                {
                    if (th_ix < 128u)
                    {
                        sh_part_count[th_ix] = count;
                    }
                    barrier();
                    if (th_ix < 128u)
                    {
                        if (th_ix >= uint(1 << int(i_1)))
                        {
                            count += sh_part_count[th_ix - uint(1 << int(i_1))];
                        }
                    }
                    barrier();
                }
                if (th_ix < 128u)
                {
                    sh_part_count[th_ix] = part_start_ix + count;
                }
                barrier();
                ready_ix = sh_part_count[127];
                partition_ix += 128u;
            }
            uint ix = rd_ix + th_ix;
            if ((ix >= wr_ix) && (ix < ready_ix))
            {
                uint part_ix = 0u;
                for (uint i_2 = 0u; i_2 < 7u; i_2++)
                {
                    uint probe = part_ix + uint(64 >> int(i_2));
                    if (ix >= sh_part_count[probe - 1u])
                    {
                        part_ix = probe;
                    }
                }
                if (part_ix > 0u)
                {
                    _1354 = sh_part_count[part_ix - 1u];
                }
                else
                {
                    _1354 = part_start_ix;
                }
                ix -= _1354;
                Alloc bin_alloc = sh_part_elements[part_ix];
                BinInstanceRef inst_ref = BinInstanceRef(bin_alloc.offset);
                BinInstanceRef param_12 = inst_ref;
                uint param_13 = ix;
                Alloc param_14 = bin_alloc;
                BinInstanceRef param_15 = BinInstance_index(param_12, param_13);
                BinInstance inst = BinInstance_read(param_14, param_15);
                sh_elements[th_ix] = inst.element_ix;
            }
            barrier();
            wr_ix = min((rd_ix + 128u), ready_ix);
            bool _1396 = (wr_ix - rd_ix) < 128u;
            if (_1396)
            {
                _1406 = (wr_ix < ready_ix) || (partition_ix < n_partitions);
            }
            else
            {
                _1406 = _1396;
            }
            if (_1406)
            {
                continue;
            }
            else
            {
                break;
            }
        }
        uint tag = 0u;
        if ((th_ix + rd_ix) < wr_ix)
        {
            element_ix = sh_elements[th_ix];
            ref = AnnotatedRef(_1066.conf.anno_alloc.offset + (element_ix * 32u));
            param_16.offset = _1066.conf.anno_alloc.offset;
            AnnotatedRef param_17 = ref;
            tag = Annotated_tag(param_16, param_17).tag;
        }
        switch (tag)
        {
            case 1u:
            case 2u:
            case 3u:
            case 4u:
            {
                uint path_ix = element_ix;
                param_18.offset = _1066.conf.tile_alloc.offset;
                PathRef param_19 = PathRef(_1066.conf.tile_alloc.offset + (path_ix * 12u));
                Path path = Path_read(param_18, param_19);
                uint stride = path.bbox.z - path.bbox.x;
                sh_tile_stride[th_ix] = stride;
                int dx = int(path.bbox.x) - int(bin_tile_x);
                int dy = int(path.bbox.y) - int(bin_tile_y);
                int x0 = clamp(dx, 0, 16);
                int y0 = clamp(dy, 0, 8);
                int x1 = clamp(int(path.bbox.z) - int(bin_tile_x), 0, 16);
                int y1 = clamp(int(path.bbox.w) - int(bin_tile_y), 0, 8);
                sh_tile_width[th_ix] = uint(x1 - x0);
                sh_tile_x0[th_ix] = uint(x0);
                sh_tile_y0[th_ix] = uint(y0);
                tile_count = uint(x1 - x0) * uint(y1 - y0);
                uint base = path.tiles.offset - (((uint(dy) * stride) + uint(dx)) * 8u);
                sh_tile_base[th_ix] = base;
                uint param_20 = path.tiles.offset;
                uint param_21 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;
                Alloc path_alloc = new_alloc(param_20, param_21);
                uint param_22 = th_ix;
                Alloc param_23 = path_alloc;
                write_tile_alloc(param_22, param_23);
                break;
            }
            default:
            {
                tile_count = 0u;
                break;
            }
        }
        sh_tile_count[th_ix] = tile_count;
        for (uint i_3 = 0u; i_3 < 7u; i_3++)
        {
            barrier();
            if (th_ix >= uint(1 << int(i_3)))
            {
                tile_count += sh_tile_count[th_ix - uint(1 << int(i_3))];
            }
            barrier();
            sh_tile_count[th_ix] = tile_count;
        }
        barrier();
        uint total_tile_count = sh_tile_count[127];
        for (uint ix_1 = th_ix; ix_1 < total_tile_count; ix_1 += 128u)
        {
            uint el_ix = 0u;
            for (uint i_4 = 0u; i_4 < 7u; i_4++)
            {
                uint probe_1 = el_ix + uint(64 >> int(i_4));
                if (ix_1 >= sh_tile_count[probe_1 - 1u])
                {
                    el_ix = probe_1;
                }
            }
            AnnotatedRef ref_1 = AnnotatedRef(_1066.conf.anno_alloc.offset + (sh_elements[el_ix] * 32u));
            param_24.offset = _1066.conf.anno_alloc.offset;
            AnnotatedRef param_25 = ref_1;
            uint tag_1 = Annotated_tag(param_24, param_25).tag;
            if (el_ix > 0u)
            {
                _1667 = sh_tile_count[el_ix - 1u];
            }
            else
            {
                _1667 = 0u;
            }
            uint seq_ix = ix_1 - _1667;
            uint width = sh_tile_width[el_ix];
            uint x = sh_tile_x0[el_ix] + (seq_ix % width);
            uint y = sh_tile_y0[el_ix] + (seq_ix / width);
            if ((tag_1 == 3u) || (tag_1 == 4u))
            {
                include_tile = true;
            }
            else
            {
                uint param_26 = el_ix;
                Alloc param_27 = read_tile_alloc(param_26);
                TileRef param_28 = TileRef(sh_tile_base[el_ix] + (((sh_tile_stride[el_ix] * y) + x) * 8u));
                Tile tile = Tile_read(param_27, param_28);
                bool _1728 = tile.tile.offset != 0u;
                bool _1735;
                if (!_1728)
                {
                    _1735 = tile.backdrop != 0;
                }
                else
                {
                    _1735 = _1728;
                }
                include_tile = _1735;
            }
            if (include_tile)
            {
                uint el_slice = el_ix / 32u;
                uint el_mask = uint(1 << int(el_ix & 31u));
                uint _1755 = atomicOr(sh_bitmaps[el_slice][(y * 16u) + x], el_mask);
            }
        }
        barrier();
        uint slice_ix = 0u;
        uint bitmap = sh_bitmaps[0][th_ix];
        while (true)
        {
            if (bitmap == 0u)
            {
                slice_ix++;
                if (slice_ix == 4u)
                {
                    break;
                }
                bitmap = sh_bitmaps[slice_ix][th_ix];
                if (bitmap == 0u)
                {
                    continue;
                }
            }
            uint element_ref_ix = (slice_ix * 32u) + uint(findLSB(bitmap));
            uint element_ix_1 = sh_elements[element_ref_ix];
            bitmap &= (bitmap - 1u);
            ref = AnnotatedRef(_1066.conf.anno_alloc.offset + (element_ix_1 * 32u));
            param_29.offset = _1066.conf.anno_alloc.offset;
            AnnotatedRef param_30 = ref;
            AnnotatedTag tag_2 = Annotated_tag(param_29, param_30);
            if (clip_zero_depth == 0u)
            {
                switch (tag_2.tag)
                {
                    case 1u:
                    {
                        uint param_31 = element_ref_ix;
                        Alloc param_32 = read_tile_alloc(param_31);
                        TileRef param_33 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));
                        tile_1 = Tile_read(param_32, param_33);
                        param_34.offset = _1066.conf.anno_alloc.offset;
                        AnnotatedRef param_35 = ref;
                        AnnoColor fill = Annotated_Color_read(param_34, param_35);
                        Alloc param_36 = cmd_alloc;
                        CmdRef param_37 = cmd_ref;
                        uint param_38 = cmd_limit;
                        bool _1865 = alloc_cmd(param_36, param_37, param_38);
                        cmd_alloc = param_36;
                        cmd_ref = param_37;
                        cmd_limit = param_38;
                        if (!_1865)
                        {
                            break;
                        }
                        Alloc param_39 = cmd_alloc;
                        CmdRef param_40 = cmd_ref;
                        uint param_41 = tag_2.flags;
                        Tile param_42 = tile_1;
                        float param_43 = fill.linewidth;
                        write_fill(param_39, param_40, param_41, param_42, param_43);
                        cmd_ref = param_40;
                        Alloc param_44 = cmd_alloc;
                        CmdRef param_45 = cmd_ref;
                        CmdColor param_46 = CmdColor(fill.rgba_color);
                        Cmd_Color_write(param_44, param_45, param_46);
                        cmd_ref.offset += 8u;
                        break;
                    }
                    case 2u:
                    {
                        uint param_47 = element_ref_ix;
                        Alloc param_48 = read_tile_alloc(param_47);
                        TileRef param_49 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));
                        tile_1 = Tile_read(param_48, param_49);
                        param_50.offset = _1066.conf.anno_alloc.offset;
                        AnnotatedRef param_51 = ref;
                        AnnoImage fill_img = Annotated_Image_read(param_50, param_51);
                        Alloc param_52 = cmd_alloc;
                        CmdRef param_53 = cmd_ref;
                        uint param_54 = cmd_limit;
                        bool _1935 = alloc_cmd(param_52, param_53, param_54);
                        cmd_alloc = param_52;
                        cmd_ref = param_53;
                        cmd_limit = param_54;
                        if (!_1935)
                        {
                            break;
                        }
                        Alloc param_55 = cmd_alloc;
                        CmdRef param_56 = cmd_ref;
                        uint param_57 = tag_2.flags;
                        Tile param_58 = tile_1;
                        float param_59 = fill_img.linewidth;
                        write_fill(param_55, param_56, param_57, param_58, param_59);
                        cmd_ref = param_56;
                        Alloc param_60 = cmd_alloc;
                        CmdRef param_61 = cmd_ref;
                        CmdImage param_62 = CmdImage(fill_img.index, fill_img.offset);
                        Cmd_Image_write(param_60, param_61, param_62);
                        cmd_ref.offset += 12u;
                        break;
                    }
                    case 3u:
                    {
                        uint param_63 = element_ref_ix;
                        Alloc param_64 = read_tile_alloc(param_63);
                        TileRef param_65 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));
                        tile_1 = Tile_read(param_64, param_65);
                        bool _1994 = tile_1.tile.offset == 0u;
                        bool _2000;
                        if (_1994)
                        {
                            _2000 = tile_1.backdrop == 0;
                        }
                        else
                        {
                            _2000 = _1994;
                        }
                        if (_2000)
                        {
                            clip_zero_depth = clip_depth + 1u;
                        }
                        else
                        {
                            if ((tile_1.tile.offset == 0u) && (clip_depth < 32u))
                            {
                                clip_one_mask |= uint(1 << int(clip_depth));
                            }
                            else
                            {
                                param_66.offset = _1066.conf.anno_alloc.offset;
                                AnnotatedRef param_67 = ref;
                                AnnoBeginClip begin_clip = Annotated_BeginClip_read(param_66, param_67);
                                Alloc param_68 = cmd_alloc;
                                CmdRef param_69 = cmd_ref;
                                uint param_70 = cmd_limit;
                                bool _2035 = alloc_cmd(param_68, param_69, param_70);
                                cmd_alloc = param_68;
                                cmd_ref = param_69;
                                cmd_limit = param_70;
                                if (!_2035)
                                {
                                    break;
                                }
                                Alloc param_71 = cmd_alloc;
                                CmdRef param_72 = cmd_ref;
                                uint param_73 = tag_2.flags;
                                Tile param_74 = tile_1;
                                float param_75 = begin_clip.linewidth;
                                write_fill(param_71, param_72, param_73, param_74, param_75);
                                cmd_ref = param_72;
                                Alloc param_76 = cmd_alloc;
                                CmdRef param_77 = cmd_ref;
                                Cmd_BeginClip_write(param_76, param_77);
                                cmd_ref.offset += 4u;
                                if (clip_depth < 32u)
                                {
                                    clip_one_mask &= uint(~(1 << int(clip_depth)));
                                }
                                begin_slot++;
                                num_begin_slots = max(num_begin_slots, begin_slot);
                            }
                        }
                        clip_depth++;
                        break;
                    }
                    case 4u:
                    {
                        clip_depth--;
                        bool _2087 = clip_depth >= 32u;
                        bool _2097;
                        if (!_2087)
                        {
                            _2097 = (clip_one_mask & uint(1 << int(clip_depth))) == 0u;
                        }
                        else
                        {
                            _2097 = _2087;
                        }
                        if (_2097)
                        {
                            Alloc param_78 = cmd_alloc;
                            CmdRef param_79 = cmd_ref;
                            uint param_80 = cmd_limit;
                            bool _2106 = alloc_cmd(param_78, param_79, param_80);
                            cmd_alloc = param_78;
                            cmd_ref = param_79;
                            cmd_limit = param_80;
                            if (!_2106)
                            {
                                break;
                            }
                            Alloc param_81 = cmd_alloc;
                            CmdRef param_82 = cmd_ref;
                            Cmd_Solid_write(param_81, param_82);
                            cmd_ref.offset += 4u;
                            begin_slot--;
                            Alloc param_83 = cmd_alloc;
                            CmdRef param_84 = cmd_ref;
                            Cmd_EndClip_write(param_83, param_84);
                            cmd_ref.offset += 4u;
                        }
                        break;
                    }
                }
            }
            else
            {
                switch (tag_2.tag)
                {
                    case 3u:
                    {
                        clip_depth++;
                        break;
                    }
                    case 4u:
                    {
                        if (clip_depth == clip_zero_depth)
                        {
                            clip_zero_depth = 0u;
                        }
                        clip_depth--;
                        break;
                    }
                }
            }
        }
        barrier();
        rd_ix += 128u;
        if ((rd_ix >= ready_ix) && (partition_ix >= n_partitions))
        {
            break;
        }
    }
    bool _2171 = (bin_tile_x + tile_x) < _1066.conf.width_in_tiles;
    bool _2180;
    if (_2171)
    {
        _2180 = (bin_tile_y + tile_y) < _1066.conf.height_in_tiles;
    }
    else
    {
        _2180 = _2171;
    }
    if (_2180)
    {
        Alloc param_85 = cmd_alloc;
        CmdRef param_86 = cmd_ref;
        Cmd_End_write(param_85, param_86);
        if (num_begin_slots > 0u)
        {
            uint scratch_size = (((num_begin_slots * 32u) * 32u) * 2u) * 4u;
            uint param_87 = scratch_size;
            MallocResult _2201 = malloc(param_87);
            MallocResult scratch = _2201;
            Alloc param_88 = scratch_alloc;
            uint param_89 = scratch_alloc.offset;
            Alloc param_90 = scratch.alloc;
            alloc_write(param_88, param_89, param_90);
        }
    }
}

`,
	}
	shader_copy_frag = driver.ShaderSources{
		Name:     "copy.frag",
		Textures: []driver.TextureBinding{{Name: "tex", Binding: 0}},
		GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

uniform mediump sampler2D tex;

layout(location = 0) out highp vec4 fragColor;

highp vec3 sRGBtoRGB(highp vec3 rgb)
{
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));
    highp vec3 below = rgb / vec3(12.9200000762939453125);
    highp vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));
    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);
}

void main()
{
    highp vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);
    highp vec3 param = texel.xyz;
    highp vec3 rgb = sRGBtoRGB(param);
    fragColor = vec4(rgb, texel.w);
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D tex;

out vec4 fragColor;

vec3 sRGBtoRGB(vec3 rgb)
{
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));
    vec3 below = rgb / vec3(12.9200000762939453125);
    vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));
    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);
}

void main()
{
    vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);
    vec3 param = texel.xyz;
    vec3 rgb = sRGBtoRGB(param);
    fragColor = vec4(rgb, texel.w);
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D tex;

out vec4 fragColor;

vec3 sRGBtoRGB(vec3 rgb)
{
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));
    vec3 below = rgb / vec3(12.9200000762939453125);
    vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));
    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);
}

void main()
{
    vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);
    vec3 param = texel.xyz;
    vec3 rgb = sRGBtoRGB(param);
    fragColor = vec4(rgb, texel.w);
}

`,
		HLSL: "DXBC\xe6\x89_t\x8b\xfc\xea8\xd9'\xad5.Èk\x01\x00\x00\x00H\x03\x00\x00\x05\x00\x00\x004\x00\x00\x00\xa4\x00\x00\x00\xd8\x00\x00\x00\f\x01\x00\x00\xcc\x02\x00\x00RDEFh\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00@\x00\x00\x00<\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\r\x00\x00\x00tex\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x03\x00\x00SV_Position\x00OSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xabSHDR\xb8\x01\x00\x00@\x00\x00\x00n\x00\x00\x00X\x18\x00\x04\x00p\x10\x00\x00\x00\x00\x00UU\x00\x00d \x00\x042\x10\x10\x00\x00\x00\x00\x00\x01\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00h\x00\x00\x02\x03\x00\x00\x00\x1b\x00\x00\x052\x00\x10\x00\x00\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x006\x00\x00\b\xc2\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\x00\x00\a\xf2\x00\x10\x00\x00\x00\x00\x00F\x0e\x10\x00\x00\x00\x00\x00F~\x10\x00\x00\x00\x00\x00\x00\x00\x00\nr\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x00\x02@\x00\x00\xaeGa=\xaeGa=\xaeGa=\x00\x00\x00\x008\x00\x00\nr\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x00\x02@\x00\x00o\xa7r?o\xa7r?o\xa7r?\x00\x00\x00\x00/\x00\x00\x05r\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x008\x00\x00\nr\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x00\x02@\x00\x00\x9a\x99\x19@\x9a\x99\x19@\x9a\x99\x19@\x00\x00\x00\x00\x19\x00\x00\x05r\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x00\x1d\x00\x00\nr\x00\x10\x00\x02\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x00\x02@\x00\x00\xe6\xae%=\xe6\xae%=\xe6\xae%=\x00\x00\x00\x008\x00\x00\nr\x00\x10\x00\x00\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x91\x83\x9e=\x91\x83\x9e=\x91\x83\x9e=\x00\x00\x00\x006\x00\x00\x05\x82 \x10\x00\x00\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x007\x00\x00\tr \x10\x00\x00\x00\x00\x00F\x02\x10\x00\x02\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\r\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	}
	shader_copy_vert = driver.ShaderSources{
		Name: "copy.vert",
		GLSL100ES: `#version 100

void main()
{
    for (int spvDummy6 = 0; spvDummy6 < 1; spvDummy6++)
    {
        if (gl_VertexID == 0)
        {
            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);
            break;
        }
        else if (gl_VertexID == 1)
        {
            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);
            break;
        }
        else if (gl_VertexID == 2)
        {
            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);
            break;
        }
        else if (gl_VertexID == 3)
        {
            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);
            break;
        }
    }
}

`,
		GLSL300ES: `#version 300 es

void main()
{
    switch (gl_VertexID)
    {
        case 0:
        {
            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);
            break;
        }
        case 1:
        {
            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);
            break;
        }
        case 2:
        {
            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);
            break;
        }
        case 3:
        {
            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);
            break;
        }
    }
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

void main()
{
    switch (gl_VertexID)
    {
        case 0:
        {
            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);
            break;
        }
        case 1:
        {
            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);
            break;
        }
        case 2:
        {
            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);
            break;
        }
        case 3:
        {
            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);
            break;
        }
    }
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

void main()
{
    switch (gl_VertexID)
    {
        case 0:
        {
            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);
            break;
        }
        case 1:
        {
            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);
            break;
        }
        case 2:
        {
            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);
            break;
        }
        case 3:
        {
            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);
            break;
        }
    }
}

`,
		HLSL: "DXBC\x99\xb4[\xef]IX\xa2Qh\x9f\xb6!\x1cR\xe7\x01\x00\x00\x00\xc0\x02\x00\x00\x05\x00\x00\x004\x00\x00\x00\x80\x00\x00\x00\xb4\x00\x00\x00\xe8\x00\x00\x00D\x02\x00\x00RDEFD\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xfe\xff\x00\x01\x00\x00\x1c\x00\x00\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x01\x00\x00SV_VertexID\x00OSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Position\x00SHDRT\x01\x00\x00@\x00\x01\x00U\x00\x00\x00`\x00\x00\x04\x12\x10\x10\x00\x00\x00\x00\x00\x06\x00\x00\x00g\x00\x00\x04\xf2 \x10\x00\x00\x00\x00\x00\x01\x00\x00\x00h\x00\x00\x02\x01\x00\x00\x00L\x00\x00\x03\n\x10\x10\x00\x00\x00\x00\x00\x06\x00\x00\x03\x01@\x00\x00\x00\x00\x00\x006\x00\x00\br\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x80\xbf\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x02\x00\x00\x01\x06\x00\x00\x03\x01@\x00\x00\x01\x00\x00\x006\x00\x00\br\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x02\x00\x00\x01\x06\x00\x00\x03\x01@\x00\x00\x02\x00\x00\x006\x00\x00\br\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x80\xbf\x00\x00\x80\xbf\x00\x00\x80?\x00\x00\x00\x00\x02\x00\x00\x01\x06\x00\x00\x03\x01@\x00\x00\x03\x00\x00\x006\x00\x00\br\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x80?\x00\x00\x80\xbf\x00\x00\x80?\x00\x00\x00\x00\x02\x00\x00\x01\n\x00\x00\x016\x00\x00\br\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x01\x17\x00\x00\x016\x00\x00\x05\xb2 \x10\x00\x00\x00\x00\x00F\b\x10\x00\x00\x00\x00\x006\x00\x00\x05B \x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\x14\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	}
	shader_cover_frag = [...]driver.ShaderSources{
		{
			Name:   "cover.frag",
			Inputs: []driver.InputLocation{{Name: "vCoverUV", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "vUV", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}},
			Uniforms: driver.UniformsReflection{
				Blocks:    []driver.UniformBlock{{Name: "Color", Binding: 0}},
				Locations: []driver.UniformLocation{{Name: "_color.color", Type: 0x0, Size: 4, Offset: 0}},
				Size:      16,
			},
			Textures: []driver.TextureBinding{{Name: "cover", Binding: 1}},
			GLSL100ES: `#version 100
precision mediump float;
precision highp int;

struct Color
{
    vec4 color;
};

uniform Color _color;

uniform mediump sampler2D cover;

varying highp vec2 vCoverUV;
varying vec2 vUV;

void main()
{
    gl_FragData[0] = _color.color;
    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);
    gl_FragData[0] *= cover_1;
}

`,
			GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform Color
{
    vec4 color;
} _color;

uniform mediump sampler2D cover;

layout(location = 0) out vec4 fragColor;
in highp vec2 vCoverUV;
in vec2 vUV;

void main()
{
    fragColor = _color.color;
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct Color
{
    vec4 color;
};

uniform Color _color;

layout(binding = 1) uniform sampler2D cover;

out vec4 fragColor;
in vec2 vCoverUV;
in vec2 vUV;

void main()
{
    fragColor = _color.color;
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0, std140) uniform Color
{
    vec4 color;
} _color;

layout(binding = 1) uniform sampler2D cover;

out vec4 fragColor;
in vec2 vCoverUV;
in vec2 vUV;

void main()
{
    fragColor = _color.color;
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			HLSL: "DXBC\x88\x01{\x0f\x94\xca3\xeb\xab߸\xa1\xbfL1\xbf\x01\x00\x00\x00\xa4\x03\x00\x00\x06\x00\x00\x008\x00\x00\x00\xcc\x00\x00\x00\x90\x01\x00\x00\f\x02\x00\x00$\x03\x00\x00p\x03\x00\x00Aon9\x8c\x00\x00\x00\x8c\x00\x00\x00\x00\x02\xff\xffX\x00\x00\x004\x00\x00\x00\x01\x00(\x00\x00\x004\x00\x00\x004\x00\x01\x00$\x00\x00\x004\x00\x01\x01\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x02\xff\xff\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x0f\xb0\x1f\x00\x00\x02\x00\x00\x00\x90\x00\b\x0f\xa0B\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\xb0\x00\b\xe4\xa0#\x00\x00\x02\x00\x00\x11\x80\x00\x00\x00\x80\x05\x00\x00\x03\x00\x00\x0f\x80\x00\x00\x00\x80\x00\x00\xe4\xa0\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00SHDR\xbc\x00\x00\x00@\x00\x00\x00/\x00\x00\x00Y\x00\x00\x04F\x8e \x00\x00\x00\x00\x00\x01\x00\x00\x00Z\x00\x00\x03\x00`\x10\x00\x01\x00\x00\x00X\x18\x00\x04\x00p\x10\x00\x01\x00\x00\x00UU\x00\x00b\x10\x00\x032\x10\x10\x00\x00\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00h\x00\x00\x02\x01\x00\x00\x00E\x00\x00\t\xf2\x00\x10\x00\x00\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x00F~\x10\x00\x01\x00\x00\x00\x00`\x10\x00\x01\x00\x00\x003\x00\x00\b\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x80\x81\x00\x00\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x80?8\x00\x00\b\xf2 \x10\x00\x00\x00\x00\x00\x06\x00\x10\x00\x00\x00\x00\x00F\x8e \x00\x00\x00\x00\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\x04\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\x10\x01\x00\x00\x01\x00\x00\x00\x98\x00\x00\x00\x03\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00\xe8\x00\x00\x00|\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x8b\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\r\x00\x00\x00\x91\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00_cover_sampler\x00cover\x00Color\x00\xab\x91\x00\x00\x00\x01\x00\x00\x00\xb0\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xd8\x00\x00\x00\x00\x00\x00\x00_color_color\x00\xab\xab\xab\x01\x00\x03\x00\x01\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGND\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x008\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\f\x00\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
		},
		{
			Name:   "cover.frag",
			Inputs: []driver.InputLocation{{Name: "vCoverUV", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "vUV", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}},
			Uniforms: driver.UniformsReflection{
				Blocks:    []driver.UniformBlock{{Name: "Gradient", Binding: 0}},
				Locations: []driver.UniformLocation{{Name: "_gradient.color1", Type: 0x0, Size: 4, Offset: 0}, {Name: "_gradient.color2", Type: 0x0, Size: 4, Offset: 16}},
				Size:      32,
			},
			Textures: []driver.TextureBinding{{Name: "cover", Binding: 1}},
			GLSL100ES: `#version 100
precision mediump float;
precision highp int;

struct Gradient
{
    vec4 color1;
    vec4 color2;
};

uniform Gradient _gradient;

uniform mediump sampler2D cover;

varying vec2 vUV;
varying highp vec2 vCoverUV;

void main()
{
    gl_FragData[0] = mix(_gradient.color1, _gradient.color2, vec4(clamp(vUV.x, 0.0, 1.0)));
    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);
    gl_FragData[0] *= cover_1;
}

`,
			GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform Gradient
{
    vec4 color1;
    vec4 color2;
} _gradient;

uniform mediump sampler2D cover;

layout(location = 0) out vec4 fragColor;
in vec2 vUV;
in highp vec2 vCoverUV;

void main()
{
    fragColor = mix(_gradient.color1, _gradient.color2, vec4(clamp(vUV.x, 0.0, 1.0)));
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct Gradient
{
    vec4 color1;
    vec4 color2;
};

uniform Gradient _gradient;

layout(binding = 1) uniform sampler2D cover;

out vec4 fragColor;
in vec2 vUV;
in vec2 vCoverUV;

void main()
{
    fragColor = mix(_gradient.color1, _gradient.color2, vec4(clamp(vUV.x, 0.0, 1.0)));
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0, std140) uniform Gradient
{
    vec4 color1;
    vec4 color2;
} _gradient;

layout(binding = 1) uniform sampler2D cover;

out vec4 fragColor;
in vec2 vUV;
in vec2 vCoverUV;

void main()
{
    fragColor = mix(_gradient.color1, _gradient.color2, vec4(clamp(vUV.x, 0.0, 1.0)));
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			HLSL: "DXBCj\xa0\x9e\x8d\x1eÌO\rJ\xea\x8f\x17\x11o\x98\x01\x00\x00\x00\x80\x04\x00\x00\x06\x00\x00\x008\x00\x00\x00\b\x01\x00\x008\x02\x00\x00\xb4\x02\x00\x00\x00\x04\x00\x00L\x04\x00\x00Aon9\xc8\x00\x00\x00\xc8\x00\x00\x00\x00\x02\xff\xff\x94\x00\x00\x004\x00\x00\x00\x01\x00(\x00\x00\x004\x00\x00\x004\x00\x01\x00$\x00\x00\x004\x00\x01\x01\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x02\xff\xff\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x0f\xb0\x1f\x00\x00\x02\x00\x00\x00\x90\x00\b\x0f\xa0B\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\xb0\x00\b\xe4\xa0\x01\x00\x00\x02\x00\x00\x12\x80\x00\x00\xff\xb0\x01\x00\x00\x02\x01\x00\x0f\x80\x00\x00\xe4\xa0\x02\x00\x00\x03\x01\x00\x0f\x80\x01\x00\xe4\x81\x01\x00\xe4\xa0\x04\x00\x00\x04\x01\x00\x0f\x80\x00\x00U\x80\x01\x00\xe4\x80\x00\x00\xe4\xa0#\x00\x00\x02\x00\x00\x11\x80\x00\x00\x00\x80\x05\x00\x00\x03\x00\x00\x0f\x80\x00\x00\x00\x80\x01\x00\xe4\x80\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00SHDR(\x01\x00\x00@\x00\x00\x00J\x00\x00\x00Y\x00\x00\x04F\x8e \x00\x00\x00\x00\x00\x02\x00\x00\x00Z\x00\x00\x03\x00`\x10\x00\x01\x00\x00\x00X\x18\x00\x04\x00p\x10\x00\x01\x00\x00\x00UU\x00\x00b\x10\x00\x032\x10\x10\x00\x00\x00\x00\x00b\x10\x00\x03B\x10\x10\x00\x00\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00h\x00\x00\x02\x02\x00\x00\x006 \x00\x05\x12\x00\x10\x00\x00\x00\x00\x00*\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\n\xf2\x00\x10\x00\x01\x00\x00\x00F\x8e \x80A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00F\x8e \x00\x00\x00\x00\x00\x01\x00\x00\x002\x00\x00\n\xf2\x00\x10\x00\x00\x00\x00\x00\x06\x00\x10\x00\x00\x00\x00\x00F\x0e\x10\x00\x01\x00\x00\x00F\x8e \x00\x00\x00\x00\x00\x00\x00\x00\x00E\x00\x00\t\xf2\x00\x10\x00\x01\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x00F~\x10\x00\x01\x00\x00\x00\x00`\x10\x00\x01\x00\x00\x003\x00\x00\b\x12\x00\x10\x00\x01\x00\x00\x00\n\x00\x10\x80\x81\x00\x00\x00\x01\x00\x00\x00\x01@\x00\x00\x00\x00\x80?8\x00\x00\a\xf2 \x10\x00\x00\x00\x00\x00F\x0e\x10\x00\x00\x00\x00\x00\x06\x00\x10\x00\x01\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\a\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEFD\x01\x00\x00\x01\x00\x00\x00\x9c\x00\x00\x00\x03\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00\x19\x01\x00\x00|\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x8b\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\r\x00\x00\x00\x91\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00_cover_sampler\x00cover\x00Gradient\x00\xab\xab\x91\x00\x00\x00\x02\x00\x00\x00\xb4\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe4\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xf8\x00\x00\x00\x00\x00\x00\x00\b\x01\x00\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xf8\x00\x00\x00\x00\x00\x00\x00_gradient_color1\x00\xab\xab\xab\x01\x00\x03\x00\x01\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00_gradient_color2\x00Microsoft (R) HLSL Shader Compiler 10.1\x00\xab\xab\xabISGND\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x008\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\f\x04\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
		},
		{
			Name:     "cover.frag",
			Inputs:   []driver.InputLocation{{Name: "vCoverUV", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "vUV", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}},
			Textures: []driver.TextureBinding{{Name: "tex", Binding: 0}, {Name: "cover", Binding: 1}},
			GLSL100ES: `#version 100
precision mediump float;
precision highp int;

uniform mediump sampler2D tex;
uniform mediump sampler2D cover;

varying vec2 vUV;
varying highp vec2 vCoverUV;

void main()
{
    gl_FragData[0] = texture2D(tex, vUV);
    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);
    gl_FragData[0] *= cover_1;
}

`,
			GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

uniform mediump sampler2D tex;
uniform mediump sampler2D cover;

layout(location = 0) out vec4 fragColor;
in vec2 vUV;
in highp vec2 vCoverUV;

void main()
{
    fragColor = texture(tex, vUV);
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D tex;
layout(binding = 1) uniform sampler2D cover;

out vec4 fragColor;
in vec2 vUV;
in vec2 vCoverUV;

void main()
{
    fragColor = texture(tex, vUV);
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D tex;
layout(binding = 1) uniform sampler2D cover;

out vec4 fragColor;
in vec2 vUV;
in vec2 vCoverUV;

void main()
{
    fragColor = texture(tex, vUV);
    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);
    fragColor *= cover_1;
}

`,
			HLSL: "DXBC\x99\x16l`\xf6:k\xa2Y$\xa1,\xfd\xcdJE\x01\x00\x00\x00\xd8\x03\x00\x00\x06\x00\x00\x008\x00\x00\x00\xec\x00\x00\x00\xe8\x01\x00\x00d\x02\x00\x00X\x03\x00\x00\xa4\x03\x00\x00Aon9\xac\x00\x00\x00\xac\x00\x00\x00\x00\x02\xff\xff\x80\x00\x00\x00,\x00\x00\x00\x00\x00,\x00\x00\x00,\x00\x00\x00,\x00\x02\x00$\x00\x00\x00,\x00\x00\x00\x00\x00\x01\x01\x01\x00\x00\x02\xff\xff\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x0f\xb0\x1f\x00\x00\x02\x00\x00\x00\x90\x00\b\x0f\xa0\x1f\x00\x00\x02\x00\x00\x00\x90\x01\b\x0f\xa0\x01\x00\x00\x02\x00\x00\x03\x80\x00\x00\x1b\xb0B\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\x80\x00\b\xe4\xa0B\x00\x00\x03\x01\x00\x0f\x80\x00\x00\xe4\xb0\x01\b\xe4\xa0#\x00\x00\x02\x01\x00\x11\x80\x01\x00\x00\x80\x05\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\x80\x01\x00\x00\x80\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00SHDR\xf4\x00\x00\x00@\x00\x00\x00=\x00\x00\x00Z\x00\x00\x03\x00`\x10\x00\x00\x00\x00\x00Z\x00\x00\x03\x00`\x10\x00\x01\x00\x00\x00X\x18\x00\x04\x00p\x10\x00\x00\x00\x00\x00UU\x00\x00X\x18\x00\x04\x00p\x10\x00\x01\x00\x00\x00UU\x00\x00b\x10\x00\x032\x10\x10\x00\x00\x00\x00\x00b\x10\x00\x03\xc2\x10\x10\x00\x00\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00h\x00\x00\x02\x02\x00\x00\x00E\x00\x00\t\xf2\x00\x10\x00\x00\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x00F~\x10\x00\x01\x00\x00\x00\x00`\x10\x00\x01\x00\x00\x003\x00\x00\b\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x80\x81\x00\x00\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x80?E\x00\x00\t\xf2\x00\x10\x00\x01\x00\x00\x00\xe6\x1a\x10\x00\x00\x00\x00\x00F~\x10\x00\x00\x00\x00\x00\x00`\x10\x00\x00\x00\x00\x008\x00\x00\a\xf2 \x10\x00\x00\x00\x00\x00\x06\x00\x10\x00\x00\x00\x00\x00F\x0e\x10\x00\x01\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\x05\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\xec\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00\xc2\x00\x00\x00\x9c\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\xa9\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\xb8\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\r\x00\x00\x00\xbc\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\r\x00\x00\x00_tex_sampler\x00_cover_sampler\x00tex\x00cover\x00Microsoft (R) HLSL Shader Compiler 10.1\x00\xab\xabISGND\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x008\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\f\f\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
		},
	}
	shader_cover_vert = driver.ShaderSources{
		Name:   "cover.vert",
		Inputs: []driver.InputLocation{{Name: "pos", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}},
		Uniforms: driver.UniformsReflection{
			Blocks:    []driver.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []driver.UniformLocation{{Name: "_block.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_block.uvCoverTransform", Type: 0x0, Size: 4, Offset: 16}, {Name: "_block.uvTransformR1", Type: 0x0, Size: 4, Offset: 32}, {Name: "_block.uvTransformR2", Type: 0x0, Size: 4, Offset: 48}, {Name: "_block.z", Type: 0x0, Size: 1, Offset: 64}},
			Size:      68,
		},
		GLSL100ES: `#version 100

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

struct Block
{
    vec4 transform;
    vec4 uvCoverTransform;
    vec4 uvTransformR1;
    vec4 uvTransformR2;
    float z;
};

uniform Block _block;

attribute vec2 pos;
varying vec2 vUV;
attribute vec2 uv;
varying vec2 vCoverUV;

vec4 toClipSpace(vec4 pos_1)
{
    return pos_1;
}

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    vec4 param = vec4((pos * _block.transform.xy) + _block.transform.zw, _block.z, 1.0);
    gl_Position = toClipSpace(param);
    m3x2 param_1 = m3x2(_block.uvTransformR1.xyz, _block.uvTransformR2.xyz);
    vec3 param_2 = vec3(uv, 1.0);
    vUV = transform3x2(param_1, param_2).xy;
    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_4 = vec3(uv, 1.0);
    vec3 uv3 = transform3x2(param_3, param_4);
    vCoverUV = ((uv3 * vec3(_block.uvCoverTransform.xy, 1.0)) + vec3(_block.uvCoverTransform.zw, 0.0)).xy;
}

`,
		GLSL300ES: `#version 300 es

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

layout(std140) uniform Block
{
    vec4 transform;
    vec4 uvCoverTransform;
    vec4 uvTransformR1;
    vec4 uvTransformR2;
    float z;
} _block;

layout(location = 0) in vec2 pos;
out vec2 vUV;
layout(location = 1) in vec2 uv;
out vec2 vCoverUV;

vec4 toClipSpace(vec4 pos_1)
{
    return pos_1;
}

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    vec4 param = vec4((pos * _block.transform.xy) + _block.transform.zw, _block.z, 1.0);
    gl_Position = toClipSpace(param);
    m3x2 param_1 = m3x2(_block.uvTransformR1.xyz, _block.uvTransformR2.xyz);
    vec3 param_2 = vec3(uv, 1.0);
    vUV = transform3x2(param_1, param_2).xy;
    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_4 = vec3(uv, 1.0);
    vec3 uv3 = transform3x2(param_3, param_4);
    vCoverUV = ((uv3 * vec3(_block.uvCoverTransform.xy, 1.0)) + vec3(_block.uvCoverTransform.zw, 0.0)).xy;
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

struct Block
{
    vec4 transform;
    vec4 uvCoverTransform;
    vec4 uvTransformR1;
    vec4 uvTransformR2;
    float z;
};

uniform Block _block;

in vec2 pos;
out vec2 vUV;
in vec2 uv;
out vec2 vCoverUV;

vec4 toClipSpace(vec4 pos_1)
{
    return pos_1;
}

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    vec4 param = vec4((pos * _block.transform.xy) + _block.transform.zw, _block.z, 1.0);
    gl_Position = toClipSpace(param);
    m3x2 param_1 = m3x2(_block.uvTransformR1.xyz, _block.uvTransformR2.xyz);
    vec3 param_2 = vec3(uv, 1.0);
    vUV = transform3x2(param_1, param_2).xy;
    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_4 = vec3(uv, 1.0);
    vec3 uv3 = transform3x2(param_3, param_4);
    vCoverUV = ((uv3 * vec3(_block.uvCoverTransform.xy, 1.0)) + vec3(_block.uvCoverTransform.zw, 0.0)).xy;
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

layout(binding = 0, std140) uniform Block
{
    vec4 transform;
    vec4 uvCoverTransform;
    vec4 uvTransformR1;
    vec4 uvTransformR2;
    float z;
} _block;

in vec2 pos;
out vec2 vUV;
in vec2 uv;
out vec2 vCoverUV;

vec4 toClipSpace(vec4 pos_1)
{
    return pos_1;
}

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    vec4 param = vec4((pos * _block.transform.xy) + _block.transform.zw, _block.z, 1.0);
    gl_Position = toClipSpace(param);
    m3x2 param_1 = m3x2(_block.uvTransformR1.xyz, _block.uvTransformR2.xyz);
    vec3 param_2 = vec3(uv, 1.0);
    vUV = transform3x2(param_1, param_2).xy;
    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_4 = vec3(uv, 1.0);
    vec3 uv3 = transform3x2(param_3, param_4);
    vCoverUV = ((uv3 * vec3(_block.uvCoverTransform.xy, 1.0)) + vec3(_block.uvCoverTransform.zw, 0.0)).xy;
}

`,
		HLSL: "DXBCx\xefn{F\v\x88%\xc6\x05\x8f4h\xe4\xaaP\x01\x00\x00\x00\xd8\x05\x00\x00\x06\x00\x00\x008\x00\x00\x00x\x01\x00\x00\x1c\x03\x00\x00\x98\x03\x00\x00\x1c\x05\x00\x00h\x05\x00\x00Aon98\x01\x00\x008\x01\x00\x00\x00\x02\xfe\xff\x04\x01\x00\x004\x00\x00\x00\x01\x00$\x00\x00\x000\x00\x00\x000\x00\x00\x00$\x00\x01\x000\x00\x00\x00\x00\x00\x05\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xfe\xffQ\x00\x00\x05\x06\x00\x0f\xa0\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80\xbf\x00\x00\x00?\x1f\x00\x00\x02\x05\x00\x00\x80\x00\x00\x0f\x90\x1f\x00\x00\x02\x05\x00\x01\x80\x01\x00\x0f\x90\x04\x00\x00\x04\x00\x00\a\x80\x01\x00Đ\x06\x00Р\x06\x00Š\b\x00\x00\x03\x00\x00\b\xe0\x03\x00\xe4\xa0\x00\x00\xe4\x80\b\x00\x00\x03\x00\x00\x04\xe0\x04\x00\xe4\xa0\x00\x00\xe4\x80\x04\x00\x00\x04\x00\x00\x03\x80\x01\x00\xe1\x90\x06\x00\xe4\xa0\x06\x00\xe1\xa0\x05\x00\x00\x03\x00\x00\x03\x80\x00\x00\xe4\x80\x06\x00\xe2\xa0\x02\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x00\x00\x00\x80\x01\x00\x00\x02\x00\x00\x01\x80\x01\x00\x00\x90\x04\x00\x00\x04\x00\x00\x03\xe0\x00\x00\xe4\x80\x02\x00\xe4\xa0\x02\x00\xee\xa0\x04\x00\x00\x04\x00\x00\x03\x80\x00\x00\xe4\x90\x01\x00\xe4\xa0\x01\x00\xee\xa0\x02\x00\x00\x03\x00\x00\x03\xc0\x00\x00\xe4\x80\x00\x00\xe4\xa0\x01\x00\x00\x02\x00\x00\v\x80\x06\x00\xe4\xa0\x04\x00\x00\x04\x00\x00\f\xc0\x05\x00\x00\xa0\x00\x00t\x80\x00\x004\x80\xff\xff\x00\x00SHDR\x9c\x01\x00\x00@\x00\x01\x00g\x00\x00\x00Y\x00\x00\x04F\x8e \x00\x00\x00\x00\x00\x05\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x00\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x01\x00\x00\x00e\x00\x00\x032 \x10\x00\x00\x00\x00\x00e\x00\x00\x03\xc2 \x10\x00\x00\x00\x00\x00g\x00\x00\x04\xf2 \x10\x00\x01\x00\x00\x00\x01\x00\x00\x00h\x00\x00\x02\x02\x00\x00\x006\x00\x00\x05\x12\x00\x10\x00\x00\x00\x00\x00\n\x10\x10\x00\x01\x00\x00\x006\x00\x00\x052\x00\x10\x00\x01\x00\x00\x00F\x10\x10\x00\x01\x00\x00\x006\x00\x00\x05B\x00\x10\x00\x01\x00\x00\x00\x01@\x00\x00\x00\x00\x80?\x0f\x00\x00\n\"\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x80\xbf\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x96\x05\x10\x00\x01\x00\x00\x002\x00\x00\v2 \x10\x00\x00\x00\x00\x00F\x00\x10\x00\x00\x00\x00\x00F\x80 \x00\x00\x00\x00\x00\x01\x00\x00\x00\xe6\x8a \x00\x00\x00\x00\x00\x01\x00\x00\x00\x10\x00\x00\bB \x10\x00\x00\x00\x00\x00F\x82 \x00\x00\x00\x00\x00\x02\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x00\x10\x00\x00\b\x82 \x10\x00\x00\x00\x00\x00F\x82 \x00\x00\x00\x00\x00\x03\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x002\x00\x00\v2 \x10\x00\x01\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x00F\x80 \x00\x00\x00\x00\x00\x00\x00\x00\x00\xe6\x8a \x00\x00\x00\x00\x00\x00\x00\x00\x002\x00\x00\nB \x10\x00\x01\x00\x00\x00\n\x80 \x00\x00\x00\x00\x00\x04\x00\x00\x00\x01@\x00\x00\x00\x00\x00?\x01@\x00\x00\x00\x00\x00?6\x00\x00\x05\x82 \x10\x00\x01\x00\x00\x00\x01@\x00\x00\x00\x00\x80?>\x00\x00\x01STATt\x00\x00\x00\v\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF|\x01\x00\x00\x01\x00\x00\x00D\x00\x00\x00\x01\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xfe\xff\x00\x01\x00\x00T\x01\x00\x00<\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00Block\x00\xab\xab<\x00\x00\x00\x05\x00\x00\x00\\\x00\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd4\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xe8\x00\x00\x00\x00\x00\x00\x00\xf8\x00\x00\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xe8\x00\x00\x00\x00\x00\x00\x00\x10\x01\x00\x00 \x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xe8\x00\x00\x00\x00\x00\x00\x00%\x01\x00\x000\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xe8\x00\x00\x00\x00\x00\x00\x00:\x01\x00\x00@\x00\x00\x00\x04\x00\x00\x00\x02\x00\x00\x00D\x01\x00\x00\x00\x00\x00\x00_block_transform\x00\xab\xab\xab\x01\x00\x03\x00\x01\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00_block_uvCoverTransform\x00_block_uvTransformR1\x00_block_uvTransformR2\x00_block_z\x00\xab\x00\x00\x03\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGND\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x008\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGNh\x00\x00\x00\x03\x00\x00\x00\b\x00\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\f\x00\x00P\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\f\x03\x00\x00Y\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x0f\x00\x00\x00TEXCOORD\x00SV_Position\x00\xab\xab\xab",
	}
	shader_elements_comp = driver.ShaderSources{
		Name: "elements.comp",
		GLSL310ES: `#version 310 es
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Alloc
{
    uint offset;
};

struct ElementRef
{
    uint offset;
};

struct LineSegRef
{
    uint offset;
};

struct LineSeg
{
    vec2 p0;
    vec2 p1;
};

struct QuadSegRef
{
    uint offset;
};

struct QuadSeg
{
    vec2 p0;
    vec2 p1;
    vec2 p2;
};

struct CubicSegRef
{
    uint offset;
};

struct CubicSeg
{
    vec2 p0;
    vec2 p1;
    vec2 p2;
    vec2 p3;
};

struct FillColorRef
{
    uint offset;
};

struct FillColor
{
    uint rgba_color;
};

struct FillImageRef
{
    uint offset;
};

struct FillImage
{
    uint index;
    ivec2 offset;
};

struct SetLineWidthRef
{
    uint offset;
};

struct SetLineWidth
{
    float width;
};

struct TransformRef
{
    uint offset;
};

struct Transform
{
    vec4 mat;
    vec2 translate;
};

struct ClipRef
{
    uint offset;
};

struct Clip
{
    vec4 bbox;
};

struct SetFillModeRef
{
    uint offset;
};

struct SetFillMode
{
    uint fill_mode;
};

struct ElementTag
{
    uint tag;
    uint flags;
};

struct StateRef
{
    uint offset;
};

struct State
{
    vec4 mat;
    vec2 translate;
    vec4 bbox;
    float linewidth;
    uint flags;
    uint path_count;
    uint pathseg_count;
    uint trans_count;
};

struct AnnoImageRef
{
    uint offset;
};

struct AnnoImage
{
    vec4 bbox;
    float linewidth;
    uint index;
    ivec2 offset;
};

struct AnnoColorRef
{
    uint offset;
};

struct AnnoColor
{
    vec4 bbox;
    float linewidth;
    uint rgba_color;
};

struct AnnoBeginClipRef
{
    uint offset;
};

struct AnnoBeginClip
{
    vec4 bbox;
    float linewidth;
};

struct AnnoEndClipRef
{
    uint offset;
};

struct AnnoEndClip
{
    vec4 bbox;
};

struct AnnotatedRef
{
    uint offset;
};

struct PathCubicRef
{
    uint offset;
};

struct PathCubic
{
    vec2 p0;
    vec2 p1;
    vec2 p2;
    vec2 p3;
    uint path_ix;
    uint trans_ix;
    vec2 stroke;
};

struct PathSegRef
{
    uint offset;
};

struct TransformSegRef
{
    uint offset;
};

struct TransformSeg
{
    vec4 mat;
    vec2 translate;
};

struct Config
{
    uint n_elements;
    uint n_pathseg;
    uint width_in_tiles;
    uint height_in_tiles;
    Alloc tile_alloc;
    Alloc bin_alloc;
    Alloc ptcl_alloc;
    Alloc pathseg_alloc;
    Alloc anno_alloc;
    Alloc trans_alloc;
};

layout(binding = 0, std430) buffer Memory
{
    uint mem_offset;
    uint mem_error;
    uint memory[];
} _294;

layout(binding = 2, std430) readonly buffer SceneBuf
{
    uint scene[];
} _323;

layout(binding = 3, std430) coherent buffer StateBuf
{
    uint part_counter;
    uint state[];
} _779;

layout(binding = 1, std430) readonly buffer ConfigBuf
{
    Config conf;
} _2435;

shared uint sh_part_ix;
shared State sh_state[32];
shared State sh_prefix;

ElementTag Element_tag(ElementRef ref)
{
    uint tag_and_flags = _323.scene[ref.offset >> uint(2)];
    return ElementTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));
}

LineSeg LineSeg_read(LineSegRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    uint raw1 = _323.scene[ix + 1u];
    uint raw2 = _323.scene[ix + 2u];
    uint raw3 = _323.scene[ix + 3u];
    LineSeg s;
    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));
    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    return s;
}

LineSeg Element_Line_read(ElementRef ref)
{
    LineSegRef param = LineSegRef(ref.offset + 4u);
    return LineSeg_read(param);
}

QuadSeg QuadSeg_read(QuadSegRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    uint raw1 = _323.scene[ix + 1u];
    uint raw2 = _323.scene[ix + 2u];
    uint raw3 = _323.scene[ix + 3u];
    uint raw4 = _323.scene[ix + 4u];
    uint raw5 = _323.scene[ix + 5u];
    QuadSeg s;
    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));
    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));
    return s;
}

QuadSeg Element_Quad_read(ElementRef ref)
{
    QuadSegRef param = QuadSegRef(ref.offset + 4u);
    return QuadSeg_read(param);
}

CubicSeg CubicSeg_read(CubicSegRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    uint raw1 = _323.scene[ix + 1u];
    uint raw2 = _323.scene[ix + 2u];
    uint raw3 = _323.scene[ix + 3u];
    uint raw4 = _323.scene[ix + 4u];
    uint raw5 = _323.scene[ix + 5u];
    uint raw6 = _323.scene[ix + 6u];
    uint raw7 = _323.scene[ix + 7u];
    CubicSeg s;
    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));
    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));
    s.p3 = vec2(uintBitsToFloat(raw6), uintBitsToFloat(raw7));
    return s;
}

CubicSeg Element_Cubic_read(ElementRef ref)
{
    CubicSegRef param = CubicSegRef(ref.offset + 4u);
    return CubicSeg_read(param);
}

SetLineWidth SetLineWidth_read(SetLineWidthRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    SetLineWidth s;
    s.width = uintBitsToFloat(raw0);
    return s;
}

SetLineWidth Element_SetLineWidth_read(ElementRef ref)
{
    SetLineWidthRef param = SetLineWidthRef(ref.offset + 4u);
    return SetLineWidth_read(param);
}

Transform Transform_read(TransformRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    uint raw1 = _323.scene[ix + 1u];
    uint raw2 = _323.scene[ix + 2u];
    uint raw3 = _323.scene[ix + 3u];
    uint raw4 = _323.scene[ix + 4u];
    uint raw5 = _323.scene[ix + 5u];
    Transform s;
    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));
    return s;
}

Transform Element_Transform_read(ElementRef ref)
{
    TransformRef param = TransformRef(ref.offset + 4u);
    return Transform_read(param);
}

SetFillMode SetFillMode_read(SetFillModeRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    SetFillMode s;
    s.fill_mode = raw0;
    return s;
}

SetFillMode Element_SetFillMode_read(ElementRef ref)
{
    SetFillModeRef param = SetFillModeRef(ref.offset + 4u);
    return SetFillMode_read(param);
}

State map_element(ElementRef ref)
{
    ElementRef param = ref;
    uint tag = Element_tag(param).tag;
    State c;
    c.bbox = vec4(0.0);
    c.mat = vec4(1.0, 0.0, 0.0, 1.0);
    c.translate = vec2(0.0);
    c.linewidth = 1.0;
    c.flags = 0u;
    c.path_count = 0u;
    c.pathseg_count = 0u;
    c.trans_count = 0u;
    switch (tag)
    {
        case 1u:
        {
            ElementRef param_1 = ref;
            LineSeg line = Element_Line_read(param_1);
            vec2 _1919 = min(line.p0, line.p1);
            c.bbox = vec4(_1919.x, _1919.y, c.bbox.z, c.bbox.w);
            vec2 _1927 = max(line.p0, line.p1);
            c.bbox = vec4(c.bbox.x, c.bbox.y, _1927.x, _1927.y);
            c.pathseg_count = 1u;
            break;
        }
        case 2u:
        {
            ElementRef param_2 = ref;
            QuadSeg quad = Element_Quad_read(param_2);
            vec2 _1944 = min(min(quad.p0, quad.p1), quad.p2);
            c.bbox = vec4(_1944.x, _1944.y, c.bbox.z, c.bbox.w);
            vec2 _1955 = max(max(quad.p0, quad.p1), quad.p2);
            c.bbox = vec4(c.bbox.x, c.bbox.y, _1955.x, _1955.y);
            c.pathseg_count = 1u;
            break;
        }
        case 3u:
        {
            ElementRef param_3 = ref;
            CubicSeg cubic = Element_Cubic_read(param_3);
            vec2 _1975 = min(min(cubic.p0, cubic.p1), min(cubic.p2, cubic.p3));
            c.bbox = vec4(_1975.x, _1975.y, c.bbox.z, c.bbox.w);
            vec2 _1989 = max(max(cubic.p0, cubic.p1), max(cubic.p2, cubic.p3));
            c.bbox = vec4(c.bbox.x, c.bbox.y, _1989.x, _1989.y);
            c.pathseg_count = 1u;
            break;
        }
        case 4u:
        case 9u:
        case 7u:
        {
            c.flags = 4u;
            c.path_count = 1u;
            break;
        }
        case 8u:
        {
            c.path_count = 1u;
            break;
        }
        case 5u:
        {
            ElementRef param_4 = ref;
            SetLineWidth lw = Element_SetLineWidth_read(param_4);
            c.linewidth = lw.width;
            c.flags = 1u;
            break;
        }
        case 6u:
        {
            ElementRef param_5 = ref;
            Transform t = Element_Transform_read(param_5);
            c.mat = t.mat;
            c.translate = t.translate;
            c.trans_count = 1u;
            break;
        }
        case 10u:
        {
            ElementRef param_6 = ref;
            SetFillMode fm = Element_SetFillMode_read(param_6);
            c.flags = 8u | (fm.fill_mode << uint(4));
            break;
        }
    }
    return c;
}

ElementRef Element_index(ElementRef ref, uint index)
{
    return ElementRef(ref.offset + (index * 36u));
}

State combine_state(State a, State b)
{
    State c;
    c.bbox.x = (min(a.mat.x * b.bbox.x, a.mat.x * b.bbox.z) + min(a.mat.z * b.bbox.y, a.mat.z * b.bbox.w)) + a.translate.x;
    c.bbox.y = (min(a.mat.y * b.bbox.x, a.mat.y * b.bbox.z) + min(a.mat.w * b.bbox.y, a.mat.w * b.bbox.w)) + a.translate.y;
    c.bbox.z = (max(a.mat.x * b.bbox.x, a.mat.x * b.bbox.z) + max(a.mat.z * b.bbox.y, a.mat.z * b.bbox.w)) + a.translate.x;
    c.bbox.w = (max(a.mat.y * b.bbox.x, a.mat.y * b.bbox.z) + max(a.mat.w * b.bbox.y, a.mat.w * b.bbox.w)) + a.translate.y;
    bool _1657 = (a.flags & 4u) == 0u;
    bool _1665;
    if (_1657)
    {
        _1665 = b.bbox.z <= b.bbox.x;
    }
    else
    {
        _1665 = _1657;
    }
    bool _1673;
    if (_1665)
    {
        _1673 = b.bbox.w <= b.bbox.y;
    }
    else
    {
        _1673 = _1665;
    }
    if (_1673)
    {
        c.bbox = a.bbox;
    }
    else
    {
        bool _1683 = (a.flags & 4u) == 0u;
        bool _1690;
        if (_1683)
        {
            _1690 = (b.flags & 2u) == 0u;
        }
        else
        {
            _1690 = _1683;
        }
        bool _1707;
        if (_1690)
        {
            bool _1697 = a.bbox.z > a.bbox.x;
            bool _1706;
            if (!_1697)
            {
                _1706 = a.bbox.w > a.bbox.y;
            }
            else
            {
                _1706 = _1697;
            }
            _1707 = _1706;
        }
        else
        {
            _1707 = _1690;
        }
        if (_1707)
        {
            vec2 _1716 = min(a.bbox.xy, c.bbox.xy);
            c.bbox = vec4(_1716.x, _1716.y, c.bbox.z, c.bbox.w);
            vec2 _1726 = max(a.bbox.zw, c.bbox.zw);
            c.bbox = vec4(c.bbox.x, c.bbox.y, _1726.x, _1726.y);
        }
    }
    c.mat.x = (a.mat.x * b.mat.x) + (a.mat.z * b.mat.y);
    c.mat.y = (a.mat.y * b.mat.x) + (a.mat.w * b.mat.y);
    c.mat.z = (a.mat.x * b.mat.z) + (a.mat.z * b.mat.w);
    c.mat.w = (a.mat.y * b.mat.z) + (a.mat.w * b.mat.w);
    c.translate.x = ((a.mat.x * b.translate.x) + (a.mat.z * b.translate.y)) + a.translate.x;
    c.translate.y = ((a.mat.y * b.translate.x) + (a.mat.w * b.translate.y)) + a.translate.y;
    float _1812;
    if ((b.flags & 1u) == 0u)
    {
        _1812 = a.linewidth;
    }
    else
    {
        _1812 = b.linewidth;
    }
    c.linewidth = _1812;
    c.flags = (a.flags & 11u) | b.flags;
    c.flags |= ((a.flags & 4u) >> uint(1));
    uint _1842;
    if ((b.flags & 8u) == 0u)
    {
        _1842 = a.flags;
    }
    else
    {
        _1842 = b.flags;
    }
    uint fill_mode = _1842;
    fill_mode &= 16u;
    c.flags = (c.flags & 4294967279u) | fill_mode;
    c.path_count = a.path_count + b.path_count;
    c.pathseg_count = a.pathseg_count + b.pathseg_count;
    c.trans_count = a.trans_count + b.trans_count;
    return c;
}

StateRef state_aggregate_ref(uint partition_ix)
{
    return StateRef(4u + (partition_ix * 124u));
}

void State_write(StateRef ref, State s)
{
    uint ix = ref.offset >> uint(2);
    _779.state[ix + 0u] = floatBitsToUint(s.mat.x);
    _779.state[ix + 1u] = floatBitsToUint(s.mat.y);
    _779.state[ix + 2u] = floatBitsToUint(s.mat.z);
    _779.state[ix + 3u] = floatBitsToUint(s.mat.w);
    _779.state[ix + 4u] = floatBitsToUint(s.translate.x);
    _779.state[ix + 5u] = floatBitsToUint(s.translate.y);
    _779.state[ix + 6u] = floatBitsToUint(s.bbox.x);
    _779.state[ix + 7u] = floatBitsToUint(s.bbox.y);
    _779.state[ix + 8u] = floatBitsToUint(s.bbox.z);
    _779.state[ix + 9u] = floatBitsToUint(s.bbox.w);
    _779.state[ix + 10u] = floatBitsToUint(s.linewidth);
    _779.state[ix + 11u] = s.flags;
    _779.state[ix + 12u] = s.path_count;
    _779.state[ix + 13u] = s.pathseg_count;
    _779.state[ix + 14u] = s.trans_count;
}

StateRef state_prefix_ref(uint partition_ix)
{
    return StateRef((4u + (partition_ix * 124u)) + 60u);
}

uint state_flag_index(uint partition_ix)
{
    return partition_ix * 31u;
}

State State_read(StateRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _779.state[ix + 0u];
    uint raw1 = _779.state[ix + 1u];
    uint raw2 = _779.state[ix + 2u];
    uint raw3 = _779.state[ix + 3u];
    uint raw4 = _779.state[ix + 4u];
    uint raw5 = _779.state[ix + 5u];
    uint raw6 = _779.state[ix + 6u];
    uint raw7 = _779.state[ix + 7u];
    uint raw8 = _779.state[ix + 8u];
    uint raw9 = _779.state[ix + 9u];
    uint raw10 = _779.state[ix + 10u];
    uint raw11 = _779.state[ix + 11u];
    uint raw12 = _779.state[ix + 12u];
    uint raw13 = _779.state[ix + 13u];
    uint raw14 = _779.state[ix + 14u];
    State s;
    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));
    s.bbox = vec4(uintBitsToFloat(raw6), uintBitsToFloat(raw7), uintBitsToFloat(raw8), uintBitsToFloat(raw9));
    s.linewidth = uintBitsToFloat(raw10);
    s.flags = raw11;
    s.path_count = raw12;
    s.pathseg_count = raw13;
    s.trans_count = raw14;
    return s;
}

uint fill_mode_from_flags(uint flags)
{
    return flags & 1u;
}

vec2 get_linewidth(State st)
{
    return vec2(length(st.mat.xz), length(st.mat.yw)) * (0.5 * st.linewidth);
}

bool touch_mem(Alloc alloc, uint offset)
{
    return true;
}

void write_mem(Alloc alloc, uint offset, uint val)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return;
    }
    _294.memory[offset] = val;
}

void PathCubic_write(Alloc a, PathCubicRef ref, PathCubic s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = floatBitsToUint(s.p0.x);
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = floatBitsToUint(s.p0.y);
    write_mem(param_3, param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 2u;
    uint param_8 = floatBitsToUint(s.p1.x);
    write_mem(param_6, param_7, param_8);
    Alloc param_9 = a;
    uint param_10 = ix + 3u;
    uint param_11 = floatBitsToUint(s.p1.y);
    write_mem(param_9, param_10, param_11);
    Alloc param_12 = a;
    uint param_13 = ix + 4u;
    uint param_14 = floatBitsToUint(s.p2.x);
    write_mem(param_12, param_13, param_14);
    Alloc param_15 = a;
    uint param_16 = ix + 5u;
    uint param_17 = floatBitsToUint(s.p2.y);
    write_mem(param_15, param_16, param_17);
    Alloc param_18 = a;
    uint param_19 = ix + 6u;
    uint param_20 = floatBitsToUint(s.p3.x);
    write_mem(param_18, param_19, param_20);
    Alloc param_21 = a;
    uint param_22 = ix + 7u;
    uint param_23 = floatBitsToUint(s.p3.y);
    write_mem(param_21, param_22, param_23);
    Alloc param_24 = a;
    uint param_25 = ix + 8u;
    uint param_26 = s.path_ix;
    write_mem(param_24, param_25, param_26);
    Alloc param_27 = a;
    uint param_28 = ix + 9u;
    uint param_29 = s.trans_ix;
    write_mem(param_27, param_28, param_29);
    Alloc param_30 = a;
    uint param_31 = ix + 10u;
    uint param_32 = floatBitsToUint(s.stroke.x);
    write_mem(param_30, param_31, param_32);
    Alloc param_33 = a;
    uint param_34 = ix + 11u;
    uint param_35 = floatBitsToUint(s.stroke.y);
    write_mem(param_33, param_34, param_35);
}

void PathSeg_Cubic_write(Alloc a, PathSegRef ref, uint flags, PathCubic s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = (flags << uint(16)) | 1u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    PathCubicRef param_4 = PathCubicRef(ref.offset + 4u);
    PathCubic param_5 = s;
    PathCubic_write(param_3, param_4, param_5);
}

FillColor FillColor_read(FillColorRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    FillColor s;
    s.rgba_color = raw0;
    return s;
}

FillColor Element_FillColor_read(ElementRef ref)
{
    FillColorRef param = FillColorRef(ref.offset + 4u);
    return FillColor_read(param);
}

void AnnoColor_write(Alloc a, AnnoColorRef ref, AnnoColor s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = floatBitsToUint(s.bbox.x);
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = floatBitsToUint(s.bbox.y);
    write_mem(param_3, param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 2u;
    uint param_8 = floatBitsToUint(s.bbox.z);
    write_mem(param_6, param_7, param_8);
    Alloc param_9 = a;
    uint param_10 = ix + 3u;
    uint param_11 = floatBitsToUint(s.bbox.w);
    write_mem(param_9, param_10, param_11);
    Alloc param_12 = a;
    uint param_13 = ix + 4u;
    uint param_14 = floatBitsToUint(s.linewidth);
    write_mem(param_12, param_13, param_14);
    Alloc param_15 = a;
    uint param_16 = ix + 5u;
    uint param_17 = s.rgba_color;
    write_mem(param_15, param_16, param_17);
}

void Annotated_Color_write(Alloc a, AnnotatedRef ref, uint flags, AnnoColor s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = (flags << uint(16)) | 1u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    AnnoColorRef param_4 = AnnoColorRef(ref.offset + 4u);
    AnnoColor param_5 = s;
    AnnoColor_write(param_3, param_4, param_5);
}

FillImage FillImage_read(FillImageRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    uint raw1 = _323.scene[ix + 1u];
    FillImage s;
    s.index = raw0;
    s.offset = ivec2(int(raw1 << uint(16)) >> 16, int(raw1) >> 16);
    return s;
}

FillImage Element_FillImage_read(ElementRef ref)
{
    FillImageRef param = FillImageRef(ref.offset + 4u);
    return FillImage_read(param);
}

void AnnoImage_write(Alloc a, AnnoImageRef ref, AnnoImage s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = floatBitsToUint(s.bbox.x);
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = floatBitsToUint(s.bbox.y);
    write_mem(param_3, param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 2u;
    uint param_8 = floatBitsToUint(s.bbox.z);
    write_mem(param_6, param_7, param_8);
    Alloc param_9 = a;
    uint param_10 = ix + 3u;
    uint param_11 = floatBitsToUint(s.bbox.w);
    write_mem(param_9, param_10, param_11);
    Alloc param_12 = a;
    uint param_13 = ix + 4u;
    uint param_14 = floatBitsToUint(s.linewidth);
    write_mem(param_12, param_13, param_14);
    Alloc param_15 = a;
    uint param_16 = ix + 5u;
    uint param_17 = s.index;
    write_mem(param_15, param_16, param_17);
    Alloc param_18 = a;
    uint param_19 = ix + 6u;
    uint param_20 = (uint(s.offset.x) & 65535u) | (uint(s.offset.y) << uint(16));
    write_mem(param_18, param_19, param_20);
}

void Annotated_Image_write(Alloc a, AnnotatedRef ref, uint flags, AnnoImage s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = (flags << uint(16)) | 2u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    AnnoImageRef param_4 = AnnoImageRef(ref.offset + 4u);
    AnnoImage param_5 = s;
    AnnoImage_write(param_3, param_4, param_5);
}

Clip Clip_read(ClipRef ref)
{
    uint ix = ref.offset >> uint(2);
    uint raw0 = _323.scene[ix + 0u];
    uint raw1 = _323.scene[ix + 1u];
    uint raw2 = _323.scene[ix + 2u];
    uint raw3 = _323.scene[ix + 3u];
    Clip s;
    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    return s;
}

Clip Element_BeginClip_read(ElementRef ref)
{
    ClipRef param = ClipRef(ref.offset + 4u);
    return Clip_read(param);
}

void AnnoBeginClip_write(Alloc a, AnnoBeginClipRef ref, AnnoBeginClip s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = floatBitsToUint(s.bbox.x);
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = floatBitsToUint(s.bbox.y);
    write_mem(param_3, param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 2u;
    uint param_8 = floatBitsToUint(s.bbox.z);
    write_mem(param_6, param_7, param_8);
    Alloc param_9 = a;
    uint param_10 = ix + 3u;
    uint param_11 = floatBitsToUint(s.bbox.w);
    write_mem(param_9, param_10, param_11);
    Alloc param_12 = a;
    uint param_13 = ix + 4u;
    uint param_14 = floatBitsToUint(s.linewidth);
    write_mem(param_12, param_13, param_14);
}

void Annotated_BeginClip_write(Alloc a, AnnotatedRef ref, uint flags, AnnoBeginClip s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = (flags << uint(16)) | 3u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    AnnoBeginClipRef param_4 = AnnoBeginClipRef(ref.offset + 4u);
    AnnoBeginClip param_5 = s;
    AnnoBeginClip_write(param_3, param_4, param_5);
}

Clip Element_EndClip_read(ElementRef ref)
{
    ClipRef param = ClipRef(ref.offset + 4u);
    return Clip_read(param);
}

void AnnoEndClip_write(Alloc a, AnnoEndClipRef ref, AnnoEndClip s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = floatBitsToUint(s.bbox.x);
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = floatBitsToUint(s.bbox.y);
    write_mem(param_3, param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 2u;
    uint param_8 = floatBitsToUint(s.bbox.z);
    write_mem(param_6, param_7, param_8);
    Alloc param_9 = a;
    uint param_10 = ix + 3u;
    uint param_11 = floatBitsToUint(s.bbox.w);
    write_mem(param_9, param_10, param_11);
}

void Annotated_EndClip_write(Alloc a, AnnotatedRef ref, AnnoEndClip s)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint param_2 = 4u;
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    AnnoEndClipRef param_4 = AnnoEndClipRef(ref.offset + 4u);
    AnnoEndClip param_5 = s;
    AnnoEndClip_write(param_3, param_4, param_5);
}

void TransformSeg_write(Alloc a, TransformSegRef ref, TransformSeg s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = floatBitsToUint(s.mat.x);
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = floatBitsToUint(s.mat.y);
    write_mem(param_3, param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 2u;
    uint param_8 = floatBitsToUint(s.mat.z);
    write_mem(param_6, param_7, param_8);
    Alloc param_9 = a;
    uint param_10 = ix + 3u;
    uint param_11 = floatBitsToUint(s.mat.w);
    write_mem(param_9, param_10, param_11);
    Alloc param_12 = a;
    uint param_13 = ix + 4u;
    uint param_14 = floatBitsToUint(s.translate.x);
    write_mem(param_12, param_13, param_14);
    Alloc param_15 = a;
    uint param_16 = ix + 5u;
    uint param_17 = floatBitsToUint(s.translate.y);
    write_mem(param_15, param_16, param_17);
}

void main()
{
    if (_294.mem_error != 0u)
    {
        return;
    }
    if (gl_LocalInvocationID.x == 0u)
    {
        uint _2069 = atomicAdd(_779.part_counter, 1u);
        sh_part_ix = _2069;
    }
    barrier();
    uint part_ix = sh_part_ix;
    uint ix = (part_ix * 128u) + (gl_LocalInvocationID.x * 4u);
    ElementRef ref = ElementRef(ix * 36u);
    ElementRef param = ref;
    State th_state[4];
    th_state[0] = map_element(param);
    for (uint i = 1u; i < 4u; i++)
    {
        ElementRef param_1 = ref;
        uint param_2 = i;
        ElementRef param_3 = Element_index(param_1, param_2);
        State param_4 = th_state[i - 1u];
        State param_5 = map_element(param_3);
        th_state[i] = combine_state(param_4, param_5);
    }
    State agg = th_state[3];
    sh_state[gl_LocalInvocationID.x] = agg;
    for (uint i_1 = 0u; i_1 < 5u; i_1++)
    {
        barrier();
        if (gl_LocalInvocationID.x >= uint(1 << int(i_1)))
        {
            State other = sh_state[gl_LocalInvocationID.x - uint(1 << int(i_1))];
            State param_6 = other;
            State param_7 = agg;
            agg = combine_state(param_6, param_7);
        }
        barrier();
        sh_state[gl_LocalInvocationID.x] = agg;
    }
    State exclusive;
    exclusive.bbox = vec4(0.0);
    exclusive.mat = vec4(1.0, 0.0, 0.0, 1.0);
    exclusive.translate = vec2(0.0);
    exclusive.linewidth = 1.0;
    exclusive.flags = 0u;
    exclusive.path_count = 0u;
    exclusive.pathseg_count = 0u;
    exclusive.trans_count = 0u;
    if (gl_LocalInvocationID.x == 31u)
    {
        uint param_8 = part_ix;
        StateRef param_9 = state_aggregate_ref(param_8);
        State param_10 = agg;
        State_write(param_9, param_10);
        uint flag = 1u;
        memoryBarrierBuffer();
        if (part_ix == 0u)
        {
            uint param_11 = part_ix;
            StateRef param_12 = state_prefix_ref(param_11);
            State param_13 = agg;
            State_write(param_12, param_13);
            flag = 2u;
        }
        uint param_14 = part_ix;
        _779.state[state_flag_index(param_14)] = flag;
        if (part_ix != 0u)
        {
            uint look_back_ix = part_ix - 1u;
            uint their_ix = 0u;
            State their_agg;
            while (true)
            {
                uint param_15 = look_back_ix;
                flag = _779.state[state_flag_index(param_15)];
                if (flag == 2u)
                {
                    uint param_16 = look_back_ix;
                    StateRef param_17 = state_prefix_ref(param_16);
                    State their_prefix = State_read(param_17);
                    State param_18 = their_prefix;
                    State param_19 = exclusive;
                    exclusive = combine_state(param_18, param_19);
                    break;
                }
                else
                {
                    if (flag == 1u)
                    {
                        uint param_20 = look_back_ix;
                        StateRef param_21 = state_aggregate_ref(param_20);
                        their_agg = State_read(param_21);
                        State param_22 = their_agg;
                        State param_23 = exclusive;
                        exclusive = combine_state(param_22, param_23);
                        look_back_ix--;
                        their_ix = 0u;
                        continue;
                    }
                }
                ElementRef ref_1 = ElementRef(((look_back_ix * 128u) + their_ix) * 36u);
                ElementRef param_24 = ref_1;
                State s = map_element(param_24);
                if (their_ix == 0u)
                {
                    their_agg = s;
                }
                else
                {
                    State param_25 = their_agg;
                    State param_26 = s;
                    their_agg = combine_state(param_25, param_26);
                }
                their_ix++;
                if (their_ix == 128u)
                {
                    State param_27 = their_agg;
                    State param_28 = exclusive;
                    exclusive = combine_state(param_27, param_28);
                    if (look_back_ix == 0u)
                    {
                        break;
                    }
                    look_back_ix--;
                    their_ix = 0u;
                }
            }
            State param_29 = exclusive;
            State param_30 = agg;
            State inclusive_prefix = combine_state(param_29, param_30);
            sh_prefix = exclusive;
            uint param_31 = part_ix;
            StateRef param_32 = state_prefix_ref(param_31);
            State param_33 = inclusive_prefix;
            State_write(param_32, param_33);
            memoryBarrierBuffer();
            flag = 2u;
            uint param_34 = part_ix;
            _779.state[state_flag_index(param_34)] = flag;
        }
    }
    barrier();
    if (part_ix != 0u)
    {
        exclusive = sh_prefix;
    }
    State row = exclusive;
    if (gl_LocalInvocationID.x > 0u)
    {
        State other_1 = sh_state[gl_LocalInvocationID.x - 1u];
        State param_35 = row;
        State param_36 = other_1;
        row = combine_state(param_35, param_36);
    }
    PathCubic path_cubic;
    PathSegRef path_out_ref;
    Alloc param_45;
    Alloc param_51;
    Alloc param_57;
    AnnoColor anno_fill;
    AnnotatedRef out_ref;
    Alloc param_63;
    AnnoImage anno_img;
    Alloc param_69;
    AnnoBeginClip anno_begin_clip;
    Alloc param_75;
    Alloc param_80;
    Alloc param_83;
    for (uint i_2 = 0u; i_2 < 4u; i_2++)
    {
        State param_37 = row;
        State param_38 = th_state[i_2];
        State st = combine_state(param_37, param_38);
        ElementRef param_39 = ref;
        uint param_40 = i_2;
        ElementRef this_ref = Element_index(param_39, param_40);
        ElementRef param_41 = this_ref;
        ElementTag tag = Element_tag(param_41);
        uint param_42 = st.flags >> uint(4);
        uint fill_mode = fill_mode_from_flags(param_42);
        bool is_stroke = fill_mode == 1u;
        switch (tag.tag)
        {
            case 1u:
            {
                ElementRef param_43 = this_ref;
                LineSeg line = Element_Line_read(param_43);
                path_cubic.p0 = line.p0;
                path_cubic.p1 = mix(line.p0, line.p1, vec2(0.3333333432674407958984375));
                path_cubic.p2 = mix(line.p1, line.p0, vec2(0.3333333432674407958984375));
                path_cubic.p3 = line.p1;
                path_cubic.path_ix = st.path_count;
                path_cubic.trans_ix = st.trans_count;
                if (is_stroke)
                {
                    State param_44 = st;
                    path_cubic.stroke = get_linewidth(param_44);
                }
                else
                {
                    path_cubic.stroke = vec2(0.0);
                }
                path_out_ref = PathSegRef(_2435.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 52u));
                param_45.offset = _2435.conf.pathseg_alloc.offset;
                PathSegRef param_46 = path_out_ref;
                uint param_47 = fill_mode;
                PathCubic param_48 = path_cubic;
                PathSeg_Cubic_write(param_45, param_46, param_47, param_48);
                break;
            }
            case 2u:
            {
                ElementRef param_49 = this_ref;
                QuadSeg quad = Element_Quad_read(param_49);
                path_cubic.p0 = quad.p0;
                path_cubic.p1 = mix(quad.p1, quad.p0, vec2(0.3333333432674407958984375));
                path_cubic.p2 = mix(quad.p1, quad.p2, vec2(0.3333333432674407958984375));
                path_cubic.p3 = quad.p2;
                path_cubic.path_ix = st.path_count;
                path_cubic.trans_ix = st.trans_count;
                if (is_stroke)
                {
                    State param_50 = st;
                    path_cubic.stroke = get_linewidth(param_50);
                }
                else
                {
                    path_cubic.stroke = vec2(0.0);
                }
                path_out_ref = PathSegRef(_2435.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 52u));
                param_51.offset = _2435.conf.pathseg_alloc.offset;
                PathSegRef param_52 = path_out_ref;
                uint param_53 = fill_mode;
                PathCubic param_54 = path_cubic;
                PathSeg_Cubic_write(param_51, param_52, param_53, param_54);
                break;
            }
            case 3u:
            {
                ElementRef param_55 = this_ref;
                CubicSeg cubic = Element_Cubic_read(param_55);
                path_cubic.p0 = cubic.p0;
                path_cubic.p1 = cubic.p1;
                path_cubic.p2 = cubic.p2;
                path_cubic.p3 = cubic.p3;
                path_cubic.path_ix = st.path_count;
                path_cubic.trans_ix = st.trans_count;
                if (is_stroke)
                {
                    State param_56 = st;
                    path_cubic.stroke = get_linewidth(param_56);
                }
                else
                {
                    path_cubic.stroke = vec2(0.0);
                }
                path_out_ref = PathSegRef(_2435.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 52u));
                param_57.offset = _2435.conf.pathseg_alloc.offset;
                PathSegRef param_58 = path_out_ref;
                uint param_59 = fill_mode;
                PathCubic param_60 = path_cubic;
                PathSeg_Cubic_write(param_57, param_58, param_59, param_60);
                break;
            }
            case 4u:
            {
                ElementRef param_61 = this_ref;
                FillColor fill = Element_FillColor_read(param_61);
                anno_fill.rgba_color = fill.rgba_color;
                if (is_stroke)
                {
                    State param_62 = st;
                    vec2 lw = get_linewidth(param_62);
                    anno_fill.bbox = st.bbox + vec4(-lw, lw);
                    anno_fill.linewidth = st.linewidth * sqrt(abs((st.mat.x * st.mat.w) - (st.mat.y * st.mat.z)));
                }
                else
                {
                    anno_fill.bbox = st.bbox;
                    anno_fill.linewidth = 0.0;
                }
                out_ref = AnnotatedRef(_2435.conf.anno_alloc.offset + ((st.path_count - 1u) * 32u));
                param_63.offset = _2435.conf.anno_alloc.offset;
                AnnotatedRef param_64 = out_ref;
                uint param_65 = fill_mode;
                AnnoColor param_66 = anno_fill;
                Annotated_Color_write(param_63, param_64, param_65, param_66);
                break;
            }
            case 9u:
            {
                ElementRef param_67 = this_ref;
                FillImage fill_img = Element_FillImage_read(param_67);
                anno_img.index = fill_img.index;
                anno_img.offset = fill_img.offset;
                if (is_stroke)
                {
                    State param_68 = st;
                    vec2 lw_1 = get_linewidth(param_68);
                    anno_img.bbox = st.bbox + vec4(-lw_1, lw_1);
                    anno_img.linewidth = st.linewidth * sqrt(abs((st.mat.x * st.mat.w) - (st.mat.y * st.mat.z)));
                }
                else
                {
                    anno_img.bbox = st.bbox;
                    anno_img.linewidth = 0.0;
                }
                out_ref = AnnotatedRef(_2435.conf.anno_alloc.offset + ((st.path_count - 1u) * 32u));
                param_69.offset = _2435.conf.anno_alloc.offset;
                AnnotatedRef param_70 = out_ref;
                uint param_71 = fill_mode;
                AnnoImage param_72 = anno_img;
                Annotated_Image_write(param_69, param_70, param_71, param_72);
                break;
            }
            case 7u:
            {
                ElementRef param_73 = this_ref;
                Clip begin_clip = Element_BeginClip_read(param_73);
                anno_begin_clip.bbox = begin_clip.bbox;
                if (is_stroke)
                {
                    State param_74 = st;
                    vec2 lw_2 = get_linewidth(param_74);
                    anno_begin_clip.linewidth = st.linewidth * sqrt(abs((st.mat.x * st.mat.w) - (st.mat.y * st.mat.z)));
                }
                else
                {
                    anno_fill.linewidth = 0.0;
                }
                out_ref = AnnotatedRef(_2435.conf.anno_alloc.offset + ((st.path_count - 1u) * 32u));
                param_75.offset = _2435.conf.anno_alloc.offset;
                AnnotatedRef param_76 = out_ref;
                uint param_77 = fill_mode;
                AnnoBeginClip param_78 = anno_begin_clip;
                Annotated_BeginClip_write(param_75, param_76, param_77, param_78);
                break;
            }
            case 8u:
            {
                ElementRef param_79 = this_ref;
                Clip end_clip = Element_EndClip_read(param_79);
                AnnoEndClip anno_end_clip = AnnoEndClip(end_clip.bbox);
                out_ref = AnnotatedRef(_2435.conf.anno_alloc.offset + ((st.path_count - 1u) * 32u));
                param_80.offset = _2435.conf.anno_alloc.offset;
                AnnotatedRef param_81 = out_ref;
                AnnoEndClip param_82 = anno_end_clip;
                Annotated_EndClip_write(param_80, param_81, param_82);
                break;
            }
            case 6u:
            {
                TransformSeg transform = TransformSeg(st.mat, st.translate);
                TransformSegRef trans_ref = TransformSegRef(_2435.conf.trans_alloc.offset + ((st.trans_count - 1u) * 24u));
                param_83.offset = _2435.conf.trans_alloc.offset;
                TransformSegRef param_84 = trans_ref;
                TransformSeg param_85 = transform;
                TransformSeg_write(param_83, param_84, param_85);
                break;
            }
        }
    }
}

`,
	}
	shader_intersect_frag = driver.ShaderSources{
		Name:     "intersect.frag",
		Inputs:   []driver.InputLocation{{Name: "vUV", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}},
		Textures: []driver.TextureBinding{{Name: "cover", Binding: 0}},
		GLSL100ES: `#version 100
precision mediump float;
precision highp int;

uniform mediump sampler2D cover;

varying highp vec2 vUV;

void main()
{
    float cover_1 = abs(texture2D(cover, vUV).x);
    gl_FragData[0].x = cover_1;
}

`,
		GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

uniform mediump sampler2D cover;

in highp vec2 vUV;
layout(location = 0) out vec4 fragColor;

void main()
{
    float cover_1 = abs(texture(cover, vUV).x);
    fragColor.x = cover_1;
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D cover;

in vec2 vUV;
out vec4 fragColor;

void main()
{
    float cover_1 = abs(texture(cover, vUV).x);
    fragColor.x = cover_1;
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D cover;

in vec2 vUV;
out vec4 fragColor;

void main()
{
    float cover_1 = abs(texture(cover, vUV).x);
    fragColor.x = cover_1;
}

`,
		HLSL: "DXBC\xe0\xe4\x03\x8c\xacVF\x82l\xe7|\xc3T\xa6'\xef\x01\x00\x00\x00\b\x03\x00\x00\x06\x00\x00\x008\x00\x00\x00\xd4\x00\x00\x00\x80\x01\x00\x00\xfc\x01\x00\x00\xa0\x02\x00\x00\xd4\x02\x00\x00Aon9\x94\x00\x00\x00\x94\x00\x00\x00\x00\x02\xff\xffl\x00\x00\x00(\x00\x00\x00\x00\x00(\x00\x00\x00(\x00\x00\x00(\x00\x01\x00$\x00\x00\x00(\x00\x00\x00\x00\x00\x00\x02\xff\xffQ\x00\x00\x05\x00\x00\x0f\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x03\xb0\x1f\x00\x00\x02\x00\x00\x00\x90\x00\b\x0f\xa0B\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\xb0\x00\b\xe4\xa0#\x00\x00\x02\x00\x00\x01\x80\x00\x00\x00\x80\x01\x00\x00\x02\x00\x00\x0e\x80\x00\x00\x00\xa0\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00SHDR\xa4\x00\x00\x00@\x00\x00\x00)\x00\x00\x00Z\x00\x00\x03\x00`\x10\x00\x00\x00\x00\x00X\x18\x00\x04\x00p\x10\x00\x00\x00\x00\x00UU\x00\x00b\x10\x00\x032\x10\x10\x00\x00\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00h\x00\x00\x02\x01\x00\x00\x00E\x00\x00\t\xf2\x00\x10\x00\x00\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x00F~\x10\x00\x00\x00\x00\x00\x00`\x10\x00\x00\x00\x00\x006\x00\x00\x06\x12 \x10\x00\x00\x00\x00\x00\n\x00\x10\x80\x81\x00\x00\x00\x00\x00\x00\x006\x00\x00\b\xe2 \x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\x04\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\x9c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00q\x00\x00\x00\\\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00k\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\r\x00\x00\x00_cover_sampler\x00cover\x00Microsoft (R) HLSL Shader Compiler 10.1\x00\xab\xab\xabISGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
	}
	shader_intersect_vert = driver.ShaderSources{
		Name:   "intersect.vert",
		Inputs: []driver.InputLocation{{Name: "pos", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}},
		Uniforms: driver.UniformsReflection{
			Blocks:    []driver.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []driver.UniformLocation{{Name: "_block.uvTransform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_block.subUVTransform", Type: 0x0, Size: 4, Offset: 16}},
			Size:      32,
		},
		GLSL100ES: `#version 100

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

struct Block
{
    vec4 uvTransform;
    vec4 subUVTransform;
};

uniform Block _block;

attribute vec2 pos;
attribute vec2 uv;
varying vec2 vUV;

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));
    vec3 param_1 = vec3(pos, 1.0);
    vec3 p = transform3x2(param, param_1);
    gl_Position = vec4(p, 1.0);
    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_3 = vec3(uv, 1.0);
    vec3 uv3 = transform3x2(param_2, param_3);
    vUV = (uv3.xy * _block.subUVTransform.xy) + _block.subUVTransform.zw;
    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_5 = vec3(vUV, 1.0);
    vUV = transform3x2(param_4, param_5).xy;
    vUV = (vUV * _block.uvTransform.xy) + _block.uvTransform.zw;
}

`,
		GLSL300ES: `#version 300 es

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

layout(std140) uniform Block
{
    vec4 uvTransform;
    vec4 subUVTransform;
} _block;

layout(location = 0) in vec2 pos;
layout(location = 1) in vec2 uv;
out vec2 vUV;

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));
    vec3 param_1 = vec3(pos, 1.0);
    vec3 p = transform3x2(param, param_1);
    gl_Position = vec4(p, 1.0);
    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_3 = vec3(uv, 1.0);
    vec3 uv3 = transform3x2(param_2, param_3);
    vUV = (uv3.xy * _block.subUVTransform.xy) + _block.subUVTransform.zw;
    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_5 = vec3(vUV, 1.0);
    vUV = transform3x2(param_4, param_5).xy;
    vUV = (vUV * _block.uvTransform.xy) + _block.uvTransform.zw;
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

struct Block
{
    vec4 uvTransform;
    vec4 subUVTransform;
};

uniform Block _block;

in vec2 pos;
in vec2 uv;
out vec2 vUV;

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));
    vec3 param_1 = vec3(pos, 1.0);
    vec3 p = transform3x2(param, param_1);
    gl_Position = vec4(p, 1.0);
    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_3 = vec3(uv, 1.0);
    vec3 uv3 = transform3x2(param_2, param_3);
    vUV = (uv3.xy * _block.subUVTransform.xy) + _block.subUVTransform.zw;
    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_5 = vec3(vUV, 1.0);
    vUV = transform3x2(param_4, param_5).xy;
    vUV = (vUV * _block.uvTransform.xy) + _block.uvTransform.zw;
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct m3x2
{
    vec3 r0;
    vec3 r1;
};

layout(binding = 0, std140) uniform Block
{
    vec4 uvTransform;
    vec4 subUVTransform;
} _block;

in vec2 pos;
in vec2 uv;
out vec2 vUV;

vec3 transform3x2(m3x2 t, vec3 v)
{
    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));
}

void main()
{
    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));
    vec3 param_1 = vec3(pos, 1.0);
    vec3 p = transform3x2(param, param_1);
    gl_Position = vec4(p, 1.0);
    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_3 = vec3(uv, 1.0);
    vec3 uv3 = transform3x2(param_2, param_3);
    vUV = (uv3.xy * _block.subUVTransform.xy) + _block.subUVTransform.zw;
    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    vec3 param_5 = vec3(vUV, 1.0);
    vUV = transform3x2(param_4, param_5).xy;
    vUV = (vUV * _block.uvTransform.xy) + _block.uvTransform.zw;
}

`,
		HLSL: "DXBCxH\xc4I\xbe\x0f[|\nl\x899\xe0\xb8\xcb?\x01\x00\x00\x00\xdc\x04\x00\x00\x06\x00\x00\x008\x00\x00\x00L\x01\x00\x00\xc4\x02\x00\x00@\x03\x00\x008\x04\x00\x00\x84\x04\x00\x00Aon9\f\x01\x00\x00\f\x01\x00\x00\x00\x02\xfe\xff\xd8\x00\x00\x004\x00\x00\x00\x01\x00$\x00\x00\x000\x00\x00\x000\x00\x00\x00$\x00\x01\x000\x00\x00\x00\x00\x00\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xfe\xffQ\x00\x00\x05\x03\x00\x0f\xa0\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80\xbf\x00\x00\x00\x00\x1f\x00\x00\x02\x05\x00\x00\x80\x00\x00\x0f\x90\x1f\x00\x00\x02\x05\x00\x01\x80\x01\x00\x0f\x90\x04\x00\x00\x04\x00\x00\x03\x80\x01\x00U\x90\x03\x00\xe4\xa0\x03\x00\xe1\xa0\x05\x00\x00\x03\x00\x00\x03\x80\x00\x00\xe4\x80\x03\x00\xe2\xa0\x02\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x00\x00\x00\x80\x01\x00\x00\x02\x00\x00\x01\x80\x01\x00\x00\x90\x04\x00\x00\x04\x00\x00\x03\x80\x00\x00\xe4\x80\x02\x00\xe4\xa0\x02\x00\xee\xa0\x01\x00\x00\x02\x00\x00\x04\x80\x03\x00\x00\xa0\b\x00\x00\x03\x00\x00\b\x80\x03\x00ɠ\x00\x00\xe4\x80\x04\x00\x00\x04\x00\x00\x03\xe0\x00\x00\xec\x80\x01\x00\xe4\xa0\x01\x00\xee\xa0\x02\x00\x00\x03\x00\x00\x03\xc0\x00\x00\xe4\x90\x00\x00\xe4\xa0\x01\x00\x00\x02\x00\x00\f\xc0\x03\x00\x00\xa0\xff\xff\x00\x00SHDRp\x01\x00\x00@\x00\x01\x00\\\x00\x00\x00Y\x00\x00\x04F\x8e \x00\x00\x00\x00\x00\x02\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x00\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x01\x00\x00\x00e\x00\x00\x032 \x10\x00\x00\x00\x00\x00g\x00\x00\x04\xf2 \x10\x00\x01\x00\x00\x00\x01\x00\x00\x00h\x00\x00\x02\x01\x00\x00\x006\x00\x00\x05\"\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x80?6\x00\x00\x05R\x00\x10\x00\x00\x00\x00\x00V\x14\x10\x00\x01\x00\x00\x00\x0f\x00\x00\n\x82\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x80\xbf\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00F\x00\x10\x00\x00\x00\x00\x002\x00\x00\v2\x00\x10\x00\x00\x00\x00\x00\xe6\n\x10\x00\x00\x00\x00\x00F\x80 \x00\x00\x00\x00\x00\x01\x00\x00\x00\xe6\x8a \x00\x00\x00\x00\x00\x01\x00\x00\x006\x00\x00\x05B\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x80?\x0f\x00\x00\n\x82\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x80\xbf\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x96\x05\x10\x00\x00\x00\x00\x002\x00\x00\v2 \x10\x00\x00\x00\x00\x00\xc6\x00\x10\x00\x00\x00\x00\x00F\x80 \x00\x00\x00\x00\x00\x00\x00\x00\x00\xe6\x8a \x00\x00\x00\x00\x00\x00\x00\x00\x006\x00\x00\x052 \x10\x00\x01\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x006\x00\x00\b\xc2 \x10\x00\x01\x00\x00\x00\x02@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?>\x00\x00\x01STATt\x00\x00\x00\n\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\xf0\x00\x00\x00\x01\x00\x00\x00D\x00\x00\x00\x01\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xfe\xff\x00\x01\x00\x00\xc6\x00\x00\x00<\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00Block\x00\xab\xab<\x00\x00\x00\x02\x00\x00\x00\\\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8c\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xa0\x00\x00\x00\x00\x00\x00\x00\xb0\x00\x00\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xa0\x00\x00\x00\x00\x00\x00\x00_block_uvTransform\x00\xab\x01\x00\x03\x00\x01\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00_block_subUVTransform\x00Microsoft (R) HLSL Shader Compiler 10.1\x00\xab\xabISGND\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x008\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGNP\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\f\x00\x00A\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x0f\x00\x00\x00TEXCOORD\x00SV_Position\x00\xab\xab\xab",
	}
	shader_kernel4_comp = driver.ShaderSources{
		Name: "kernel4.comp",
		GLSL310ES: `#version 310 es
layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

struct Alloc
{
    uint offset;
};

struct CmdStrokeRef
{
    uint offset;
};

struct CmdStroke
{
    uint tile_ref;
    float half_width;
};

struct CmdFillRef
{
    uint offset;
};

struct CmdFill
{
    uint tile_ref;
    int backdrop;
};

struct CmdColorRef
{
    uint offset;
};

struct CmdColor
{
    uint rgba_color;
};

struct CmdImageRef
{
    uint offset;
};

struct CmdImage
{
    uint index;
    ivec2 offset;
};

struct CmdAlphaRef
{
    uint offset;
};

struct CmdAlpha
{
    float alpha;
};

struct CmdJumpRef
{
    uint offset;
};

struct CmdJump
{
    uint new_ref;
};

struct CmdRef
{
    uint offset;
};

struct CmdTag
{
    uint tag;
    uint flags;
};

struct TileSegRef
{
    uint offset;
};

struct TileSeg
{
    vec2 origin;
    vec2 vector;
    float y_edge;
    TileSegRef next;
};

struct Config
{
    uint n_elements;
    uint n_pathseg;
    uint width_in_tiles;
    uint height_in_tiles;
    Alloc tile_alloc;
    Alloc bin_alloc;
    Alloc ptcl_alloc;
    Alloc pathseg_alloc;
    Alloc anno_alloc;
    Alloc trans_alloc;
};

layout(binding = 0, std430) buffer Memory
{
    uint mem_offset;
    uint mem_error;
    uint memory[];
} _196;

layout(binding = 1, std430) readonly buffer ConfigBuf
{
    Config conf;
} _693;

layout(binding = 3, rgba8) uniform readonly highp image2D images[1];
layout(binding = 2, rgba8) uniform writeonly highp image2D image;

Alloc new_alloc(uint offset, uint size)
{
    Alloc a;
    a.offset = offset;
    return a;
}

Alloc slice_mem(Alloc a, uint offset, uint size)
{
    uint param = a.offset + offset;
    uint param_1 = size;
    return new_alloc(param, param_1);
}

bool touch_mem(Alloc alloc, uint offset)
{
    return true;
}

uint read_mem(Alloc alloc, uint offset)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return 0u;
    }
    uint v = _196.memory[offset];
    return v;
}

Alloc alloc_read(Alloc a, uint offset)
{
    Alloc param = a;
    uint param_1 = offset >> uint(2);
    Alloc alloc;
    alloc.offset = read_mem(param, param_1);
    return alloc;
}

CmdTag Cmd_tag(Alloc a, CmdRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint tag_and_flags = read_mem(param, param_1);
    return CmdTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));
}

CmdStroke CmdStroke_read(Alloc a, CmdStrokeRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    CmdStroke s;
    s.tile_ref = raw0;
    s.half_width = uintBitsToFloat(raw1);
    return s;
}

CmdStroke Cmd_Stroke_read(Alloc a, CmdRef ref)
{
    Alloc param = a;
    CmdStrokeRef param_1 = CmdStrokeRef(ref.offset + 4u);
    return CmdStroke_read(param, param_1);
}

TileSeg TileSeg_read(Alloc a, TileSegRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 3u;
    uint raw3 = read_mem(param_6, param_7);
    Alloc param_8 = a;
    uint param_9 = ix + 4u;
    uint raw4 = read_mem(param_8, param_9);
    Alloc param_10 = a;
    uint param_11 = ix + 5u;
    uint raw5 = read_mem(param_10, param_11);
    TileSeg s;
    s.origin = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));
    s.vector = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.y_edge = uintBitsToFloat(raw4);
    s.next = TileSegRef(raw5);
    return s;
}

uvec2 chunk_offset(uint i)
{
    return uvec2((i % 2u) * 16u, (i / 2u) * 8u);
}

CmdFill CmdFill_read(Alloc a, CmdFillRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    CmdFill s;
    s.tile_ref = raw0;
    s.backdrop = int(raw1);
    return s;
}

CmdFill Cmd_Fill_read(Alloc a, CmdRef ref)
{
    Alloc param = a;
    CmdFillRef param_1 = CmdFillRef(ref.offset + 4u);
    return CmdFill_read(param, param_1);
}

CmdAlpha CmdAlpha_read(Alloc a, CmdAlphaRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    CmdAlpha s;
    s.alpha = uintBitsToFloat(raw0);
    return s;
}

CmdAlpha Cmd_Alpha_read(Alloc a, CmdRef ref)
{
    Alloc param = a;
    CmdAlphaRef param_1 = CmdAlphaRef(ref.offset + 4u);
    return CmdAlpha_read(param, param_1);
}

CmdColor CmdColor_read(Alloc a, CmdColorRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    CmdColor s;
    s.rgba_color = raw0;
    return s;
}

CmdColor Cmd_Color_read(Alloc a, CmdRef ref)
{
    Alloc param = a;
    CmdColorRef param_1 = CmdColorRef(ref.offset + 4u);
    return CmdColor_read(param, param_1);
}

vec3 fromsRGB(vec3 srgb)
{
    bvec3 cutoff = greaterThanEqual(srgb, vec3(0.040449999272823333740234375));
    vec3 below = srgb / vec3(12.9200000762939453125);
    vec3 above = pow((srgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));
    return mix(below, above, cutoff);
}

vec4 unpacksRGB(uint srgba)
{
    vec4 color = unpackUnorm4x8(srgba).wzyx;
    vec3 param = color.xyz;
    return vec4(fromsRGB(param), color.w);
}

CmdImage CmdImage_read(Alloc a, CmdImageRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    CmdImage s;
    s.index = raw0;
    s.offset = ivec2(int(raw1 << uint(16)) >> 16, int(raw1) >> 16);
    return s;
}

CmdImage Cmd_Image_read(Alloc a, CmdRef ref)
{
    Alloc param = a;
    CmdImageRef param_1 = CmdImageRef(ref.offset + 4u);
    return CmdImage_read(param, param_1);
}

vec4[8] fillImage(uvec2 xy, CmdImage cmd_img)
{
    vec4 rgba[8];
    for (uint i = 0u; i < 8u; i++)
    {
        uint param = i;
        ivec2 uv = ivec2(xy + chunk_offset(param)) + cmd_img.offset;
        vec4 fg_rgba = imageLoad(images[0], uv);
        vec3 param_1 = fg_rgba.xyz;
        vec3 _663 = fromsRGB(param_1);
        fg_rgba = vec4(_663.x, _663.y, _663.z, fg_rgba.w);
        rgba[i] = fg_rgba;
    }
    return rgba;
}

vec3 tosRGB(vec3 rgb)
{
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));
    vec3 below = vec3(12.9200000762939453125) * rgb;
    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);
    return mix(below, above, cutoff);
}

uint packsRGB(inout vec4 rgba)
{
    vec3 param = rgba.xyz;
    rgba = vec4(tosRGB(param), rgba.w);
    return packUnorm4x8(rgba.wzyx);
}

void write_mem(Alloc alloc, uint offset, uint val)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return;
    }
    _196.memory[offset] = val;
}

CmdJump CmdJump_read(Alloc a, CmdJumpRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    CmdJump s;
    s.new_ref = raw0;
    return s;
}

CmdJump Cmd_Jump_read(Alloc a, CmdRef ref)
{
    Alloc param = a;
    CmdJumpRef param_1 = CmdJumpRef(ref.offset + 4u);
    return CmdJump_read(param, param_1);
}

void main()
{
    if (_196.mem_error != 0u)
    {
        return;
    }
    uint tile_ix = (gl_WorkGroupID.y * _693.conf.width_in_tiles) + gl_WorkGroupID.x;
    Alloc param;
    param.offset = _693.conf.ptcl_alloc.offset;
    uint param_1 = tile_ix * 1024u;
    uint param_2 = 1024u;
    Alloc cmd_alloc = slice_mem(param, param_1, param_2);
    CmdRef cmd_ref = CmdRef(cmd_alloc.offset);
    Alloc param_3 = cmd_alloc;
    uint param_4 = cmd_ref.offset;
    Alloc scratch_alloc = alloc_read(param_3, param_4);
    cmd_ref.offset += 8u;
    uvec2 xy_uint = uvec2(gl_LocalInvocationID.x + (32u * gl_WorkGroupID.x), gl_LocalInvocationID.y + (32u * gl_WorkGroupID.y));
    vec2 xy = vec2(xy_uint);
    vec4 rgba[8];
    for (uint i = 0u; i < 8u; i++)
    {
        rgba[i] = vec4(0.0);
    }
    uint clip_depth = 0u;
    float df[8];
    TileSegRef tile_seg_ref;
    float area[8];
    uint base_ix;
    while (true)
    {
        Alloc param_5 = cmd_alloc;
        CmdRef param_6 = cmd_ref;
        uint tag = Cmd_tag(param_5, param_6).tag;
        if (tag == 0u)
        {
            break;
        }
        switch (tag)
        {
            case 2u:
            {
                Alloc param_7 = cmd_alloc;
                CmdRef param_8 = cmd_ref;
                CmdStroke stroke = Cmd_Stroke_read(param_7, param_8);
                for (uint k = 0u; k < 8u; k++)
                {
                    df[k] = 1000000000.0;
                }
                tile_seg_ref = TileSegRef(stroke.tile_ref);
                do
                {
                    uint param_9 = tile_seg_ref.offset;
                    uint param_10 = 24u;
                    Alloc param_11 = new_alloc(param_9, param_10);
                    TileSegRef param_12 = tile_seg_ref;
                    TileSeg seg = TileSeg_read(param_11, param_12);
                    vec2 line_vec = seg.vector;
                    for (uint k_1 = 0u; k_1 < 8u; k_1++)
                    {
                        vec2 dpos = (xy + vec2(0.5)) - seg.origin;
                        uint param_13 = k_1;
                        dpos += vec2(chunk_offset(param_13));
                        float t = clamp(dot(line_vec, dpos) / dot(line_vec, line_vec), 0.0, 1.0);
                        df[k_1] = min(df[k_1], length((line_vec * t) - dpos));
                    }
                    tile_seg_ref = seg.next;
                } while (tile_seg_ref.offset != 0u);
                for (uint k_2 = 0u; k_2 < 8u; k_2++)
                {
                    area[k_2] = clamp((stroke.half_width + 0.5) - df[k_2], 0.0, 1.0);
                }
                cmd_ref.offset += 12u;
                break;
            }
            case 1u:
            {
                Alloc param_14 = cmd_alloc;
                CmdRef param_15 = cmd_ref;
                CmdFill fill = Cmd_Fill_read(param_14, param_15);
                for (uint k_3 = 0u; k_3 < 8u; k_3++)
                {
                    area[k_3] = float(fill.backdrop);
                }
                tile_seg_ref = TileSegRef(fill.tile_ref);
                do
                {
                    uint param_16 = tile_seg_ref.offset;
                    uint param_17 = 24u;
                    Alloc param_18 = new_alloc(param_16, param_17);
                    TileSegRef param_19 = tile_seg_ref;
                    TileSeg seg_1 = TileSeg_read(param_18, param_19);
                    for (uint k_4 = 0u; k_4 < 8u; k_4++)
                    {
                        uint param_20 = k_4;
                        vec2 my_xy = xy + vec2(chunk_offset(param_20));
                        vec2 start = seg_1.origin - my_xy;
                        vec2 end = start + seg_1.vector;
                        vec2 window = clamp(vec2(start.y, end.y), vec2(0.0), vec2(1.0));
                        if (!(window.x == window.y))
                        {
                            vec2 t_1 = (window - vec2(start.y)) / vec2(seg_1.vector.y);
                            vec2 xs = vec2(mix(start.x, end.x, t_1.x), mix(start.x, end.x, t_1.y));
                            float xmin = min(min(xs.x, xs.y), 1.0) - 9.9999999747524270787835121154785e-07;
                            float xmax = max(xs.x, xs.y);
                            float b = min(xmax, 1.0);
                            float c = max(b, 0.0);
                            float d = max(xmin, 0.0);
                            float a = ((b + (0.5 * ((d * d) - (c * c)))) - xmin) / (xmax - xmin);
                            area[k_4] += (a * (window.x - window.y));
                        }
                        area[k_4] += (sign(seg_1.vector.x) * clamp((my_xy.y - seg_1.y_edge) + 1.0, 0.0, 1.0));
                    }
                    tile_seg_ref = seg_1.next;
                } while (tile_seg_ref.offset != 0u);
                for (uint k_5 = 0u; k_5 < 8u; k_5++)
                {
                    area[k_5] = min(abs(area[k_5]), 1.0);
                }
                cmd_ref.offset += 12u;
                break;
            }
            case 3u:
            {
                for (uint k_6 = 0u; k_6 < 8u; k_6++)
                {
                    area[k_6] = 1.0;
                }
                cmd_ref.offset += 4u;
                break;
            }
            case 4u:
            {
                Alloc param_21 = cmd_alloc;
                CmdRef param_22 = cmd_ref;
                CmdAlpha alpha = Cmd_Alpha_read(param_21, param_22);
                for (uint k_7 = 0u; k_7 < 8u; k_7++)
                {
                    area[k_7] = alpha.alpha;
                }
                cmd_ref.offset += 8u;
                break;
            }
            case 5u:
            {
                Alloc param_23 = cmd_alloc;
                CmdRef param_24 = cmd_ref;
                CmdColor color = Cmd_Color_read(param_23, param_24);
                uint param_25 = color.rgba_color;
                vec4 fg = unpacksRGB(param_25);
                for (uint k_8 = 0u; k_8 < 8u; k_8++)
                {
                    vec4 fg_k = fg * area[k_8];
                    rgba[k_8] = (rgba[k_8] * (1.0 - fg_k.w)) + fg_k;
                }
                cmd_ref.offset += 8u;
                break;
            }
            case 6u:
            {
                Alloc param_26 = cmd_alloc;
                CmdRef param_27 = cmd_ref;
                CmdImage fill_img = Cmd_Image_read(param_26, param_27);
                uvec2 param_28 = xy_uint;
                CmdImage param_29 = fill_img;
                vec4 img[8] = fillImage(param_28, param_29);
                for (uint k_9 = 0u; k_9 < 8u; k_9++)
                {
                    vec4 fg_k_1 = img[k_9] * area[k_9];
                    rgba[k_9] = (rgba[k_9] * (1.0 - fg_k_1.w)) + fg_k_1;
                }
                cmd_ref.offset += 12u;
                break;
            }
            case 7u:
            {
                base_ix = (scratch_alloc.offset >> uint(2)) + (2u * ((((clip_depth * 32u) * 32u) + gl_LocalInvocationID.x) + (32u * gl_LocalInvocationID.y)));
                for (uint k_10 = 0u; k_10 < 8u; k_10++)
                {
                    uint param_30 = k_10;
                    uvec2 offset = chunk_offset(param_30);
                    vec4 param_31 = vec4(rgba[k_10]);
                    uint _1286 = packsRGB(param_31);
                    uint srgb = _1286;
                    float alpha_1 = clamp(abs(area[k_10]), 0.0, 1.0);
                    Alloc param_32 = scratch_alloc;
                    uint param_33 = (base_ix + 0u) + (2u * (offset.x + (offset.y * 32u)));
                    uint param_34 = srgb;
                    write_mem(param_32, param_33, param_34);
                    Alloc param_35 = scratch_alloc;
                    uint param_36 = (base_ix + 1u) + (2u * (offset.x + (offset.y * 32u)));
                    uint param_37 = floatBitsToUint(alpha_1);
                    write_mem(param_35, param_36, param_37);
                    rgba[k_10] = vec4(0.0);
                }
                clip_depth++;
                cmd_ref.offset += 4u;
                break;
            }
            case 8u:
            {
                clip_depth--;
                base_ix = (scratch_alloc.offset >> uint(2)) + (2u * ((((clip_depth * 32u) * 32u) + gl_LocalInvocationID.x) + (32u * gl_LocalInvocationID.y)));
                for (uint k_11 = 0u; k_11 < 8u; k_11++)
                {
                    uint param_38 = k_11;
                    uvec2 offset_1 = chunk_offset(param_38);
                    Alloc param_39 = scratch_alloc;
                    uint param_40 = (base_ix + 0u) + (2u * (offset_1.x + (offset_1.y * 32u)));
                    uint srgb_1 = read_mem(param_39, param_40);
                    Alloc param_41 = scratch_alloc;
                    uint param_42 = (base_ix + 1u) + (2u * (offset_1.x + (offset_1.y * 32u)));
                    uint alpha_2 = read_mem(param_41, param_42);
                    uint param_43 = srgb_1;
                    vec4 bg = unpacksRGB(param_43);
                    vec4 fg_1 = (rgba[k_11] * area[k_11]) * uintBitsToFloat(alpha_2);
                    rgba[k_11] = (bg * (1.0 - fg_1.w)) + fg_1;
                }
                cmd_ref.offset += 4u;
                break;
            }
            case 9u:
            {
                Alloc param_44 = cmd_alloc;
                CmdRef param_45 = cmd_ref;
                cmd_ref = CmdRef(Cmd_Jump_read(param_44, param_45).new_ref);
                cmd_alloc.offset = cmd_ref.offset;
                break;
            }
        }
    }
    for (uint i_1 = 0u; i_1 < 8u; i_1++)
    {
        uint param_46 = i_1;
        vec3 param_47 = rgba[i_1].xyz;
        imageStore(image, ivec2(xy_uint + chunk_offset(param_46)), vec4(tosRGB(param_47), rgba[i_1].w));
    }
}

`,
	}
	shader_material_frag = driver.ShaderSources{
		Name:     "material.frag",
		Inputs:   []driver.InputLocation{{Name: "vUV", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}},
		Textures: []driver.TextureBinding{{Name: "tex", Binding: 0}},
		GLSL100ES: `#version 100
precision mediump float;
precision highp int;

uniform mediump sampler2D tex;

varying vec2 vUV;

vec3 RGBtosRGB(vec3 rgb)
{
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));
    vec3 below = vec3(12.9200000762939453125) * rgb;
    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);
    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);
}

void main()
{
    vec4 texel = texture2D(tex, vUV);
    vec3 param = texel.xyz;
    vec3 _59 = RGBtosRGB(param);
    texel = vec4(_59.x, _59.y, _59.z, texel.w);
    gl_FragData[0] = texel;
}

`,
		GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

uniform mediump sampler2D tex;

in vec2 vUV;
layout(location = 0) out vec4 fragColor;

vec3 RGBtosRGB(vec3 rgb)
{
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));
    vec3 below = vec3(12.9200000762939453125) * rgb;
    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);
    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);
}

void main()
{
    vec4 texel = texture(tex, vUV);
    vec3 param = texel.xyz;
    vec3 _59 = RGBtosRGB(param);
    texel = vec4(_59.x, _59.y, _59.z, texel.w);
    fragColor = texel;
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D tex;

in vec2 vUV;
out vec4 fragColor;

vec3 RGBtosRGB(vec3 rgb)
{
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));
    vec3 below = vec3(12.9200000762939453125) * rgb;
    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);
    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);
}

void main()
{
    vec4 texel = texture(tex, vUV);
    vec3 param = texel.xyz;
    vec3 _59 = RGBtosRGB(param);
    texel = vec4(_59.x, _59.y, _59.z, texel.w);
    fragColor = texel;
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0) uniform sampler2D tex;

in vec2 vUV;
out vec4 fragColor;

vec3 RGBtosRGB(vec3 rgb)
{
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));
    vec3 below = vec3(12.9200000762939453125) * rgb;
    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);
    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);
}

void main()
{
    vec4 texel = texture(tex, vUV);
    vec3 param = texel.xyz;
    vec3 _59 = RGBtosRGB(param);
    texel = vec4(_59.x, _59.y, _59.z, texel.w);
    fragColor = texel;
}

`,
		HLSL: "DXBC\x9e\x87LD\xf3\x17\n\x06\\\xb7\x98\x94\xa9PKe\x01\x00\x00\x00\xc8\x04\x00\x00\x06\x00\x00\x008\x00\x00\x00\xbc\x01\x00\x00D\x03\x00\x00\xc0\x03\x00\x00`\x04\x00\x00\x94\x04\x00\x00Aon9|\x01\x00\x00|\x01\x00\x00\x00\x02\xff\xffT\x01\x00\x00(\x00\x00\x00\x00\x00(\x00\x00\x00(\x00\x00\x00(\x00\x01\x00$\x00\x00\x00(\x00\x00\x00\x00\x00\x00\x02\xff\xffQ\x00\x00\x05\x00\x00\x0f\xa0=\n\x87?\xaeGa\xbd\x00\x00\x00\x00\x00\x00\x00\x00Q\x00\x00\x05\x01\x00\x0f\xa0\x1c.M\xbbR\xb8NAvT\xd5>\x00\x00\x00\x00\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x03\xb0\x1f\x00\x00\x02\x00\x00\x00\x90\x00\b\x0f\xa0B\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\xb0\x00\b\xe4\xa0\x0f\x00\x00\x02\x01\x00\x01\x80\x00\x00\x00\x80\x0f\x00\x00\x02\x01\x00\x02\x80\x00\x00U\x80\x0f\x00\x00\x02\x01\x00\x04\x80\x00\x00\xaa\x80\x05\x00\x00\x03\x01\x00\a\x80\x01\x00\xe4\x80\x01\x00\xaa\xa0\x0e\x00\x00\x02\x02\x00\x01\x80\x01\x00\x00\x80\x0e\x00\x00\x02\x02\x00\x02\x80\x01\x00U\x80\x0e\x00\x00\x02\x02\x00\x04\x80\x01\x00\xaa\x80\x04\x00\x00\x04\x01\x00\a\x80\x02\x00\xe4\x80\x00\x00\x00\xa0\x00\x00U\xa0\x02\x00\x00\x03\x01\x00\b\x80\x00\x00\x00\x80\x01\x00\x00\xa0\x05\x00\x00\x03\x02\x00\a\x80\x00\x00\xe4\x80\x01\x00U\xa0X\x00\x00\x04\x00\x00\x01\x80\x01\x00\xff\x80\x01\x00\x00\x80\x02\x00\x00\x80\x02\x00\x00\x03\x01\x00\x01\x80\x00\x00U\x80\x01\x00\x00\xa0X\x00\x00\x04\x00\x00\x02\x80\x01\x00\x00\x80\x01\x00U\x80\x02\x00U\x80\x02\x00\x00\x03\x01\x00\x01\x80\x00\x00\xaa\x80\x01\x00\x00\xa0X\x00\x00\x04\x00\x00\x04\x80\x01\x00\x00\x80\x01\x00\xaa\x80\x02\x00\xaa\x80\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00SHDR\x80\x01\x00\x00@\x00\x00\x00`\x00\x00\x00Z\x00\x00\x03\x00`\x10\x00\x00\x00\x00\x00X\x18\x00\x04\x00p\x10\x00\x00\x00\x00\x00UU\x00\x00b\x10\x00\x032\x10\x10\x00\x00\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00h\x00\x00\x02\x03\x00\x00\x00E\x00\x00\t\xf2\x00\x10\x00\x00\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x00F~\x10\x00\x00\x00\x00\x00\x00`\x10\x00\x00\x00\x00\x00/\x00\x00\x05r\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x008\x00\x00\nr\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x00\x02@\x00\x00vT\xd5>vT\xd5>vT\xd5>\x00\x00\x00\x00\x19\x00\x00\x05r\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x002\x00\x00\x0fr\x00\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x00\x02@\x00\x00=\n\x87?=\n\x87?=\n\x87?\x00\x00\x00\x00\x02@\x00\x00\xaeGa\xbd\xaeGa\xbd\xaeGa\xbd\x00\x00\x00\x00\x1d\x00\x00\nr\x00\x10\x00\x02\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x1c.M;\x1c.M;\x1c.M;\x00\x00\x00\x008\x00\x00\nr\x00\x10\x00\x00\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x00\x02@\x00\x00R\xb8NAR\xb8NAR\xb8NA\x00\x00\x00\x006\x00\x00\x05\x82 \x10\x00\x00\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x007\x00\x00\tr \x10\x00\x00\x00\x00\x00F\x02\x10\x00\x02\x00\x00\x00F\x02\x10\x00\x01\x00\x00\x00F\x02\x10\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00\n\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\x98\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00m\x00\x00\x00\\\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00i\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\r\x00\x00\x00_tex_sampler\x00tex\x00Microsoft (R) HLSL Shader Compiler 10.1\x00\xab\xab\xabISGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
	}
	shader_material_vert = driver.ShaderSources{
		Name:   "material.vert",
		Inputs: []driver.InputLocation{{Name: "pos", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}},
		GLSL100ES: `#version 100

varying vec2 vUV;
attribute vec2 uv;
attribute vec2 pos;

void main()
{
    vUV = uv;
    gl_Position = vec4(pos, 0.0, 1.0);
}

`,
		GLSL300ES: `#version 300 es

out vec2 vUV;
layout(location = 1) in vec2 uv;
layout(location = 0) in vec2 pos;

void main()
{
    vUV = uv;
    gl_Position = vec4(pos, 0.0, 1.0);
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

out vec2 vUV;
in vec2 uv;
in vec2 pos;

void main()
{
    vUV = uv;
    gl_Position = vec4(pos, 0.0, 1.0);
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

out vec2 vUV;
in vec2 uv;
in vec2 pos;

void main()
{
    vUV = uv;
    gl_Position = vec4(pos, 0.0, 1.0);
}

`,
		HLSL: "DXBCg\xc0\xae\x16\xd8\xe1\xbdl~ń\xf1\xc4\xf6dV\x01\x00\x00\x00\xc4\x02\x00\x00\x06\x00\x00\x008\x00\x00\x00\xc8\x00\x00\x00X\x01\x00\x00\xd4\x01\x00\x00 \x02\x00\x00l\x02\x00\x00Aon9\x88\x00\x00\x00\x88\x00\x00\x00\x00\x02\xfe\xff`\x00\x00\x00(\x00\x00\x00\x00\x00$\x00\x00\x00$\x00\x00\x00$\x00\x00\x00$\x00\x01\x00$\x00\x00\x00\x00\x00\x00\x02\xfe\xffQ\x00\x00\x05\x01\x00\x0f\xa0\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x00\x00\x02\x05\x00\x00\x80\x00\x00\x0f\x90\x1f\x00\x00\x02\x05\x00\x01\x80\x01\x00\x0f\x90\x02\x00\x00\x03\x00\x00\x03\xc0\x00\x00\xe4\x90\x00\x00\xe4\xa0\x01\x00\x00\x02\x00\x00\x03\xe0\x01\x00\xe4\x90\x01\x00\x00\x02\x00\x00\f\xc0\x01\x00D\xa0\xff\xff\x00\x00SHDR\x88\x00\x00\x00@\x00\x01\x00\"\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x00\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x01\x00\x00\x00e\x00\x00\x032 \x10\x00\x00\x00\x00\x00g\x00\x00\x04\xf2 \x10\x00\x01\x00\x00\x00\x01\x00\x00\x006\x00\x00\x052 \x10\x00\x00\x00\x00\x00F\x10\x10\x00\x01\x00\x00\x006\x00\x00\x052 \x10\x00\x01\x00\x00\x00F\x10\x10\x00\x00\x00\x00\x006\x00\x00\b\xc2 \x10\x00\x01\x00\x00\x00\x02@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?>\x00\x00\x01STATt\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEFD\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xfe\xff\x00\x01\x00\x00\x1c\x00\x00\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGND\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x008\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGNP\x00\x00\x00\x02\x00\x00\x00\b\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\f\x00\x00A\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x0f\x00\x00\x00TEXCOORD\x00SV_Position\x00\xab\xab\xab",
	}
	shader_path_coarse_comp = driver.ShaderSources{
		Name: "path_coarse.comp",
		GLSL310ES: `#version 310 es
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Alloc
{
    uint offset;
};

struct MallocResult
{
    Alloc alloc;
    bool failed;
};

struct PathCubicRef
{
    uint offset;
};

struct PathCubic
{
    vec2 p0;
    vec2 p1;
    vec2 p2;
    vec2 p3;
    uint path_ix;
    uint trans_ix;
    vec2 stroke;
};

struct PathSegRef
{
    uint offset;
};

struct PathSegTag
{
    uint tag;
    uint flags;
};

struct TileRef
{
    uint offset;
};

struct PathRef
{
    uint offset;
};

struct Path
{
    uvec4 bbox;
    TileRef tiles;
};

struct TileSegRef
{
    uint offset;
};

struct TileSeg
{
    vec2 origin;
    vec2 vector;
    float y_edge;
    TileSegRef next;
};

struct TransformSegRef
{
    uint offset;
};

struct TransformSeg
{
    vec4 mat;
    vec2 translate;
};

struct SubdivResult
{
    float val;
    float a0;
    float a2;
};

struct Config
{
    uint n_elements;
    uint n_pathseg;
    uint width_in_tiles;
    uint height_in_tiles;
    Alloc tile_alloc;
    Alloc bin_alloc;
    Alloc ptcl_alloc;
    Alloc pathseg_alloc;
    Alloc anno_alloc;
    Alloc trans_alloc;
};

layout(binding = 0, std430) buffer Memory
{
    uint mem_offset;
    uint mem_error;
    uint memory[];
} _149;

layout(binding = 1, std430) readonly buffer ConfigBuf
{
    Config conf;
} _788;

bool touch_mem(Alloc alloc, uint offset)
{
    return true;
}

uint read_mem(Alloc alloc, uint offset)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return 0u;
    }
    uint v = _149.memory[offset];
    return v;
}

PathSegTag PathSeg_tag(Alloc a, PathSegRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint tag_and_flags = read_mem(param, param_1);
    return PathSegTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));
}

PathCubic PathCubic_read(Alloc a, PathCubicRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 3u;
    uint raw3 = read_mem(param_6, param_7);
    Alloc param_8 = a;
    uint param_9 = ix + 4u;
    uint raw4 = read_mem(param_8, param_9);
    Alloc param_10 = a;
    uint param_11 = ix + 5u;
    uint raw5 = read_mem(param_10, param_11);
    Alloc param_12 = a;
    uint param_13 = ix + 6u;
    uint raw6 = read_mem(param_12, param_13);
    Alloc param_14 = a;
    uint param_15 = ix + 7u;
    uint raw7 = read_mem(param_14, param_15);
    Alloc param_16 = a;
    uint param_17 = ix + 8u;
    uint raw8 = read_mem(param_16, param_17);
    Alloc param_18 = a;
    uint param_19 = ix + 9u;
    uint raw9 = read_mem(param_18, param_19);
    Alloc param_20 = a;
    uint param_21 = ix + 10u;
    uint raw10 = read_mem(param_20, param_21);
    Alloc param_22 = a;
    uint param_23 = ix + 11u;
    uint raw11 = read_mem(param_22, param_23);
    PathCubic s;
    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));
    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));
    s.p3 = vec2(uintBitsToFloat(raw6), uintBitsToFloat(raw7));
    s.path_ix = raw8;
    s.trans_ix = raw9;
    s.stroke = vec2(uintBitsToFloat(raw10), uintBitsToFloat(raw11));
    return s;
}

PathCubic PathSeg_Cubic_read(Alloc a, PathSegRef ref)
{
    Alloc param = a;
    PathCubicRef param_1 = PathCubicRef(ref.offset + 4u);
    return PathCubic_read(param, param_1);
}

TransformSeg TransformSeg_read(Alloc a, TransformSegRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 3u;
    uint raw3 = read_mem(param_6, param_7);
    Alloc param_8 = a;
    uint param_9 = ix + 4u;
    uint raw4 = read_mem(param_8, param_9);
    Alloc param_10 = a;
    uint param_11 = ix + 5u;
    uint raw5 = read_mem(param_10, param_11);
    TransformSeg s;
    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));
    return s;
}

vec2 eval_cubic(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)
{
    float mt = 1.0 - t;
    return (p0 * ((mt * mt) * mt)) + (((p1 * ((mt * mt) * 3.0)) + (((p2 * (mt * 3.0)) + (p3 * t)) * t)) * t);
}

float approx_parabola_integral(float x)
{
    return x * inversesqrt(sqrt(0.3300000131130218505859375 + (0.201511204242706298828125 + ((0.25 * x) * x))));
}

SubdivResult estimate_subdiv(vec2 p0, vec2 p1, vec2 p2, float sqrt_tol)
{
    vec2 d01 = p1 - p0;
    vec2 d12 = p2 - p1;
    vec2 dd = d01 - d12;
    float _cross = ((p2.x - p0.x) * dd.y) - ((p2.y - p0.y) * dd.x);
    float x0 = ((d01.x * dd.x) + (d01.y * dd.y)) / _cross;
    float x2 = ((d12.x * dd.x) + (d12.y * dd.y)) / _cross;
    float scale = abs(_cross / (length(dd) * (x2 - x0)));
    float param = x0;
    float a0 = approx_parabola_integral(param);
    float param_1 = x2;
    float a2 = approx_parabola_integral(param_1);
    float val = 0.0;
    if (scale < 1000000000.0)
    {
        float da = abs(a2 - a0);
        float sqrt_scale = sqrt(scale);
        if (sign(x0) == sign(x2))
        {
            val = da * sqrt_scale;
        }
        else
        {
            float xmin = sqrt_tol / sqrt_scale;
            float param_2 = xmin;
            val = (sqrt_tol * da) / approx_parabola_integral(param_2);
        }
    }
    return SubdivResult(val, a0, a2);
}

uint fill_mode_from_flags(uint flags)
{
    return flags & 1u;
}

Path Path_read(Alloc a, PathRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Path s;
    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));
    s.tiles = TileRef(raw2);
    return s;
}

Alloc new_alloc(uint offset, uint size)
{
    Alloc a;
    a.offset = offset;
    return a;
}

float approx_parabola_inv_integral(float x)
{
    return x * sqrt(0.61000001430511474609375 + (0.1520999968051910400390625 + ((0.25 * x) * x)));
}

vec2 eval_quad(vec2 p0, vec2 p1, vec2 p2, float t)
{
    float mt = 1.0 - t;
    return (p0 * (mt * mt)) + (((p1 * (mt * 2.0)) + (p2 * t)) * t);
}

MallocResult malloc(uint size)
{
    MallocResult r;
    r.failed = false;
    uint _155 = atomicAdd(_149.mem_offset, size);
    uint offset = _155;
    uint param = offset;
    uint param_1 = size;
    r.alloc = new_alloc(param, param_1);
    if ((offset + size) > uint(int(uint(_149.memory.length())) * 4))
    {
        r.failed = true;
        uint _176 = atomicMax(_149.mem_error, 1u);
        return r;
    }
    return r;
}

TileRef Tile_index(TileRef ref, uint index)
{
    return TileRef(ref.offset + (index * 8u));
}

void write_mem(Alloc alloc, uint offset, uint val)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return;
    }
    _149.memory[offset] = val;
}

void TileSeg_write(Alloc a, TileSegRef ref, TileSeg s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = floatBitsToUint(s.origin.x);
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = floatBitsToUint(s.origin.y);
    write_mem(param_3, param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 2u;
    uint param_8 = floatBitsToUint(s.vector.x);
    write_mem(param_6, param_7, param_8);
    Alloc param_9 = a;
    uint param_10 = ix + 3u;
    uint param_11 = floatBitsToUint(s.vector.y);
    write_mem(param_9, param_10, param_11);
    Alloc param_12 = a;
    uint param_13 = ix + 4u;
    uint param_14 = floatBitsToUint(s.y_edge);
    write_mem(param_12, param_13, param_14);
    Alloc param_15 = a;
    uint param_16 = ix + 5u;
    uint param_17 = s.next.offset;
    write_mem(param_15, param_16, param_17);
}

void main()
{
    if (_149.mem_error != 0u)
    {
        return;
    }
    uint element_ix = gl_GlobalInvocationID.x;
    PathSegRef ref = PathSegRef(_788.conf.pathseg_alloc.offset + (element_ix * 52u));
    PathSegTag tag = PathSegTag(0u, 0u);
    if (element_ix < _788.conf.n_pathseg)
    {
        Alloc param;
        param.offset = _788.conf.pathseg_alloc.offset;
        PathSegRef param_1 = ref;
        tag = PathSeg_tag(param, param_1);
    }
    switch (tag.tag)
    {
        case 1u:
        {
            Alloc param_2;
            param_2.offset = _788.conf.pathseg_alloc.offset;
            PathSegRef param_3 = ref;
            PathCubic cubic = PathSeg_Cubic_read(param_2, param_3);
            uint trans_ix = cubic.trans_ix;
            if (trans_ix > 0u)
            {
                TransformSegRef trans_ref = TransformSegRef(_788.conf.trans_alloc.offset + ((trans_ix - 1u) * 24u));
                Alloc param_4;
                param_4.offset = _788.conf.trans_alloc.offset;
                TransformSegRef param_5 = trans_ref;
                TransformSeg trans = TransformSeg_read(param_4, param_5);
                cubic.p0 = ((trans.mat.xy * cubic.p0.x) + (trans.mat.zw * cubic.p0.y)) + trans.translate;
                cubic.p1 = ((trans.mat.xy * cubic.p1.x) + (trans.mat.zw * cubic.p1.y)) + trans.translate;
                cubic.p2 = ((trans.mat.xy * cubic.p2.x) + (trans.mat.zw * cubic.p2.y)) + trans.translate;
                cubic.p3 = ((trans.mat.xy * cubic.p3.x) + (trans.mat.zw * cubic.p3.y)) + trans.translate;
            }
            vec2 err_v = (((cubic.p2 - cubic.p1) * 3.0) + cubic.p0) - cubic.p3;
            float err = (err_v.x * err_v.x) + (err_v.y * err_v.y);
            uint n_quads = max(uint(ceil(pow(err * 3.7037036418914794921875, 0.16666667163372039794921875))), 1u);
            float val = 0.0;
            vec2 qp0 = cubic.p0;
            float _step = 1.0 / float(n_quads);
            for (uint i = 0u; i < n_quads; i++)
            {
                float t = float(i + 1u) * _step;
                vec2 param_6 = cubic.p0;
                vec2 param_7 = cubic.p1;
                vec2 param_8 = cubic.p2;
                vec2 param_9 = cubic.p3;
                float param_10 = t;
                vec2 qp2 = eval_cubic(param_6, param_7, param_8, param_9, param_10);
                vec2 param_11 = cubic.p0;
                vec2 param_12 = cubic.p1;
                vec2 param_13 = cubic.p2;
                vec2 param_14 = cubic.p3;
                float param_15 = t - (0.5 * _step);
                vec2 qp1 = eval_cubic(param_11, param_12, param_13, param_14, param_15);
                qp1 = (qp1 * 2.0) - ((qp0 + qp2) * 0.5);
                vec2 param_16 = qp0;
                vec2 param_17 = qp1;
                vec2 param_18 = qp2;
                float param_19 = 0.4743416607379913330078125;
                SubdivResult params = estimate_subdiv(param_16, param_17, param_18, param_19);
                val += params.val;
                qp0 = qp2;
            }
            uint n = max(uint(ceil((val * 0.5) / 0.4743416607379913330078125)), 1u);
            uint param_20 = tag.flags;
            bool is_stroke = fill_mode_from_flags(param_20) == 1u;
            uint path_ix = cubic.path_ix;
            Alloc param_21;
            param_21.offset = _788.conf.tile_alloc.offset;
            PathRef param_22 = PathRef(_788.conf.tile_alloc.offset + (path_ix * 12u));
            Path path = Path_read(param_21, param_22);
            uint param_23 = path.tiles.offset;
            uint param_24 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;
            Alloc path_alloc = new_alloc(param_23, param_24);
            ivec4 bbox = ivec4(path.bbox);
            vec2 p0 = cubic.p0;
            qp0 = cubic.p0;
            float v_step = val / float(n);
            int n_out = 1;
            float val_sum = 0.0;
            vec2 p1;
            float _1309;
            TileSeg tile_seg;
            for (uint i_1 = 0u; i_1 < n_quads; i_1++)
            {
                float t_1 = float(i_1 + 1u) * _step;
                vec2 param_25 = cubic.p0;
                vec2 param_26 = cubic.p1;
                vec2 param_27 = cubic.p2;
                vec2 param_28 = cubic.p3;
                float param_29 = t_1;
                vec2 qp2_1 = eval_cubic(param_25, param_26, param_27, param_28, param_29);
                vec2 param_30 = cubic.p0;
                vec2 param_31 = cubic.p1;
                vec2 param_32 = cubic.p2;
                vec2 param_33 = cubic.p3;
                float param_34 = t_1 - (0.5 * _step);
                vec2 qp1_1 = eval_cubic(param_30, param_31, param_32, param_33, param_34);
                qp1_1 = (qp1_1 * 2.0) - ((qp0 + qp2_1) * 0.5);
                vec2 param_35 = qp0;
                vec2 param_36 = qp1_1;
                vec2 param_37 = qp2_1;
                float param_38 = 0.4743416607379913330078125;
                SubdivResult params_1 = estimate_subdiv(param_35, param_36, param_37, param_38);
                float param_39 = params_1.a0;
                float u0 = approx_parabola_inv_integral(param_39);
                float param_40 = params_1.a2;
                float u2 = approx_parabola_inv_integral(param_40);
                float uscale = 1.0 / (u2 - u0);
                float target = float(n_out) * v_step;
                for (;;)
                {
                    bool _1202 = uint(n_out) == n;
                    bool _1212;
                    if (!_1202)
                    {
                        _1212 = target < (val_sum + params_1.val);
                    }
                    else
                    {
                        _1212 = _1202;
                    }
                    if (_1212)
                    {
                        if (uint(n_out) == n)
                        {
                            p1 = cubic.p3;
                        }
                        else
                        {
                            float u = (target - val_sum) / params_1.val;
                            float a = mix(params_1.a0, params_1.a2, u);
                            float param_41 = a;
                            float au = approx_parabola_inv_integral(param_41);
                            float t_2 = (au - u0) * uscale;
                            vec2 param_42 = qp0;
                            vec2 param_43 = qp1_1;
                            vec2 param_44 = qp2_1;
                            float param_45 = t_2;
                            p1 = eval_quad(param_42, param_43, param_44, param_45);
                        }
                        float xmin = min(p0.x, p1.x) - cubic.stroke.x;
                        float xmax = max(p0.x, p1.x) + cubic.stroke.x;
                        float ymin = min(p0.y, p1.y) - cubic.stroke.y;
                        float ymax = max(p0.y, p1.y) + cubic.stroke.y;
                        float dx = p1.x - p0.x;
                        float dy = p1.y - p0.y;
                        if (abs(dy) < 9.999999717180685365747194737196e-10)
                        {
                            _1309 = 1000000000.0;
                        }
                        else
                        {
                            _1309 = dx / dy;
                        }
                        float invslope = _1309;
                        float c = (cubic.stroke.x + (abs(invslope) * (16.0 + cubic.stroke.y))) * 0.03125;
                        float b = invslope;
                        float a_1 = (p0.x - ((p0.y - 16.0) * b)) * 0.03125;
                        int x0 = int(floor(xmin * 0.03125));
                        int x1 = int(floor(xmax * 0.03125) + 1.0);
                        int y0 = int(floor(ymin * 0.03125));
                        int y1 = int(floor(ymax * 0.03125) + 1.0);
                        x0 = clamp(x0, bbox.x, bbox.z);
                        y0 = clamp(y0, bbox.y, bbox.w);
                        x1 = clamp(x1, bbox.x, bbox.z);
                        y1 = clamp(y1, bbox.y, bbox.w);
                        float xc = a_1 + (b * float(y0));
                        int stride = bbox.z - bbox.x;
                        int base = ((y0 - bbox.y) * stride) - bbox.x;
                        uint n_tile_alloc = uint((x1 - x0) * (y1 - y0));
                        uint param_46 = n_tile_alloc * 24u;
                        MallocResult _1424 = malloc(param_46);
                        MallocResult tile_alloc = _1424;
                        if (tile_alloc.failed)
                        {
                            return;
                        }
                        uint tile_offset = tile_alloc.alloc.offset;
                        int xray = int(floor(p0.x * 0.03125));
                        int last_xray = int(floor(p1.x * 0.03125));
                        if (p0.y > p1.y)
                        {
                            int tmp = xray;
                            xray = last_xray;
                            last_xray = tmp;
                        }
                        for (int y = y0; y < y1; y++)
                        {
                            float tile_y0 = float(y * 32);
                            int xbackdrop = max((xray + 1), bbox.x);
                            bool _1478 = !is_stroke;
                            bool _1488;
                            if (_1478)
                            {
                                _1488 = min(p0.y, p1.y) < tile_y0;
                            }
                            else
                            {
                                _1488 = _1478;
                            }
                            bool _1495;
                            if (_1488)
                            {
                                _1495 = xbackdrop < bbox.z;
                            }
                            else
                            {
                                _1495 = _1488;
                            }
                            if (_1495)
                            {
                                int backdrop = (p1.y < p0.y) ? 1 : (-1);
                                TileRef param_47 = path.tiles;
                                uint param_48 = uint(base + xbackdrop);
                                TileRef tile_ref = Tile_index(param_47, param_48);
                                uint tile_el = tile_ref.offset >> uint(2);
                                Alloc param_49 = path_alloc;
                                uint param_50 = tile_el + 1u;
                                if (touch_mem(param_49, param_50))
                                {
                                    uint _1533 = atomicAdd(_149.memory[tile_el + 1u], uint(backdrop));
                                }
                            }
                            int next_xray = last_xray;
                            if (y < (y1 - 1))
                            {
                                float tile_y1 = float((y + 1) * 32);
                                float x_edge = mix(p0.x, p1.x, (tile_y1 - p0.y) / dy);
                                next_xray = int(floor(x_edge * 0.03125));
                            }
                            int min_xray = min(xray, next_xray);
                            int max_xray = max(xray, next_xray);
                            int xx0 = min(int(floor(xc - c)), min_xray);
                            int xx1 = max(int(ceil(xc + c)), (max_xray + 1));
                            xx0 = clamp(xx0, x0, x1);
                            xx1 = clamp(xx1, x0, x1);
                            for (int x = xx0; x < xx1; x++)
                            {
                                float tile_x0 = float(x * 32);
                                TileRef param_51 = TileRef(path.tiles.offset);
                                uint param_52 = uint(base + x);
                                TileRef tile_ref_1 = Tile_index(param_51, param_52);
                                uint tile_el_1 = tile_ref_1.offset >> uint(2);
                                uint old = 0u;
                                Alloc param_53 = path_alloc;
                                uint param_54 = tile_el_1;
                                if (touch_mem(param_53, param_54))
                                {
                                    uint _1636 = atomicExchange(_149.memory[tile_el_1], tile_offset);
                                    old = _1636;
                                }
                                tile_seg.origin = p0;
                                tile_seg.vector = p1 - p0;
                                float y_edge = 0.0;
                                if (!is_stroke)
                                {
                                    y_edge = mix(p0.y, p1.y, (tile_x0 - p0.x) / dx);
                                    if (min(p0.x, p1.x) < tile_x0)
                                    {
                                        vec2 p = vec2(tile_x0, y_edge);
                                        if (p0.x > p1.x)
                                        {
                                            tile_seg.vector = p - p0;
                                        }
                                        else
                                        {
                                            tile_seg.origin = p;
                                            tile_seg.vector = p1 - p;
                                        }
                                        if (tile_seg.vector.x == 0.0)
                                        {
                                            tile_seg.vector.x = sign(p1.x - p0.x) * 9.999999717180685365747194737196e-10;
                                        }
                                    }
                                    if ((x <= min_xray) || (max_xray < x))
                                    {
                                        y_edge = 1000000000.0;
                                    }
                                }
                                tile_seg.y_edge = y_edge;
                                tile_seg.next.offset = old;
                                Alloc param_55 = tile_alloc.alloc;
                                TileSegRef param_56 = TileSegRef(tile_offset);
                                TileSeg param_57 = tile_seg;
                                TileSeg_write(param_55, param_56, param_57);
                                tile_offset += 24u;
                            }
                            xc += b;
                            base += stride;
                            xray = next_xray;
                        }
                        n_out++;
                        target += v_step;
                        p0 = p1;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                val_sum += params_1.val;
                qp0 = qp2_1;
            }
            break;
        }
    }
}

`,
	}
	shader_stencil_frag = driver.ShaderSources{
		Name:   "stencil.frag",
		Inputs: []driver.InputLocation{{Name: "vFrom", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "vCtrl", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}, {Name: "vTo", Location: 2, Semantic: "TEXCOORD", SemanticIndex: 2, Type: 0x0, Size: 2}},
		GLSL100ES: `#version 100
precision mediump float;
precision highp int;

varying vec2 vTo;
varying vec2 vFrom;
varying vec2 vCtrl;

void main()
{
    float dx = vTo.x - vFrom.x;
    bool increasing = vTo.x >= vFrom.x;
    bvec2 _35 = bvec2(increasing);
    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);
    bvec2 _41 = bvec2(increasing);
    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);
    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));
    float midx = mix(extent.x, extent.y, 0.5);
    float x0 = midx - left.x;
    vec2 p1 = vCtrl - left;
    vec2 v = right - vCtrl;
    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));
    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);
    vec2 d_half = mix(p1, v, vec2(t));
    float dy = d_half.y / d_half.x;
    float width = extent.y - extent.x;
    dy = abs(dy * width);
    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);
    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));
    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));
    area *= width;
    if (width == 0.0)
    {
        area = 0.0;
    }
    gl_FragData[0].x = area;
}

`,
		GLSL300ES: `#version 300 es
precision mediump float;
precision highp int;

in vec2 vTo;
in vec2 vFrom;
in vec2 vCtrl;
layout(location = 0) out vec4 fragCover;

void main()
{
    float dx = vTo.x - vFrom.x;
    bool increasing = vTo.x >= vFrom.x;
    bvec2 _35 = bvec2(increasing);
    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);
    bvec2 _41 = bvec2(increasing);
    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);
    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));
    float midx = mix(extent.x, extent.y, 0.5);
    float x0 = midx - left.x;
    vec2 p1 = vCtrl - left;
    vec2 v = right - vCtrl;
    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));
    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);
    vec2 d_half = mix(p1, v, vec2(t));
    float dy = d_half.y / d_half.x;
    float width = extent.y - extent.x;
    dy = abs(dy * width);
    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);
    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));
    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));
    area *= width;
    if (width == 0.0)
    {
        area = 0.0;
    }
    fragCover.x = area;
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

in vec2 vTo;
in vec2 vFrom;
in vec2 vCtrl;
out vec4 fragCover;

void main()
{
    float dx = vTo.x - vFrom.x;
    bool increasing = vTo.x >= vFrom.x;
    bvec2 _35 = bvec2(increasing);
    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);
    bvec2 _41 = bvec2(increasing);
    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);
    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));
    float midx = mix(extent.x, extent.y, 0.5);
    float x0 = midx - left.x;
    vec2 p1 = vCtrl - left;
    vec2 v = right - vCtrl;
    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));
    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);
    vec2 d_half = mix(p1, v, vec2(t));
    float dy = d_half.y / d_half.x;
    float width = extent.y - extent.x;
    dy = abs(dy * width);
    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);
    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));
    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));
    area *= width;
    if (width == 0.0)
    {
        area = 0.0;
    }
    fragCover.x = area;
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

in vec2 vTo;
in vec2 vFrom;
in vec2 vCtrl;
out vec4 fragCover;

void main()
{
    float dx = vTo.x - vFrom.x;
    bool increasing = vTo.x >= vFrom.x;
    bvec2 _35 = bvec2(increasing);
    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);
    bvec2 _41 = bvec2(increasing);
    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);
    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));
    float midx = mix(extent.x, extent.y, 0.5);
    float x0 = midx - left.x;
    vec2 p1 = vCtrl - left;
    vec2 v = right - vCtrl;
    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));
    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);
    vec2 d_half = mix(p1, v, vec2(t));
    float dy = d_half.y / d_half.x;
    float width = extent.y - extent.x;
    dy = abs(dy * width);
    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);
    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));
    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));
    area *= width;
    if (width == 0.0)
    {
        area = 0.0;
    }
    fragCover.x = area;
}

`,
		HLSL: "DXBC\x94!\xb9\x13L\xba\r\x11\x8f\xc7\xce\x0eAs\xec\xe1\x01\x00\x00\x00\\\n\x00\x00\x06\x00\x00\x008\x00\x00\x00\x9c\x03\x00\x00\xfc\b\x00\x00x\t\x00\x00\xc4\t\x00\x00(\n\x00\x00Aon9\\\x03\x00\x00\\\x03\x00\x00\x00\x02\xff\xff8\x03\x00\x00$\x00\x00\x00\x00\x00$\x00\x00\x00$\x00\x00\x00$\x00\x00\x00$\x00\x00\x00$\x00\x00\x02\xff\xffQ\x00\x00\x05\x00\x00\x0f\xa0\x00\x00\x00\xbf\x00\x00\x00?\x00\x00\x80?\x00\x00\x00\x00\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x0f\xb0\x1f\x00\x00\x02\x00\x00\x00\x80\x01\x00\x03\xb0\v\x00\x00\x03\x00\x00\x01\x80\x00\x00\x00\xb0\x00\x00\x00\xa0\v\x00\x00\x03\x00\x00\x02\x80\x01\x00\x00\xb0\x00\x00\x00\xa0\n\x00\x00\x03\x01\x00\x03\x80\x00\x00\xe4\x80\x00\x00U\xa0\x02\x00\x00\x03\x00\x00\x01\x80\x01\x00\x00\x81\x01\x00U\x80\x04\x00\x00\x04\x00\x00\x02\x80\x00\x00\x00\x80\x00\x00U\xa0\x01\x00\x00\x80\x01\x00\x00\x02\x01\x00\x03\x80\x00\x00\xe4\xb0\n\x00\x00\x03\x02\x00\x01\x80\x01\x00\x00\x80\x01\x00\x00\xb0\x02\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x02\x00\x00\x81\v\x00\x00\x03\x03\x00\x01\x80\x01\x00\x00\xb0\x01\x00\x00\x80\x02\x00\x00\x03\x00\x00\x04\x80\x01\x00\x00\x81\x01\x00\x00\xb0X\x00\x00\x04\x03\x00\x02\x80\x00\x00\xaa\x80\x01\x00U\xb0\x01\x00U\x80X\x00\x00\x04\x02\x00\x02\x80\x00\x00\xaa\x80\x01\x00U\x80\x01\x00U\xb0\x02\x00\x00\x03\x00\x00\f\x80\x03\x00\x1b\x80\x00\x00\xe4\xb1\x02\x00\x00\x03\x01\x00\x03\x80\x02\x00\xe4\x81\x00\x00\x1b\xb0\x02\x00\x00\x03\x01\x00\x04\x80\x00\x00\xff\x80\x01\x00\x00\x81\x05\x00\x00\x03\x01\x00\x04\x80\x00\x00U\x80\x01\x00\xaa\x80\x04\x00\x00\x04\x01\x00\x04\x80\x01\x00\x00\x80\x01\x00\x00\x80\x01\x00\xaa\x80\a\x00\x00\x02\x01\x00\x04\x80\x01\x00\xaa\x80\x06\x00\x00\x02\x01\x00\x04\x80\x01\x00\xaa\x80\x02\x00\x00\x03\x01\x00\x04\x80\x01\x00\xaa\x80\x01\x00\x00\x80\x06\x00\x00\x02\x01\x00\x04\x80\x01\x00\xaa\x80\x05\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x01\x00\xaa\x80\x04\x00\x00\x04\x01\x00\x04\x80\x00\x00U\x80\x01\x00U\x80\x02\x00U\x80\x12\x00\x00\x04\x02\x00\x03\x80\x00\x00U\x80\x00\x00\x1b\x80\x01\x00\xe4\x80\x04\x00\x00\x04\x00\x00\x04\x80\x00\x00U\x80\x00\x00\xaa\x80\x00\x00\xaa\xb0\x12\x00\x00\x04\x02\x00\x04\x80\x00\x00U\x80\x00\x00\xaa\x80\x01\x00\xaa\x80\x06\x00\x00\x02\x00\x00\x02\x80\x02\x00\x00\x80\x05\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x02\x00U\x80\x05\x00\x00\x03\x00\x00\x02\x80\x00\x00\x00\x80\x00\x00U\x80#\x00\x00\x02\x00\x00\x02\x80\x00\x00U\x80\x04\x00\x00\x04\x01\x00\x01\x80\x00\x00U\x80\x00\x00U\xa0\x02\x00\xaa\x80\x04\x00\x00\x04\x01\x00\x02\x80\x00\x00U\x80\x00\x00\x00\xa0\x02\x00\xaa\x80\x06\x00\x00\x02\x00\x00\x02\x80\x00\x00U\x80\x02\x00\x00\x03\x00\x00\f\x80\x02\x00\xaa\x81\x00\x00\x1b\xa0\x05\x00\x00\x03\x01\x00\b\x80\x00\x00U\x80\x00\x00\xff\x80\x05\x00\x00\x03\x01\x00\x04\x80\x00\x00U\x80\x00\x00\xaa\x80\x02\x00\x00\x03\x01\x00\x1f\x80\x01\x00\xe4\x80\x00\x00U\xa0\x04\x00\x00\x04\x00\x00\x02\x80\x01\x00\xaa\x80\x01\x00U\x81\x01\x00\xaa\x80\x02\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x00\x00\xaa\xa0\x02\x00\x00\x03\x00\x00\x02\x80\x01\x00\x00\x81\x00\x00U\x80\x04\x00\x00\x04\x00\x00\x02\x80\x01\x00\x00\x80\x01\x00\xff\x80\x00\x00U\x80\x05\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x00\x00\x00\x80\x05\x00\x00\x03\x00\x00\x01\x80\x00\x00\x00\x80\x00\x00\x00\x80\x05\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x00\x00U\xa0X\x00\x00\x04\x00\x00\x01\x80\x00\x00\x00\x81\x00\x00\xff\xa0\x00\x00U\x80\x01\x00\x00\x02\x00\x00\x0e\x80\x00\x00\xff\xa0\x01\x00\x00\x02\x00\b\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00SHDRX\x05\x00\x00@\x00\x00\x00V\x01\x00\x00b\x10\x00\x032\x10\x10\x00\x00\x00\x00\x00b\x10\x00\x03\xc2\x10\x10\x00\x00\x00\x00\x00b\x10\x00\x032\x10\x10\x00\x01\x00\x00\x00e\x00\x00\x03\xf2 \x10\x00\x00\x00\x00\x00h\x00\x00\x02\x03\x00\x00\x006\x00\x00\x05\x12\x00\x10\x00\x00\x00\x00\x00\n\x10\x10\x00\x00\x00\x00\x006\x00\x00\x05\"\x00\x10\x00\x00\x00\x00\x00\n\x10\x10\x00\x01\x00\x00\x004\x00\x00\n2\x00\x10\x00\x00\x00\x00\x00F\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x00\xbf\x00\x00\x00\xbf\x00\x00\x00\x00\x00\x00\x00\x003\x00\x00\n2\x00\x10\x00\x00\x00\x00\x00F\x00\x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x00?\x00\x00\x00?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\b\"\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x80A\x00\x00\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x00\x00\x00\x002\x00\x00\t\x12\x00\x10\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00?\n\x00\x10\x00\x00\x00\x00\x003\x00\x00\a2\x00\x10\x00\x01\x00\x00\x00\x06\x10\x10\x00\x00\x00\x00\x00\x06\x10\x10\x00\x01\x00\x00\x00\x00\x00\x00\b\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x80A\x00\x00\x00\x01\x00\x00\x004\x00\x00\a2\x00\x10\x00\x02\x00\x00\x00\x06\x10\x10\x00\x00\x00\x00\x00\x06\x10\x10\x00\x01\x00\x00\x00\x1d\x00\x00\aB\x00\x10\x00\x00\x00\x00\x00\n\x10\x10\x00\x01\x00\x00\x00\n\x10\x10\x00\x00\x00\x00\x007\x00\x00\tB\x00\x10\x00\x02\x00\x00\x00*\x00\x10\x00\x00\x00\x00\x00\x1a\x10\x10\x00\x01\x00\x00\x00\x1a\x10\x10\x00\x00\x00\x00\x007\x00\x00\tB\x00\x10\x00\x01\x00\x00\x00*\x00\x10\x00\x00\x00\x00\x00\x1a\x10\x10\x00\x00\x00\x00\x00\x1a\x10\x10\x00\x01\x00\x00\x00\x00\x00\x00\br\x00\x10\x00\x02\x00\x00\x00F\x02\x10\x00\x02\x00\x00\x00\xa6\x1b\x10\x80A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\b\xc2\x00\x10\x00\x00\x00\x00\x00V\t\x10\x80A\x00\x00\x00\x01\x00\x00\x00\xa6\x1e\x10\x00\x00\x00\x00\x00\x00\x00\x00\b\xb2\x00\x10\x00\x01\x00\x00\x00\xa6\x0e\x10\x80A\x00\x00\x00\x00\x00\x00\x00F\b\x10\x00\x02\x00\x00\x008\x00\x00\a\x12\x00\x10\x00\x01\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x01\x00\x00\x002\x00\x00\t\x12\x00\x10\x00\x01\x00\x00\x00*\x00\x10\x00\x00\x00\x00\x00*\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x01\x00\x00\x00K\x00\x00\x05\x12\x00\x10\x00\x01\x00\x00\x00\n\x00\x10\x00\x01\x00\x00\x00\x00\x00\x00\a\x12\x00\x10\x00\x01\x00\x00\x00*\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x01\x00\x00\x00\x0e\x00\x00\a\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x01\x00\x00\x002\x00\x00\t\x12\x00\x10\x00\x01\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x00*\x00\x10\x00\x01\x00\x00\x002\x00\x00\t\xc2\x00\x10\x00\x00\x00\x00\x00\x06\x00\x10\x00\x00\x00\x00\x00V\r\x10\x00\x01\x00\x00\x00\xa6\x0e\x10\x00\x00\x00\x00\x00\x0e\x00\x00\aB\x00\x10\x00\x00\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x00*\x00\x10\x00\x00\x00\x00\x008\x00\x00\aB\x00\x10\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x00\x00\x00\x00*\x00\x10\x00\x00\x00\x00\x002\x00\x00\t\x82\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00*\x00\x10\x00\x02\x00\x00\x00:\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\b\x82\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x80A\x00\x00\x00\x01\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x002\x00\x00\t\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x01\x00\x00\x00\x00\x00\x00\v2\x00\x10\x00\x01\x00\x00\x00\x06\x00\x10\x80A\x00\x00\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x00?\x00\x00\x00\xbf\x00\x00\x00\x00\x00\x00\x00\x002\x00\x00\r2\x00\x10\x00\x02\x00\x00\x00\xa6\n\x10\x80\x81\x00\x00\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x00?\x00\x00\x00\xbf\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x10\x00\x00\x00\x00\x00\x0e\x00\x00\b\xc2\x00\x10\x00\x02\x00\x00\x00\x06\x04\x10\x00\x01\x00\x00\x00\xa6\n\x10\x80\x81\x00\x00\x00\x00\x00\x00\x00\x00 \x00\n\xf2\x00\x10\x00\x01\x00\x00\x00F\x0e\x10\x00\x02\x00\x00\x00\x02@\x00\x00\x00\x00\x00?\x00\x00\x00?\x00\x00\x00?\x00\x00\x00?2\x00\x00\n\x12\x00\x10\x00\x00\x00\x00\x00*\x00\x10\x80A\x00\x00\x00\x01\x00\x00\x00\x1a\x00\x10\x00\x01\x00\x00\x00*\x00\x10\x00\x01\x00\x00\x00\x00\x00\x00\a\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x80?\x00\x00\x00\b\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x80A\x00\x00\x00\x01\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x002\x00\x00\t\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x01\x00\x00\x00:\x00\x10\x00\x01\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x008\x00\x00\a\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x00\x00\x00\x00\x18\x00\x00\a\"\x00\x10\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00\x008\x00\x00\a\x12\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00?7\x00\x00\t\x12 \x10\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x006\x00\x00\b\xe2 \x10\x00\x00\x00\x00\x00\x02@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00>\x00\x00\x01STATt\x00\x00\x00)\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEFD\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xff\xff\x00\x01\x00\x00\x1c\x00\x00\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGN\\\x00\x00\x00\x03\x00\x00\x00\b\x00\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x03\x00\x00P\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\f\f\x00\x00P\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGN,\x00\x00\x00\x01\x00\x00\x00\b\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00SV_Target\x00\xab\xab",
	}
	shader_stencil_vert = driver.ShaderSources{
		Name:   "stencil.vert",
		Inputs: []driver.InputLocation{{Name: "corner", Location: 0, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 1}, {Name: "maxy", Location: 1, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 1}, {Name: "from", Location: 2, Semantic: "TEXCOORD", SemanticIndex: 2, Type: 0x0, Size: 2}, {Name: "ctrl", Location: 3, Semantic: "TEXCOORD", SemanticIndex: 3, Type: 0x0, Size: 2}, {Name: "to", Location: 4, Semantic: "TEXCOORD", SemanticIndex: 4, Type: 0x0, Size: 2}},
		Uniforms: driver.UniformsReflection{
			Blocks:    []driver.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []driver.UniformLocation{{Name: "_block.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_block.pathOffset", Type: 0x0, Size: 2, Offset: 16}},
			Size:      24,
		},
		GLSL100ES: `#version 100

struct Block
{
    vec4 transform;
    vec2 pathOffset;
};

uniform Block _block;

attribute vec2 from;
attribute vec2 ctrl;
attribute vec2 to;
attribute float maxy;
attribute float corner;
varying vec2 vFrom;
varying vec2 vCtrl;
varying vec2 vTo;

void main()
{
    vec2 from_1 = from + _block.pathOffset;
    vec2 ctrl_1 = ctrl + _block.pathOffset;
    vec2 to_1 = to + _block.pathOffset;
    float maxy_1 = maxy + _block.pathOffset.y;
    float c = corner;
    vec2 pos;
    if (c >= 0.375)
    {
        c -= 0.5;
        pos.y = maxy_1 + 1.0;
    }
    else
    {
        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;
    }
    if (c >= 0.125)
    {
        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;
    }
    else
    {
        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;
    }
    vFrom = from_1 - pos;
    vCtrl = ctrl_1 - pos;
    vTo = to_1 - pos;
    pos = (pos * _block.transform.xy) + _block.transform.zw;
    gl_Position = vec4(pos, 1.0, 1.0);
}

`,
		GLSL300ES: `#version 300 es

layout(std140) uniform Block
{
    vec4 transform;
    vec2 pathOffset;
} _block;

layout(location = 2) in vec2 from;
layout(location = 3) in vec2 ctrl;
layout(location = 4) in vec2 to;
layout(location = 1) in float maxy;
layout(location = 0) in float corner;
out vec2 vFrom;
out vec2 vCtrl;
out vec2 vTo;

void main()
{
    vec2 from_1 = from + _block.pathOffset;
    vec2 ctrl_1 = ctrl + _block.pathOffset;
    vec2 to_1 = to + _block.pathOffset;
    float maxy_1 = maxy + _block.pathOffset.y;
    float c = corner;
    vec2 pos;
    if (c >= 0.375)
    {
        c -= 0.5;
        pos.y = maxy_1 + 1.0;
    }
    else
    {
        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;
    }
    if (c >= 0.125)
    {
        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;
    }
    else
    {
        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;
    }
    vFrom = from_1 - pos;
    vCtrl = ctrl_1 - pos;
    vTo = to_1 - pos;
    pos = (pos * _block.transform.xy) + _block.transform.zw;
    gl_Position = vec4(pos, 1.0, 1.0);
}

`,
		GLSL130: `#version 130
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

struct Block
{
    vec4 transform;
    vec2 pathOffset;
};

uniform Block _block;

in vec2 from;
in vec2 ctrl;
in vec2 to;
in float maxy;
in float corner;
out vec2 vFrom;
out vec2 vCtrl;
out vec2 vTo;

void main()
{
    vec2 from_1 = from + _block.pathOffset;
    vec2 ctrl_1 = ctrl + _block.pathOffset;
    vec2 to_1 = to + _block.pathOffset;
    float maxy_1 = maxy + _block.pathOffset.y;
    float c = corner;
    vec2 pos;
    if (c >= 0.375)
    {
        c -= 0.5;
        pos.y = maxy_1 + 1.0;
    }
    else
    {
        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;
    }
    if (c >= 0.125)
    {
        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;
    }
    else
    {
        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;
    }
    vFrom = from_1 - pos;
    vCtrl = ctrl_1 - pos;
    vTo = to_1 - pos;
    pos = (pos * _block.transform.xy) + _block.transform.zw;
    gl_Position = vec4(pos, 1.0, 1.0);
}

`,
		GLSL150: `#version 150
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 0, std140) uniform Block
{
    vec4 transform;
    vec2 pathOffset;
} _block;

in vec2 from;
in vec2 ctrl;
in vec2 to;
in float maxy;
in float corner;
out vec2 vFrom;
out vec2 vCtrl;
out vec2 vTo;

void main()
{
    vec2 from_1 = from + _block.pathOffset;
    vec2 ctrl_1 = ctrl + _block.pathOffset;
    vec2 to_1 = to + _block.pathOffset;
    float maxy_1 = maxy + _block.pathOffset.y;
    float c = corner;
    vec2 pos;
    if (c >= 0.375)
    {
        c -= 0.5;
        pos.y = maxy_1 + 1.0;
    }
    else
    {
        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;
    }
    if (c >= 0.125)
    {
        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;
    }
    else
    {
        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;
    }
    vFrom = from_1 - pos;
    vCtrl = ctrl_1 - pos;
    vTo = to_1 - pos;
    pos = (pos * _block.transform.xy) + _block.transform.zw;
    gl_Position = vec4(pos, 1.0, 1.0);
}

`,
		HLSL: "DXBC\xa5!\xd8\x10\xb4n\x90\xe3\xd9U\xdb\xe2\xb6~I0\x01\x00\x00\x00\x10\b\x00\x00\x06\x00\x00\x008\x00\x00\x00L\x02\x00\x00t\x05\x00\x00\xf0\x05\x00\x00\xf4\x06\x00\x00\x88\a\x00\x00Aon9\f\x02\x00\x00\f\x02\x00\x00\x00\x02\xfe\xff\xd8\x01\x00\x004\x00\x00\x00\x01\x00$\x00\x00\x000\x00\x00\x000\x00\x00\x00$\x00\x01\x000\x00\x00\x00\x00\x00\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xfe\xffQ\x00\x00\x05\x03\x00\x0f\xa0\x00\x00\xc0>\x00\x00\x80?\x00\x00\x80\xbf\x00\x00\x00\xbfQ\x00\x00\x05\x04\x00\x0f\xa0\x00\x00\x00>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x00\x00\x02\x05\x00\x00\x80\x00\x00\x0f\x90\x1f\x00\x00\x02\x05\x00\x01\x80\x01\x00\x0f\x90\x1f\x00\x00\x02\x05\x00\x02\x80\x02\x00\x0f\x90\x1f\x00\x00\x02\x05\x00\x03\x80\x03\x00\x0f\x90\x1f\x00\x00\x02\x05\x00\x04\x80\x04\x00\x0f\x90\x02\x00\x00\x03\x00\x00\x01\x80\x01\x00\x00\x90\x02\x00U\xa0\x02\x00\x00\x03\x00\x00\x04\x80\x00\x00\x00\x80\x03\x00U\xa0\r\x00\x00\x03\x00\x00\x01\x80\x00\x00\x00\x90\x03\x00\x00\xa0\x01\x00\x00\x02\x01\x00\x04\x80\x00\x00\x00\x90\x02\x00\x00\x03\x00\x00\x02\x80\x00\x00\x00\x90\x03\x00\xff\xa0\x02\x00\x00\x03\x02\x00\x03\x80\x02\x00\xe4\x90\x02\x00\xe4\xa0\x02\x00\x00\x03\x02\x00\f\x80\x03\x00\x14\x90\x02\x00\x14\xa0\n\x00\x00\x03\x03\x00\x03\x80\x02\x00\xee\x80\x02\x00\xe1\x80\x02\x00\x00\x03\x03\x00\f\x80\x04\x00D\x90\x02\x00D\xa0\n\x00\x00\x03\x03\x00\x03\x80\x03\x00\xeb\x80\x03\x00\xe4\x80\x02\x00\x00\x03\x01\x00\x03\x80\x03\x00\xe4\x80\x03\x00\xaa\xa0\x12\x00\x00\x04\x04\x00\x06\x80\x00\x00\x00\x80\x00\x00\xe4\x80\x01\x00Ȁ\r\x00\x00\x03\x00\x00\x01\x80\x04\x00U\x80\x04\x00\x00\xa0\v\x00\x00\x03\x00\x00\x02\x80\x02\x00\xff\x80\x02\x00\x00\x80\v\x00\x00\x03\x00\x00\x02\x80\x03\x00\xaa\x80\x00\x00U\x80\x02\x00\x00\x03\x00\x00\x02\x80\x00\x00U\x80\x03\x00U\xa0\x12\x00\x00\x04\x04\x00\x01\x80\x00\x00\x00\x80\x00\x00U\x80\x01\x00U\x80\x02\x00\x00\x03\x00\x00\x0f\xe0\x02\x00\xe4\x80\x04\x00(\x81\x02\x00\x00\x03\x01\x00\x03\xe0\x03\x00\xee\x80\x04\x00\xe8\x81\x04\x00\x00\x04\x00\x00\x03\x80\x04\x00\xe8\x80\x01\x00\xe4\xa0\x01\x00\xee\xa0\x02\x00\x00\x03\x00\x00\x03\xc0\x00\x00\xe4\x80\x00\x00\xe4\xa0\x01\x00\x00\x02\x00\x00\f\xc0\x03\x00U\xa0\xff\xff\x00\x00SHDR \x03\x00\x00@\x00\x01\x00\xc8\x00\x00\x00Y\x00\x00\x04F\x8e \x00\x00\x00\x00\x00\x02\x00\x00\x00_\x00\x00\x03\x12\x10\x10\x00\x00\x00\x00\x00_\x00\x00\x03\x12\x10\x10\x00\x01\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x02\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x03\x00\x00\x00_\x00\x00\x032\x10\x10\x00\x04\x00\x00\x00e\x00\x00\x032 \x10\x00\x00\x00\x00\x00e\x00\x00\x03\xc2 \x10\x00\x00\x00\x00\x00e\x00\x00\x032 \x10\x00\x01\x00\x00\x00g\x00\x00\x04\xf2 \x10\x00\x02\x00\x00\x00\x01\x00\x00\x00h\x00\x00\x02\x04\x00\x00\x00\x00\x00\x00\b\x12\x00\x10\x00\x00\x00\x00\x00\n\x10\x10\x00\x01\x00\x00\x00\x1a\x80 \x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\aB\x00\x10\x00\x00\x00\x00\x00\n\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x80?\x1d\x00\x00\a\x12\x00\x10\x00\x00\x00\x00\x00\n\x10\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\xc0>\x00\x00\x00\a\"\x00\x10\x00\x00\x00\x00\x00\n\x10\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00\xbf6\x00\x00\x05B\x00\x10\x00\x01\x00\x00\x00\n\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\b2\x00\x10\x00\x02\x00\x00\x00F\x10\x10\x00\x02\x00\x00\x00F\x80 \x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\b\xc2\x00\x10\x00\x02\x00\x00\x00\x06\x14\x10\x00\x03\x00\x00\x00\x06\x84 \x00\x00\x00\x00\x00\x01\x00\x00\x003\x00\x00\a2\x00\x10\x00\x03\x00\x00\x00\xb6\x0f\x10\x00\x02\x00\x00\x00\x16\x05\x10\x00\x02\x00\x00\x00\x00\x00\x00\b\xc2\x00\x10\x00\x03\x00\x00\x00\x06\x14\x10\x00\x04\x00\x00\x00\x06\x84 \x00\x00\x00\x00\x00\x01\x00\x00\x003\x00\x00\a2\x00\x10\x00\x03\x00\x00\x00\xb6\x0f\x10\x00\x03\x00\x00\x00F\x00\x10\x00\x03\x00\x00\x00\x00\x00\x00\n2\x00\x10\x00\x01\x00\x00\x00F\x00\x10\x00\x03\x00\x00\x00\x02@\x00\x00\x00\x00\x80\xbf\x00\x00\x80\xbf\x00\x00\x00\x00\x00\x00\x00\x007\x00\x00\tb\x00\x10\x00\x00\x00\x00\x00\x06\x00\x10\x00\x00\x00\x00\x00V\x06\x10\x00\x00\x00\x00\x00\xa6\b\x10\x00\x01\x00\x00\x00\x1d\x00\x00\a\"\x00\x10\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00>4\x00\x00\a\x82\x00\x10\x00\x00\x00\x00\x00*\x00\x10\x00\x02\x00\x00\x00\n\x00\x10\x00\x02\x00\x00\x004\x00\x00\a\x82\x00\x10\x00\x00\x00\x00\x00*\x00\x10\x00\x03\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\a\x82\x00\x10\x00\x00\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x80?7\x00\x00\t\x12\x00\x10\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x00\x00\x00\x00:\x00\x10\x00\x00\x00\x00\x00\x1a\x00\x10\x00\x01\x00\x00\x00\x00\x00\x00\b\xf2 \x10\x00\x00\x00\x00\x00\x86\b\x10\x80A\x00\x00\x00\x00\x00\x00\x00F\x0e\x10\x00\x02\x00\x00\x00\x00\x00\x00\b2 \x10\x00\x01\x00\x00\x00\x86\x00\x10\x80A\x00\x00\x00\x00\x00\x00\x00\xe6\n\x10\x00\x03\x00\x00\x002\x00\x00\v2 \x10\x00\x02\x00\x00\x00\x86\x00\x10\x00\x00\x00\x00\x00F\x80 \x00\x00\x00\x00\x00\x00\x00\x00\x00\xe6\x8a \x00\x00\x00\x00\x00\x00\x00\x00\x006\x00\x00\b\xc2 \x10\x00\x02\x00\x00\x00\x02@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?>\x00\x00\x01STATt\x00\x00\x00\x16\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\t\x00\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00RDEF\xfc\x00\x00\x00\x01\x00\x00\x00D\x00\x00\x00\x01\x00\x00\x00\x1c\x00\x00\x00\x00\x04\xfe\xff\x00\x01\x00\x00\xd4\x00\x00\x00<\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00Block\x00\xab\xab<\x00\x00\x00\x02\x00\x00\x00\\\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8c\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00\x00\xa0\x00\x00\x00\x00\x00\x00\x00\xb0\x00\x00\x00\x10\x00\x00\x00\b\x00\x00\x00\x02\x00\x00\x00\xc4\x00\x00\x00\x00\x00\x00\x00_block_transform\x00\xab\xab\xab\x01\x00\x03\x00\x01\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00_block_pathOffset\x00\xab\xab\x01\x00\x03\x00\x01\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00Microsoft (R) HLSL Shader Compiler 10.1\x00ISGN\x8c\x00\x00\x00\x05\x00\x00\x00\b\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x01\x00\x00\x80\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x01\x01\x00\x00\x80\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00\x03\x03\x00\x00\x80\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x03\x00\x00\x00\x03\x03\x00\x00\x80\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x03\x03\x00\x00TEXCOORD\x00\xab\xab\xabOSGN\x80\x00\x00\x00\x04\x00\x00\x00\b\x00\x00\x00h\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\f\x00\x00h\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\f\x03\x00\x00h\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x03\f\x00\x00q\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00\x0f\x00\x00\x00TEXCOORD\x00SV_Position\x00\xab\xab\xab",
	}
	shader_tile_alloc_comp = driver.ShaderSources{
		Name: "tile_alloc.comp",
		GLSL310ES: `#version 310 es
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Alloc
{
    uint offset;
};

struct MallocResult
{
    Alloc alloc;
    bool failed;
};

struct AnnoEndClipRef
{
    uint offset;
};

struct AnnoEndClip
{
    vec4 bbox;
};

struct AnnotatedRef
{
    uint offset;
};

struct AnnotatedTag
{
    uint tag;
    uint flags;
};

struct PathRef
{
    uint offset;
};

struct TileRef
{
    uint offset;
};

struct Path
{
    uvec4 bbox;
    TileRef tiles;
};

struct Config
{
    uint n_elements;
    uint n_pathseg;
    uint width_in_tiles;
    uint height_in_tiles;
    Alloc tile_alloc;
    Alloc bin_alloc;
    Alloc ptcl_alloc;
    Alloc pathseg_alloc;
    Alloc anno_alloc;
    Alloc trans_alloc;
};

layout(binding = 0, std430) buffer Memory
{
    uint mem_offset;
    uint mem_error;
    uint memory[];
} _96;

layout(binding = 1, std430) readonly buffer ConfigBuf
{
    Config conf;
} _309;

shared uint sh_tile_count[128];
shared MallocResult sh_tile_alloc;

bool touch_mem(Alloc alloc, uint offset)
{
    return true;
}

uint read_mem(Alloc alloc, uint offset)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return 0u;
    }
    uint v = _96.memory[offset];
    return v;
}

AnnotatedTag Annotated_tag(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    uint param_1 = ref.offset >> uint(2);
    uint tag_and_flags = read_mem(param, param_1);
    return AnnotatedTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));
}

AnnoEndClip AnnoEndClip_read(Alloc a, AnnoEndClipRef ref)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint raw0 = read_mem(param, param_1);
    Alloc param_2 = a;
    uint param_3 = ix + 1u;
    uint raw1 = read_mem(param_2, param_3);
    Alloc param_4 = a;
    uint param_5 = ix + 2u;
    uint raw2 = read_mem(param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 3u;
    uint raw3 = read_mem(param_6, param_7);
    AnnoEndClip s;
    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));
    return s;
}

AnnoEndClip Annotated_EndClip_read(Alloc a, AnnotatedRef ref)
{
    Alloc param = a;
    AnnoEndClipRef param_1 = AnnoEndClipRef(ref.offset + 4u);
    return AnnoEndClip_read(param, param_1);
}

Alloc new_alloc(uint offset, uint size)
{
    Alloc a;
    a.offset = offset;
    return a;
}

MallocResult malloc(uint size)
{
    MallocResult r;
    r.failed = false;
    uint _102 = atomicAdd(_96.mem_offset, size);
    uint offset = _102;
    uint param = offset;
    uint param_1 = size;
    r.alloc = new_alloc(param, param_1);
    if ((offset + size) > uint(int(uint(_96.memory.length())) * 4))
    {
        r.failed = true;
        uint _123 = atomicMax(_96.mem_error, 1u);
        return r;
    }
    return r;
}

Alloc slice_mem(Alloc a, uint offset, uint size)
{
    uint param = a.offset + offset;
    uint param_1 = size;
    return new_alloc(param, param_1);
}

void write_mem(Alloc alloc, uint offset, uint val)
{
    Alloc param = alloc;
    uint param_1 = offset;
    if (!touch_mem(param, param_1))
    {
        return;
    }
    _96.memory[offset] = val;
}

void Path_write(Alloc a, PathRef ref, Path s)
{
    uint ix = ref.offset >> uint(2);
    Alloc param = a;
    uint param_1 = ix + 0u;
    uint param_2 = s.bbox.x | (s.bbox.y << uint(16));
    write_mem(param, param_1, param_2);
    Alloc param_3 = a;
    uint param_4 = ix + 1u;
    uint param_5 = s.bbox.z | (s.bbox.w << uint(16));
    write_mem(param_3, param_4, param_5);
    Alloc param_6 = a;
    uint param_7 = ix + 2u;
    uint param_8 = s.tiles.offset;
    write_mem(param_6, param_7, param_8);
}

void main()
{
    if (_96.mem_error != 0u)
    {
        return;
    }
    uint th_ix = gl_LocalInvocationID.x;
    uint element_ix = gl_GlobalInvocationID.x;
    PathRef path_ref = PathRef(_309.conf.tile_alloc.offset + (element_ix * 12u));
    AnnotatedRef ref = AnnotatedRef(_309.conf.anno_alloc.offset + (element_ix * 32u));
    uint tag = 0u;
    if (element_ix < _309.conf.n_elements)
    {
        Alloc param;
        param.offset = _309.conf.anno_alloc.offset;
        AnnotatedRef param_1 = ref;
        tag = Annotated_tag(param, param_1).tag;
    }
    int x0 = 0;
    int y0 = 0;
    int x1 = 0;
    int y1 = 0;
    switch (tag)
    {
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        {
            Alloc param_2;
            param_2.offset = _309.conf.anno_alloc.offset;
            AnnotatedRef param_3 = ref;
            AnnoEndClip clip = Annotated_EndClip_read(param_2, param_3);
            x0 = int(floor(clip.bbox.x * 0.03125));
            y0 = int(floor(clip.bbox.y * 0.03125));
            x1 = int(ceil(clip.bbox.z * 0.03125));
            y1 = int(ceil(clip.bbox.w * 0.03125));
            break;
        }
    }
    x0 = clamp(x0, 0, int(_309.conf.width_in_tiles));
    y0 = clamp(y0, 0, int(_309.conf.height_in_tiles));
    x1 = clamp(x1, 0, int(_309.conf.width_in_tiles));
    y1 = clamp(y1, 0, int(_309.conf.height_in_tiles));
    Path path;
    path.bbox = uvec4(uint(x0), uint(y0), uint(x1), uint(y1));
    uint tile_count = uint((x1 - x0) * (y1 - y0));
    if (tag == 4u)
    {
        tile_count = 0u;
    }
    sh_tile_count[th_ix] = tile_count;
    uint total_tile_count = tile_count;
    for (uint i = 0u; i < 7u; i++)
    {
        barrier();
        if (th_ix >= uint(1 << int(i)))
        {
            total_tile_count += sh_tile_count[th_ix - uint(1 << int(i))];
        }
        barrier();
        sh_tile_count[th_ix] = total_tile_count;
    }
    if (th_ix == 127u)
    {
        uint param_4 = total_tile_count * 8u;
        MallocResult _482 = malloc(param_4);
        sh_tile_alloc = _482;
    }
    barrier();
    MallocResult alloc_start = sh_tile_alloc;
    if (alloc_start.failed)
    {
        return;
    }
    if (element_ix < _309.conf.n_elements)
    {
        uint _499;
        if (th_ix > 0u)
        {
            _499 = sh_tile_count[th_ix - 1u];
        }
        else
        {
            _499 = 0u;
        }
        uint tile_subix = _499;
        Alloc param_5 = alloc_start.alloc;
        uint param_6 = 8u * tile_subix;
        uint param_7 = 8u * tile_count;
        Alloc tiles_alloc = slice_mem(param_5, param_6, param_7);
        path.tiles = TileRef(tiles_alloc.offset);
        Alloc param_8;
        param_8.offset = _309.conf.tile_alloc.offset;
        PathRef param_9 = path_ref;
        Path param_10 = path;
        Path_write(param_8, param_9, param_10);
    }
    uint total_count = sh_tile_count[127] * 2u;
    uint start_ix = alloc_start.alloc.offset >> uint(2);
    for (uint i_1 = th_ix; i_1 < total_count; i_1 += 128u)
    {
        Alloc param_11 = alloc_start.alloc;
        uint param_12 = start_ix + i_1;
        uint param_13 = 0u;
        write_mem(param_11, param_12, param_13);
    }
}

`,
	}
)
