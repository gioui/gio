// Code generated by build.go. DO NOT EDIT.

package gpu

import "gioui.org/gpu/backend"

var (
	shader_backdrop_comp = backend.ShaderSources{
		Name:      "backdrop.comp",
		GLSL310ES: "#version 310 es\r\nlayout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;\r\n\r\nstruct Alloc\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnotatedRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct PathRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct TileRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Path\r\n{\r\n    uvec4 bbox;\r\n    TileRef tiles;\r\n};\r\n\r\nstruct Config\r\n{\r\n    uint n_elements;\r\n    uint n_pathseg;\r\n    uint width_in_tiles;\r\n    uint height_in_tiles;\r\n    Alloc tile_alloc;\r\n    Alloc bin_alloc;\r\n    Alloc ptcl_alloc;\r\n    Alloc pathseg_alloc;\r\n    Alloc anno_alloc;\r\n};\r\n\r\nlayout(binding = 0, std430) buffer Memory\r\n{\r\n    uint mem_offset;\r\n    uint mem_error;\r\n    uint memory[];\r\n} _72;\r\n\r\nlayout(binding = 1, std430) readonly buffer ConfigBuf\r\n{\r\n    Config conf;\r\n} _176;\r\n\r\nshared uint sh_row_width[128];\r\nshared Alloc sh_row_alloc[128];\r\nshared uint sh_row_count[128];\r\n\r\nbool touch_mem(Alloc alloc, uint offset)\r\n{\r\n    return true;\r\n}\r\n\r\nuint read_mem(Alloc alloc, uint offset)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return 0u;\r\n    }\r\n    uint v = _72.memory[offset];\r\n    return v;\r\n}\r\n\r\nuint Annotated_tag(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    return read_mem(param, param_1);\r\n}\r\n\r\nPath Path_read(Alloc a, PathRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Path s;\r\n    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));\r\n    s.tiles = TileRef(raw2);\r\n    return s;\r\n}\r\n\r\nAlloc new_alloc(uint offset, uint size)\r\n{\r\n    Alloc a;\r\n    a.offset = offset;\r\n    return a;\r\n}\r\n\r\nvoid write_mem(Alloc alloc, uint offset, uint val)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return;\r\n    }\r\n    _72.memory[offset] = val;\r\n}\r\n\r\nvoid main()\r\n{\r\n    if (_72.mem_error != 0u)\r\n    {\r\n        return;\r\n    }\r\n    uint th_ix = gl_LocalInvocationID.x;\r\n    uint element_ix = gl_GlobalInvocationID.x;\r\n    AnnotatedRef ref = AnnotatedRef(_176.conf.anno_alloc.offset + (element_ix * 52u));\r\n    uint row_count = 0u;\r\n    if (element_ix < _176.conf.n_elements)\r\n    {\r\n        Alloc param;\r\n        param.offset = _176.conf.anno_alloc.offset;\r\n        AnnotatedRef param_1 = ref;\r\n        uint tag = Annotated_tag(param, param_1);\r\n        switch (tag)\r\n        {\r\n            case 2u:\r\n            case 3u:\r\n            case 4u:\r\n            {\r\n                PathRef path_ref = PathRef(_176.conf.tile_alloc.offset + (element_ix * 12u));\r\n                Alloc param_2;\r\n                param_2.offset = _176.conf.tile_alloc.offset;\r\n                PathRef param_3 = path_ref;\r\n                Path path = Path_read(param_2, param_3);\r\n                sh_row_width[th_ix] = path.bbox.z - path.bbox.x;\r\n                row_count = path.bbox.w - path.bbox.y;\r\n                bool _242 = row_count == 1u;\r\n                bool _248;\r\n                if (_242)\r\n                {\r\n                    _248 = path.bbox.y > 0u;\r\n                }\r\n                else\r\n                {\r\n                    _248 = _242;\r\n                }\r\n                if (_248)\r\n                {\r\n                    row_count = 0u;\r\n                }\r\n                uint param_4 = path.tiles.offset;\r\n                uint param_5 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;\r\n                Alloc path_alloc = new_alloc(param_4, param_5);\r\n                sh_row_alloc[th_ix] = path_alloc;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    sh_row_count[th_ix] = row_count;\r\n    for (uint i = 0u; i < 7u; i++)\r\n    {\r\n        barrier();\r\n        if (th_ix >= uint(1 << int(i)))\r\n        {\r\n            row_count += sh_row_count[th_ix - uint(1 << int(i))];\r\n        }\r\n        barrier();\r\n        sh_row_count[th_ix] = row_count;\r\n    }\r\n    barrier();\r\n    uint total_rows = sh_row_count[127];\r\n    uint _370;\r\n    for (uint row = th_ix; row < total_rows; row += 128u)\r\n    {\r\n        uint el_ix = 0u;\r\n        for (uint i_1 = 0u; i_1 < 7u; i_1++)\r\n        {\r\n            uint probe = el_ix + uint(64 >> int(i_1));\r\n            if (row >= sh_row_count[probe - 1u])\r\n            {\r\n                el_ix = probe;\r\n            }\r\n        }\r\n        uint width = sh_row_width[el_ix];\r\n        if (width > 0u)\r\n        {\r\n            Alloc tiles_alloc = sh_row_alloc[el_ix];\r\n            if (el_ix > 0u)\r\n            {\r\n                _370 = sh_row_count[el_ix - 1u];\r\n            }\r\n            else\r\n            {\r\n                _370 = 0u;\r\n            }\r\n            uint seq_ix = row - _370;\r\n            uint tile_el_ix = ((tiles_alloc.offset >> uint(2)) + 1u) + ((seq_ix * 2u) * width);\r\n            Alloc param_6 = tiles_alloc;\r\n            uint param_7 = tile_el_ix;\r\n            uint sum = read_mem(param_6, param_7);\r\n            for (uint x = 1u; x < width; x++)\r\n            {\r\n                tile_el_ix += 2u;\r\n                Alloc param_8 = tiles_alloc;\r\n                uint param_9 = tile_el_ix;\r\n                sum += read_mem(param_8, param_9);\r\n                Alloc param_10 = tiles_alloc;\r\n                uint param_11 = tile_el_ix;\r\n                uint param_12 = sum;\r\n                write_mem(param_10, param_11, param_12);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n",
	}
	shader_binning_comp = backend.ShaderSources{
		Name:      "binning.comp",
		GLSL310ES: "#version 310 es\r\nlayout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;\r\n\r\nstruct Alloc\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct MallocResult\r\n{\r\n    Alloc alloc;\r\n    bool failed;\r\n};\r\n\r\nstruct AnnoFillRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoFill\r\n{\r\n    vec4 bbox;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct AnnotatedRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct BinInstanceRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct BinInstance\r\n{\r\n    uint element_ix;\r\n};\r\n\r\nstruct Config\r\n{\r\n    uint n_elements;\r\n    uint n_pathseg;\r\n    uint width_in_tiles;\r\n    uint height_in_tiles;\r\n    Alloc tile_alloc;\r\n    Alloc bin_alloc;\r\n    Alloc ptcl_alloc;\r\n    Alloc pathseg_alloc;\r\n    Alloc anno_alloc;\r\n};\r\n\r\nlayout(binding = 0, std430) buffer Memory\r\n{\r\n    uint mem_offset;\r\n    uint mem_error;\r\n    uint memory[];\r\n} _87;\r\n\r\nlayout(binding = 1, std430) readonly buffer ConfigBuf\r\n{\r\n    Config conf;\r\n} _254;\r\n\r\nshared uint bitmaps[4][128];\r\nshared bool sh_alloc_failed;\r\nshared uint count[4][128];\r\nshared Alloc sh_chunk_alloc[128];\r\n\r\nbool touch_mem(Alloc alloc, uint offset)\r\n{\r\n    return true;\r\n}\r\n\r\nuint read_mem(Alloc alloc, uint offset)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return 0u;\r\n    }\r\n    uint v = _87.memory[offset];\r\n    return v;\r\n}\r\n\r\nuint Annotated_tag(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    return read_mem(param, param_1);\r\n}\r\n\r\nAnnoFill AnnoFill_read(Alloc a, AnnoFillRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    AnnoFill s;\r\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.rgba_color = raw4;\r\n    return s;\r\n}\r\n\r\nAnnoFill Annotated_Fill_read(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    AnnoFillRef param_1 = AnnoFillRef(ref.offset + 4u);\r\n    return AnnoFill_read(param, param_1);\r\n}\r\n\r\nAlloc new_alloc(uint offset, uint size)\r\n{\r\n    Alloc a;\r\n    a.offset = offset;\r\n    return a;\r\n}\r\n\r\nMallocResult malloc(uint size)\r\n{\r\n    MallocResult r;\r\n    r.failed = false;\r\n    uint _93 = atomicAdd(_87.mem_offset, size);\r\n    uint offset = _93;\r\n    uint param = offset;\r\n    uint param_1 = size;\r\n    r.alloc = new_alloc(param, param_1);\r\n    if ((offset + size) > uint(int(uint(_87.memory.length())) * 4))\r\n    {\r\n        r.failed = true;\r\n        uint _114 = atomicMax(_87.mem_error, 1u);\r\n        return r;\r\n    }\r\n    return r;\r\n}\r\n\r\nvoid write_mem(Alloc alloc, uint offset, uint val)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return;\r\n    }\r\n    _87.memory[offset] = val;\r\n}\r\n\r\nvoid BinInstance_write(Alloc a, BinInstanceRef ref, BinInstance s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = s.element_ix;\r\n    write_mem(param, param_1, param_2);\r\n}\r\n\r\nvoid main()\r\n{\r\n    if (_87.mem_error != 0u)\r\n    {\r\n        return;\r\n    }\r\n    uint my_n_elements = _254.conf.n_elements;\r\n    uint my_partition = gl_WorkGroupID.x;\r\n    for (uint i = 0u; i < 4u; i++)\r\n    {\r\n        bitmaps[i][gl_LocalInvocationID.x] = 0u;\r\n    }\r\n    if (gl_LocalInvocationID.x == 0u)\r\n    {\r\n        sh_alloc_failed = false;\r\n    }\r\n    barrier();\r\n    uint element_ix = (my_partition * 128u) + gl_LocalInvocationID.x;\r\n    AnnotatedRef ref = AnnotatedRef(_254.conf.anno_alloc.offset + (element_ix * 52u));\r\n    uint tag = 0u;\r\n    if (element_ix < my_n_elements)\r\n    {\r\n        Alloc param;\r\n        param.offset = _254.conf.anno_alloc.offset;\r\n        AnnotatedRef param_1 = ref;\r\n        tag = Annotated_tag(param, param_1);\r\n    }\r\n    int x0 = 0;\r\n    int y0 = 0;\r\n    int x1 = 0;\r\n    int y1 = 0;\r\n    switch (tag)\r\n    {\r\n        case 2u:\r\n        case 3u:\r\n        case 1u:\r\n        case 4u:\r\n        case 5u:\r\n        {\r\n            Alloc param_2;\r\n            param_2.offset = _254.conf.anno_alloc.offset;\r\n            AnnotatedRef param_3 = ref;\r\n            AnnoFill fill = Annotated_Fill_read(param_2, param_3);\r\n            x0 = int(floor(fill.bbox.x * 0.001953125));\r\n            y0 = int(floor(fill.bbox.y * 0.00390625));\r\n            x1 = int(ceil(fill.bbox.z * 0.001953125));\r\n            y1 = int(ceil(fill.bbox.w * 0.00390625));\r\n            break;\r\n        }\r\n    }\r\n    uint width_in_bins = ((_254.conf.width_in_tiles + 16u) - 1u) / 16u;\r\n    uint height_in_bins = ((_254.conf.height_in_tiles + 8u) - 1u) / 8u;\r\n    x0 = clamp(x0, 0, int(width_in_bins));\r\n    x1 = clamp(x1, x0, int(width_in_bins));\r\n    y0 = clamp(y0, 0, int(height_in_bins));\r\n    y1 = clamp(y1, y0, int(height_in_bins));\r\n    if (x0 == x1)\r\n    {\r\n        y1 = y0;\r\n    }\r\n    int x = x0;\r\n    int y = y0;\r\n    uint my_slice = gl_LocalInvocationID.x / 32u;\r\n    uint my_mask = uint(1 << int(gl_LocalInvocationID.x & 31u));\r\n    while (y < y1)\r\n    {\r\n        uint _438 = atomicOr(bitmaps[my_slice][(uint(y) * width_in_bins) + uint(x)], my_mask);\r\n        x++;\r\n        if (x == x1)\r\n        {\r\n            x = x0;\r\n            y++;\r\n        }\r\n    }\r\n    barrier();\r\n    uint element_count = 0u;\r\n    for (uint i_1 = 0u; i_1 < 4u; i_1++)\r\n    {\r\n        element_count += uint(bitCount(bitmaps[i_1][gl_LocalInvocationID.x]));\r\n        count[i_1][gl_LocalInvocationID.x] = element_count;\r\n    }\r\n    uint param_4 = 0u;\r\n    uint param_5 = 0u;\r\n    Alloc chunk_alloc = new_alloc(param_4, param_5);\r\n    if (element_count != 0u)\r\n    {\r\n        uint param_6 = element_count * 4u;\r\n        MallocResult _487 = malloc(param_6);\r\n        MallocResult chunk = _487;\r\n        chunk_alloc = chunk.alloc;\r\n        sh_chunk_alloc[gl_LocalInvocationID.x] = chunk_alloc;\r\n        if (chunk.failed)\r\n        {\r\n            sh_alloc_failed = true;\r\n        }\r\n    }\r\n    uint out_ix = (_254.conf.bin_alloc.offset >> uint(2)) + (((my_partition * 128u) + gl_LocalInvocationID.x) * 2u);\r\n    Alloc param_7;\r\n    param_7.offset = _254.conf.bin_alloc.offset;\r\n    uint param_8 = out_ix;\r\n    uint param_9 = element_count;\r\n    write_mem(param_7, param_8, param_9);\r\n    Alloc param_10;\r\n    param_10.offset = _254.conf.bin_alloc.offset;\r\n    uint param_11 = out_ix + 1u;\r\n    uint param_12 = chunk_alloc.offset;\r\n    write_mem(param_10, param_11, param_12);\r\n    barrier();\r\n    if (sh_alloc_failed)\r\n    {\r\n        return;\r\n    }\r\n    x = x0;\r\n    y = y0;\r\n    while (y < y1)\r\n    {\r\n        uint bin_ix = (uint(y) * width_in_bins) + uint(x);\r\n        uint out_mask = bitmaps[my_slice][bin_ix];\r\n        if ((out_mask & my_mask) != 0u)\r\n        {\r\n            uint idx = uint(bitCount(out_mask & (my_mask - 1u)));\r\n            if (my_slice > 0u)\r\n            {\r\n                idx += count[my_slice - 1u][bin_ix];\r\n            }\r\n            Alloc out_alloc = sh_chunk_alloc[bin_ix];\r\n            uint out_offset = out_alloc.offset + (idx * 4u);\r\n            Alloc param_13 = out_alloc;\r\n            BinInstanceRef param_14 = BinInstanceRef(out_offset);\r\n            BinInstance param_15 = BinInstance(element_ix);\r\n            BinInstance_write(param_13, param_14, param_15);\r\n        }\r\n        x++;\r\n        if (x == x1)\r\n        {\r\n            x = x0;\r\n            y++;\r\n        }\r\n    }\r\n}\r\n\r\n",
	}
	shader_blit_frag = [...]backend.ShaderSources{
		{
			Name: "blit.frag",
			Uniforms: backend.UniformsReflection{
				Blocks:    []backend.UniformBlock{{Name: "Color", Binding: 0}},
				Locations: []backend.UniformLocation{{Name: "_12._color", Type: 0x0, Size: 4, Offset: 0}},
				Size:      16,
			},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nvarying vec2 vUV;\n\nvoid main()\n{\n    gl_FragData[0] = _12._color;\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nlayout(std140) uniform Color\n{\n    vec4 _color;\n} _12;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n}\n\n",
			GLSL130:   "#version 130\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n}\n\n",
			GLSL150:   "#version 150\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n}\n\n",
			/*
			   cbuffer Color : register(b0)
			   {
			       float4 _12_color : packoffset(c0);
			   };


			   static float4 fragColor;
			   static float2 vUV;

			   struct SPIRV_Cross_Input
			   {
			       float2 vUV : TEXCOORD0;
			   };

			   struct SPIRV_Cross_Output
			   {
			       float4 fragColor : SV_Target0;
			   };

			   void frag_main()
			   {
			       fragColor = _12_color;
			   }

			   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
			   {
			       vUV = stage_input.vUV;
			       frag_main();
			       SPIRV_Cross_Output stage_output;
			       stage_output.fragColor = fragColor;
			       return stage_output;
			   }

			*/
			HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0xc6, 0x4a, 0x23, 0x81, 0x87, 0xab, 0xe3, 0xca, 0x12, 0x9, 0x7e, 0x2f, 0x5e, 0x2, 0x62, 0x14, 0x1, 0x0, 0x0, 0x0, 0x70, 0x2, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x84, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x48, 0x1, 0x0, 0x0, 0x8, 0x2, 0x0, 0x0, 0x3c, 0x2, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x44, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x14, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x40, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x6, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xb8, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
		{
			Name: "blit.frag",
			Uniforms: backend.UniformsReflection{
				Blocks:    []backend.UniformBlock{{Name: "Gradient", Binding: 0}},
				Locations: []backend.UniformLocation{{Name: "_12._color1", Type: 0x0, Size: 4, Offset: 0}, {Name: "_12._color2", Type: 0x0, Size: 4, Offset: 16}},
				Size:      32,
			},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nvarying vec2 vUV;\n\nvoid main()\n{\n    gl_FragData[0] = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nlayout(std140) uniform Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n} _12;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n}\n\n",
			GLSL130:   "#version 130\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n}\n\n",
			GLSL150:   "#version 150\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n}\n\n",
			/*
			   cbuffer Gradient : register(b0)
			   {
			       float4 _12_color1 : packoffset(c0);
			       float4 _12_color2 : packoffset(c1);
			   };


			   static float4 fragColor;
			   static float2 vUV;

			   struct SPIRV_Cross_Input
			   {
			       float2 vUV : TEXCOORD0;
			   };

			   struct SPIRV_Cross_Output
			   {
			       float4 fragColor : SV_Target0;
			   };

			   void frag_main()
			   {
			       fragColor = lerp(_12_color1, _12_color2, clamp(vUV.x, 0.0f, 1.0f).xxxx);
			   }

			   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
			   {
			       vUV = stage_input.vUV;
			       frag_main();
			       SPIRV_Cross_Output stage_output;
			       stage_output.fragColor = fragColor;
			       return stage_output;
			   }

			*/
			HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0xc0, 0x43, 0x72, 0x3d, 0x68, 0xc9, 0x38, 0x57, 0x9f, 0xa3, 0x60, 0xa8, 0xae, 0xd2, 0xa2, 0xf0, 0x1, 0x0, 0x0, 0x0, 0x40, 0x3, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x74, 0x1, 0x0, 0x0, 0xf0, 0x1, 0x0, 0x0, 0xd8, 0x2, 0x0, 0x0, 0xc, 0x3, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x8c, 0x0, 0x0, 0x0, 0x8c, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x5c, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x3, 0xb0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x18, 0x80, 0x0, 0x0, 0x0, 0xb0, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0xf, 0x80, 0x1, 0x0, 0xe4, 0x81, 0x1, 0x0, 0xe4, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xff, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0xa0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x12, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x36, 0x20, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xe0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x48, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0xb7, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x47, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x0, 0xab, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xac, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x31, 0x0, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x32, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x1, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
		{
			Name:      "blit.frag",
			Textures:  []backend.TextureBinding{{Name: "tex", Binding: 0}},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\n\nvarying vec2 vUV;\n\nvoid main()\n{\n    gl_FragData[0] = texture2D(tex, vUV);\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n}\n\n",
			GLSL130:   "#version 130\n\nuniform sampler2D tex;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n}\n\n",
			GLSL150:   "#version 150\n\nuniform sampler2D tex;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n}\n\n",
			/*
			   Texture2D<float4> tex : register(t0);
			   SamplerState _tex_sampler : register(s0);

			   static float4 fragColor;
			   static float2 vUV;

			   struct SPIRV_Cross_Input
			   {
			       float2 vUV : TEXCOORD0;
			   };

			   struct SPIRV_Cross_Output
			   {
			       float4 fragColor : SV_Target0;
			   };

			   void frag_main()
			   {
			       fragColor = tex.Sample(_tex_sampler, vUV);
			   }

			   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
			   {
			       vUV = stage_input.vUV;
			       frag_main();
			       SPIRV_Cross_Output stage_output;
			       stage_output.fragColor = fragColor;
			       return stage_output;
			   }

			*/
			HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0xb7, 0x3f, 0x1d, 0xb1, 0x80, 0xcd, 0x80, 0xa3, 0x57, 0x9, 0xfb, 0x5a, 0x9f, 0x56, 0xd6, 0xda, 0x1, 0x0, 0x0, 0x0, 0x94, 0x2, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xa4, 0x0, 0x0, 0x0, 0x10, 0x1, 0x0, 0x0, 0x8c, 0x1, 0x0, 0x0, 0x2c, 0x2, 0x0, 0x0, 0x60, 0x2, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x64, 0x0, 0x0, 0x0, 0x64, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x3c, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x3, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x64, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x98, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x6d, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x69, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x5f, 0x74, 0x65, 0x78, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x74, 0x65, 0x78, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
	}
	shader_blit_vert = backend.ShaderSources{
		Name:   "blit.vert",
		Inputs: []backend.InputLocation{{Name: "pos", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 2}},
		Uniforms: backend.UniformsReflection{
			Blocks:    []backend.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []backend.UniformLocation{{Name: "_52.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_52.uvTransformR1", Type: 0x0, Size: 4, Offset: 16}, {Name: "_52.uvTransformR2", Type: 0x0, Size: 4, Offset: 32}, {Name: "_52.z", Type: 0x0, Size: 1, Offset: 48}},
			Size:      52,
		},
		GLSL100ES: "\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _52;\n\nattribute vec2 pos;\nvarying vec2 vUV;\nattribute vec2 uv;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec2 p = (pos * _52.transform.xy) + _52.transform.zw;\n    vec4 param = vec4(p, _52.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_52.uvTransformR1.xyz, _52.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n}\n\n",
		GLSL300ES: "#version 300 es\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nlayout(std140) uniform Block\n{\n    vec4 transform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n} _52;\n\nlayout(location = 0) in vec2 pos;\nout vec2 vUV;\nlayout(location = 1) in vec2 uv;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec2 p = (pos * _52.transform.xy) + _52.transform.zw;\n    vec4 param = vec4(p, _52.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_52.uvTransformR1.xyz, _52.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n}\n\n",
		GLSL130:   "#version 130\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _52;\n\nin vec2 pos;\nout vec2 vUV;\nin vec2 uv;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec2 p = (pos * _52.transform.xy) + _52.transform.zw;\n    vec4 param = vec4(p, _52.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_52.uvTransformR1.xyz, _52.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n}\n\n",
		GLSL150:   "#version 150\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _52;\n\nin vec2 pos;\nout vec2 vUV;\nin vec2 uv;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec2 p = (pos * _52.transform.xy) + _52.transform.zw;\n    vec4 param = vec4(p, _52.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_52.uvTransformR1.xyz, _52.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n}\n\n",
		/*
		   struct m3x2
		   {
		       float3 r0;
		       float3 r1;
		   };

		   static const m3x2 _116 = { float3(1.0f, 0.0f, 0.0f), float3(0.0f, -1.0f, 1.0f) };
		   static const m3x2 _118 = { float3(1.0f, 0.0f, 0.0f), float3(0.0f, 1.0f, 0.0f) };

		   cbuffer Block : register(b0)
		   {
		       float4 _69_transform : packoffset(c0);
		       float4 _69_uvTransformR1 : packoffset(c1);
		       float4 _69_uvTransformR2 : packoffset(c2);
		       float _69_z : packoffset(c3);
		   };


		   static float4 gl_Position;
		   static float2 pos;
		   static float2 vUV;
		   static float2 uv;

		   struct SPIRV_Cross_Input
		   {
		       float2 pos : POSITION;
		       float2 uv : NORMAL;
		   };

		   struct SPIRV_Cross_Output
		   {
		       float2 vUV : TEXCOORD0;
		       float4 gl_Position : SV_Position;
		   };

		   float4 toClipSpace(float4 pos_1)
		   {
		       return float4(pos_1.xy, (pos_1.z + pos_1.w) * 0.5f, pos_1.w);
		   }

		   float3 transform3x2(m3x2 t, float3 v)
		   {
		       return float3(dot(t.r0, v), dot(t.r1, v), dot(float3(0.0f, 0.0f, 1.0f), v));
		   }

		   void vert_main()
		   {
		       float2 p = (pos * _69_transform.xy) + _69_transform.zw;
		       float4 param = float4(p, _69_z, 1.0f);
		       gl_Position = toClipSpace(param);
		       m3x2 _103 = { _69_uvTransformR1.xyz, _69_uvTransformR2.xyz };
		       m3x2 param_1 = _103;
		       float3 param_2 = float3(uv, 1.0f);
		       vUV = transform3x2(param_1, param_2).xy;
		   }

		   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
		   {
		       pos = stage_input.pos;
		       uv = stage_input.uv;
		       vert_main();
		       SPIRV_Cross_Output stage_output;
		       stage_output.gl_Position = gl_Position;
		       stage_output.vUV = vUV;
		       return stage_output;
		   }

		*/
		HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0x57, 0x0, 0x34, 0xa, 0xf6, 0x3b, 0x1b, 0xc4, 0x28, 0xa1, 0x26, 0x75, 0x95, 0x95, 0xc4, 0x27, 0x1, 0x0, 0x0, 0x0, 0xc0, 0x4, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x24, 0x1, 0x0, 0x0, 0x54, 0x2, 0x0, 0x0, 0xd0, 0x2, 0x0, 0x0, 0x18, 0x4, 0x0, 0x0, 0x68, 0x4, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xe4, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0xb0, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x5, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x7, 0x80, 0x1, 0x0, 0xc4, 0x90, 0x5, 0x0, 0xd0, 0xa0, 0x5, 0x0, 0xc5, 0xa0, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0xe0, 0x2, 0x0, 0xe4, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0xe0, 0x3, 0x0, 0xe4, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x90, 0x1, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0xee, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x7, 0x80, 0x5, 0x0, 0xe4, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0xc, 0xc0, 0x4, 0x0, 0x0, 0xa0, 0x0, 0x0, 0x64, 0x80, 0x0, 0x0, 0x24, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x28, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x4a, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x10, 0x0, 0x0, 0x8, 0x12, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x82, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x8, 0x22, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x82, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0x42, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x36, 0x0, 0x0, 0x5, 0x82, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x40, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0x18, 0x1, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xdc, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x36, 0x39, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x36, 0x39, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x52, 0x31, 0x0, 0x5f, 0x36, 0x39, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x52, 0x32, 0x0, 0x5f, 0x36, 0x39, 0x5f, 0x7a, 0x0, 0xab, 0xab, 0x0, 0x0, 0x3, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x48, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x50, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_coarse_comp = backend.ShaderSources{
		Name:      "coarse.comp",
		GLSL310ES: "#version 310 es\r\nlayout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;\r\n\r\nstruct Alloc\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct MallocResult\r\n{\r\n    Alloc alloc;\r\n    bool failed;\r\n};\r\n\r\nstruct AnnoFillRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoFill\r\n{\r\n    vec4 bbox;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct AnnoFillTextureRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoFillTexture\r\n{\r\n    vec4 bbox;\r\n    vec4 mat;\r\n    vec2 translate;\r\n    uvec2 uv_bounds;\r\n};\r\n\r\nstruct AnnoStrokeRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoStroke\r\n{\r\n    vec4 bbox;\r\n    uint rgba_color;\r\n    float linewidth;\r\n};\r\n\r\nstruct AnnotatedRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct BinInstanceRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct BinInstance\r\n{\r\n    uint element_ix;\r\n};\r\n\r\nstruct PathRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct TileRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Path\r\n{\r\n    uvec4 bbox;\r\n    TileRef tiles;\r\n};\r\n\r\nstruct TileSegRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Tile\r\n{\r\n    TileSegRef tile;\r\n    int backdrop;\r\n};\r\n\r\nstruct CmdStrokeRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdStroke\r\n{\r\n    uint tile_ref;\r\n    float half_width;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct CmdFillRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdFill\r\n{\r\n    uint tile_ref;\r\n    int backdrop;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct CmdFillTextureRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdFillTexture\r\n{\r\n    uint tile_ref;\r\n    int backdrop;\r\n    vec4 mat;\r\n    vec2 translate;\r\n    uvec2 uv_bounds;\r\n};\r\n\r\nstruct CmdBeginClipRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdBeginClip\r\n{\r\n    uint tile_ref;\r\n    int backdrop;\r\n};\r\n\r\nstruct CmdBeginSolidClipRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdBeginSolidClip\r\n{\r\n    float alpha;\r\n};\r\n\r\nstruct CmdEndClipRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdEndClip\r\n{\r\n    float alpha;\r\n};\r\n\r\nstruct CmdSolidRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdSolid\r\n{\r\n    uint rgba_color;\r\n};\r\n\r\nstruct CmdSolidTextureRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdSolidTexture\r\n{\r\n    vec4 mat;\r\n    vec2 translate;\r\n    uvec2 uv_bounds;\r\n};\r\n\r\nstruct CmdJumpRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdJump\r\n{\r\n    uint new_ref;\r\n};\r\n\r\nstruct CmdRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Config\r\n{\r\n    uint n_elements;\r\n    uint n_pathseg;\r\n    uint width_in_tiles;\r\n    uint height_in_tiles;\r\n    Alloc tile_alloc;\r\n    Alloc bin_alloc;\r\n    Alloc ptcl_alloc;\r\n    Alloc pathseg_alloc;\r\n    Alloc anno_alloc;\r\n};\r\n\r\nlayout(binding = 0, std430) buffer Memory\r\n{\r\n    uint mem_offset;\r\n    uint mem_error;\r\n    uint memory[];\r\n} _308;\r\n\r\nlayout(binding = 1, std430) readonly buffer ConfigBuf\r\n{\r\n    Config conf;\r\n} _1338;\r\n\r\nshared uint sh_bitmaps[4][128];\r\nshared Alloc sh_part_elements[128];\r\nshared uint sh_part_count[128];\r\nshared uint sh_elements[128];\r\nshared uint sh_tile_stride[128];\r\nshared uint sh_tile_width[128];\r\nshared uint sh_tile_x0[128];\r\nshared uint sh_tile_y0[128];\r\nshared uint sh_tile_base[128];\r\nshared uint sh_tile_count[128];\r\n\r\nAlloc new_alloc(uint offset, uint size)\r\n{\r\n    Alloc a;\r\n    a.offset = offset;\r\n    return a;\r\n}\r\n\r\nAlloc slice_mem(Alloc a, uint offset, uint size)\r\n{\r\n    uint param = a.offset + offset;\r\n    uint param_1 = size;\r\n    return new_alloc(param, param_1);\r\n}\r\n\r\nbool touch_mem(Alloc alloc, uint offset)\r\n{\r\n    return true;\r\n}\r\n\r\nuint read_mem(Alloc alloc, uint offset)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return 0u;\r\n    }\r\n    uint v = _308.memory[offset];\r\n    return v;\r\n}\r\n\r\nBinInstanceRef BinInstance_index(BinInstanceRef ref, uint index)\r\n{\r\n    return BinInstanceRef(ref.offset + (index * 4u));\r\n}\r\n\r\nBinInstance BinInstance_read(Alloc a, BinInstanceRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    BinInstance s;\r\n    s.element_ix = raw0;\r\n    return s;\r\n}\r\n\r\nuint Annotated_tag(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    return read_mem(param, param_1);\r\n}\r\n\r\nPath Path_read(Alloc a, PathRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Path s;\r\n    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));\r\n    s.tiles = TileRef(raw2);\r\n    return s;\r\n}\r\n\r\nvoid write_tile_alloc(uint el_ix, Alloc a)\r\n{\r\n}\r\n\r\nAlloc read_tile_alloc(uint el_ix)\r\n{\r\n    uint param = 0u;\r\n    uint param_1 = uint(int(uint(_308.memory.length())) * 4);\r\n    return new_alloc(param, param_1);\r\n}\r\n\r\nTile Tile_read(Alloc a, TileRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Tile s;\r\n    s.tile = TileSegRef(raw0);\r\n    s.backdrop = int(raw1);\r\n    return s;\r\n}\r\n\r\nAnnoFill AnnoFill_read(Alloc a, AnnoFillRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    AnnoFill s;\r\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.rgba_color = raw4;\r\n    return s;\r\n}\r\n\r\nAnnoFill Annotated_Fill_read(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    AnnoFillRef param_1 = AnnoFillRef(ref.offset + 4u);\r\n    return AnnoFill_read(param, param_1);\r\n}\r\n\r\nMallocResult malloc(uint size)\r\n{\r\n    MallocResult r;\r\n    r.failed = false;\r\n    uint _314 = atomicAdd(_308.mem_offset, size);\r\n    uint offset = _314;\r\n    uint param = offset;\r\n    uint param_1 = size;\r\n    r.alloc = new_alloc(param, param_1);\r\n    if ((offset + size) > uint(int(uint(_308.memory.length())) * 4))\r\n    {\r\n        r.failed = true;\r\n        uint _335 = atomicMax(_308.mem_error, 1u);\r\n        return r;\r\n    }\r\n    return r;\r\n}\r\n\r\nvoid write_mem(Alloc alloc, uint offset, uint val)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return;\r\n    }\r\n    _308.memory[offset] = val;\r\n}\r\n\r\nvoid CmdJump_write(Alloc a, CmdJumpRef ref, CmdJump s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = s.new_ref;\r\n    write_mem(param, param_1, param_2);\r\n}\r\n\r\nvoid Cmd_Jump_write(Alloc a, CmdRef ref, CmdJump s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 12u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdJumpRef param_4 = CmdJumpRef(ref.offset + 4u);\r\n    CmdJump param_5 = s;\r\n    CmdJump_write(param_3, param_4, param_5);\r\n}\r\n\r\nbool alloc_cmd(inout Alloc cmd_alloc, inout CmdRef cmd_ref, inout uint cmd_limit)\r\n{\r\n    if (cmd_ref.offset < cmd_limit)\r\n    {\r\n        return true;\r\n    }\r\n    uint param = 1024u;\r\n    MallocResult _1298 = malloc(param);\r\n    MallocResult new_cmd = _1298;\r\n    if (new_cmd.failed)\r\n    {\r\n        return false;\r\n    }\r\n    CmdJump jump = CmdJump(new_cmd.alloc.offset);\r\n    Alloc param_1 = cmd_alloc;\r\n    CmdRef param_2 = cmd_ref;\r\n    CmdJump param_3 = jump;\r\n    Cmd_Jump_write(param_1, param_2, param_3);\r\n    cmd_alloc = new_cmd.alloc;\r\n    cmd_ref = CmdRef(cmd_alloc.offset);\r\n    cmd_limit = (cmd_alloc.offset + 1024u) - 88u;\r\n    return true;\r\n}\r\n\r\nvoid CmdFill_write(Alloc a, CmdFillRef ref, CmdFill s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = s.tile_ref;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = uint(s.backdrop);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = s.rgba_color;\r\n    write_mem(param_6, param_7, param_8);\r\n}\r\n\r\nvoid Cmd_Fill_write(Alloc a, CmdRef ref, CmdFill s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 3u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdFillRef param_4 = CmdFillRef(ref.offset + 4u);\r\n    CmdFill param_5 = s;\r\n    CmdFill_write(param_3, param_4, param_5);\r\n}\r\n\r\nvoid CmdSolid_write(Alloc a, CmdSolidRef ref, CmdSolid s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = s.rgba_color;\r\n    write_mem(param, param_1, param_2);\r\n}\r\n\r\nvoid Cmd_Solid_write(Alloc a, CmdRef ref, CmdSolid s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 9u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdSolidRef param_4 = CmdSolidRef(ref.offset + 4u);\r\n    CmdSolid param_5 = s;\r\n    CmdSolid_write(param_3, param_4, param_5);\r\n}\r\n\r\nAnnoFillTexture AnnoFillTexture_read(Alloc a, AnnoFillTextureRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    Alloc param_10 = a;\r\n    uint param_11 = ix + 5u;\r\n    uint raw5 = read_mem(param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 6u;\r\n    uint raw6 = read_mem(param_12, param_13);\r\n    Alloc param_14 = a;\r\n    uint param_15 = ix + 7u;\r\n    uint raw7 = read_mem(param_14, param_15);\r\n    Alloc param_16 = a;\r\n    uint param_17 = ix + 8u;\r\n    uint raw8 = read_mem(param_16, param_17);\r\n    Alloc param_18 = a;\r\n    uint param_19 = ix + 9u;\r\n    uint raw9 = read_mem(param_18, param_19);\r\n    Alloc param_20 = a;\r\n    uint param_21 = ix + 10u;\r\n    uint raw10 = read_mem(param_20, param_21);\r\n    Alloc param_22 = a;\r\n    uint param_23 = ix + 11u;\r\n    uint raw11 = read_mem(param_22, param_23);\r\n    AnnoFillTexture s;\r\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.mat = vec4(uintBitsToFloat(raw4), uintBitsToFloat(raw5), uintBitsToFloat(raw6), uintBitsToFloat(raw7));\r\n    s.translate = vec2(uintBitsToFloat(raw8), uintBitsToFloat(raw9));\r\n    s.uv_bounds = uvec2(raw10, raw11);\r\n    return s;\r\n}\r\n\r\nAnnoFillTexture Annotated_FillTexture_read(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    AnnoFillTextureRef param_1 = AnnoFillTextureRef(ref.offset + 4u);\r\n    return AnnoFillTexture_read(param, param_1);\r\n}\r\n\r\nvoid CmdFillTexture_write(Alloc a, CmdFillTextureRef ref, CmdFillTexture s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = s.tile_ref;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = uint(s.backdrop);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = floatBitsToUint(s.mat.x);\r\n    write_mem(param_6, param_7, param_8);\r\n    Alloc param_9 = a;\r\n    uint param_10 = ix + 3u;\r\n    uint param_11 = floatBitsToUint(s.mat.y);\r\n    write_mem(param_9, param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 4u;\r\n    uint param_14 = floatBitsToUint(s.mat.z);\r\n    write_mem(param_12, param_13, param_14);\r\n    Alloc param_15 = a;\r\n    uint param_16 = ix + 5u;\r\n    uint param_17 = floatBitsToUint(s.mat.w);\r\n    write_mem(param_15, param_16, param_17);\r\n    Alloc param_18 = a;\r\n    uint param_19 = ix + 6u;\r\n    uint param_20 = floatBitsToUint(s.translate.x);\r\n    write_mem(param_18, param_19, param_20);\r\n    Alloc param_21 = a;\r\n    uint param_22 = ix + 7u;\r\n    uint param_23 = floatBitsToUint(s.translate.y);\r\n    write_mem(param_21, param_22, param_23);\r\n    Alloc param_24 = a;\r\n    uint param_25 = ix + 8u;\r\n    uint param_26 = s.uv_bounds.x;\r\n    write_mem(param_24, param_25, param_26);\r\n    Alloc param_27 = a;\r\n    uint param_28 = ix + 9u;\r\n    uint param_29 = s.uv_bounds.y;\r\n    write_mem(param_27, param_28, param_29);\r\n}\r\n\r\nvoid Cmd_FillTexture_write(Alloc a, CmdRef ref, CmdFillTexture s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 4u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdFillTextureRef param_4 = CmdFillTextureRef(ref.offset + 4u);\r\n    CmdFillTexture param_5 = s;\r\n    CmdFillTexture_write(param_3, param_4, param_5);\r\n}\r\n\r\nvoid CmdSolidTexture_write(Alloc a, CmdSolidTextureRef ref, CmdSolidTexture s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.mat.x);\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = floatBitsToUint(s.mat.y);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = floatBitsToUint(s.mat.z);\r\n    write_mem(param_6, param_7, param_8);\r\n    Alloc param_9 = a;\r\n    uint param_10 = ix + 3u;\r\n    uint param_11 = floatBitsToUint(s.mat.w);\r\n    write_mem(param_9, param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 4u;\r\n    uint param_14 = floatBitsToUint(s.translate.x);\r\n    write_mem(param_12, param_13, param_14);\r\n    Alloc param_15 = a;\r\n    uint param_16 = ix + 5u;\r\n    uint param_17 = floatBitsToUint(s.translate.y);\r\n    write_mem(param_15, param_16, param_17);\r\n    Alloc param_18 = a;\r\n    uint param_19 = ix + 6u;\r\n    uint param_20 = s.uv_bounds.x;\r\n    write_mem(param_18, param_19, param_20);\r\n    Alloc param_21 = a;\r\n    uint param_22 = ix + 7u;\r\n    uint param_23 = s.uv_bounds.y;\r\n    write_mem(param_21, param_22, param_23);\r\n}\r\n\r\nvoid Cmd_SolidTexture_write(Alloc a, CmdRef ref, CmdSolidTexture s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 11u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdSolidTextureRef param_4 = CmdSolidTextureRef(ref.offset + 4u);\r\n    CmdSolidTexture param_5 = s;\r\n    CmdSolidTexture_write(param_3, param_4, param_5);\r\n}\r\n\r\nvoid CmdBeginClip_write(Alloc a, CmdBeginClipRef ref, CmdBeginClip s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = s.tile_ref;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = uint(s.backdrop);\r\n    write_mem(param_3, param_4, param_5);\r\n}\r\n\r\nvoid Cmd_BeginClip_write(Alloc a, CmdRef ref, CmdBeginClip s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 5u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdBeginClipRef param_4 = CmdBeginClipRef(ref.offset + 4u);\r\n    CmdBeginClip param_5 = s;\r\n    CmdBeginClip_write(param_3, param_4, param_5);\r\n}\r\n\r\nvoid CmdBeginSolidClip_write(Alloc a, CmdBeginSolidClipRef ref, CmdBeginSolidClip s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.alpha);\r\n    write_mem(param, param_1, param_2);\r\n}\r\n\r\nvoid Cmd_BeginSolidClip_write(Alloc a, CmdRef ref, CmdBeginSolidClip s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 6u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdBeginSolidClipRef param_4 = CmdBeginSolidClipRef(ref.offset + 4u);\r\n    CmdBeginSolidClip param_5 = s;\r\n    CmdBeginSolidClip_write(param_3, param_4, param_5);\r\n}\r\n\r\nvoid CmdEndClip_write(Alloc a, CmdEndClipRef ref, CmdEndClip s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.alpha);\r\n    write_mem(param, param_1, param_2);\r\n}\r\n\r\nvoid Cmd_EndClip_write(Alloc a, CmdRef ref, CmdEndClip s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 7u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdEndClipRef param_4 = CmdEndClipRef(ref.offset + 4u);\r\n    CmdEndClip param_5 = s;\r\n    CmdEndClip_write(param_3, param_4, param_5);\r\n}\r\n\r\nAnnoStroke AnnoStroke_read(Alloc a, AnnoStrokeRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    Alloc param_10 = a;\r\n    uint param_11 = ix + 5u;\r\n    uint raw5 = read_mem(param_10, param_11);\r\n    AnnoStroke s;\r\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.rgba_color = raw4;\r\n    s.linewidth = uintBitsToFloat(raw5);\r\n    return s;\r\n}\r\n\r\nAnnoStroke Annotated_Stroke_read(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    AnnoStrokeRef param_1 = AnnoStrokeRef(ref.offset + 4u);\r\n    return AnnoStroke_read(param, param_1);\r\n}\r\n\r\nvoid CmdStroke_write(Alloc a, CmdStrokeRef ref, CmdStroke s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = s.tile_ref;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = floatBitsToUint(s.half_width);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = s.rgba_color;\r\n    write_mem(param_6, param_7, param_8);\r\n}\r\n\r\nvoid Cmd_Stroke_write(Alloc a, CmdRef ref, CmdStroke s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 8u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    CmdStrokeRef param_4 = CmdStrokeRef(ref.offset + 4u);\r\n    CmdStroke param_5 = s;\r\n    CmdStroke_write(param_3, param_4, param_5);\r\n}\r\n\r\nvoid Cmd_End_write(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 0u;\r\n    write_mem(param, param_1, param_2);\r\n}\r\n\r\nvoid main()\r\n{\r\n    if (_308.mem_error != 0u)\r\n    {\r\n        return;\r\n    }\r\n    uint width_in_bins = ((_1338.conf.width_in_tiles + 16u) - 1u) / 16u;\r\n    uint bin_ix = (width_in_bins * gl_WorkGroupID.y) + gl_WorkGroupID.x;\r\n    uint partition_ix = 0u;\r\n    uint n_partitions = ((_1338.conf.n_elements + 128u) - 1u) / 128u;\r\n    uint th_ix = gl_LocalInvocationID.x;\r\n    uint bin_tile_x = 16u * gl_WorkGroupID.x;\r\n    uint bin_tile_y = 8u * gl_WorkGroupID.y;\r\n    uint tile_x = gl_LocalInvocationID.x % 16u;\r\n    uint tile_y = gl_LocalInvocationID.x / 16u;\r\n    uint this_tile_ix = (((bin_tile_y + tile_y) * _1338.conf.width_in_tiles) + bin_tile_x) + tile_x;\r\n    Alloc param;\r\n    param.offset = _1338.conf.ptcl_alloc.offset;\r\n    uint param_1 = this_tile_ix * 1024u;\r\n    uint param_2 = 1024u;\r\n    Alloc cmd_alloc = slice_mem(param, param_1, param_2);\r\n    CmdRef cmd_ref = CmdRef(cmd_alloc.offset);\r\n    uint cmd_limit = (cmd_ref.offset + 1024u) - 88u;\r\n    uint clip_depth = 0u;\r\n    uint clip_zero_depth = 0u;\r\n    uint clip_one_mask = 0u;\r\n    uint rd_ix = 0u;\r\n    uint wr_ix = 0u;\r\n    uint part_start_ix = 0u;\r\n    uint ready_ix = 0u;\r\n    Alloc param_3;\r\n    Alloc param_5;\r\n    uint _1614;\r\n    uint element_ix;\r\n    AnnotatedRef ref;\r\n    Alloc param_13;\r\n    Alloc param_15;\r\n    uint tile_count;\r\n    Alloc param_21;\r\n    uint _1925;\r\n    bool include_tile;\r\n    Alloc param_26;\r\n    Tile tile_1;\r\n    Alloc param_31;\r\n    CmdFill cmd_fill;\r\n    Alloc param_45;\r\n    CmdFillTexture cmd_fill_tex;\r\n    CmdSolidTexture cmd_solid_tex;\r\n    CmdBeginClip cmd_begin_clip;\r\n    Alloc param_77;\r\n    CmdStroke cmd_stroke;\r\n    while (true)\r\n    {\r\n        for (uint i = 0u; i < 4u; i++)\r\n        {\r\n            sh_bitmaps[i][th_ix] = 0u;\r\n        }\r\n        bool _1666;\r\n        for (;;)\r\n        {\r\n            if ((ready_ix == wr_ix) && (partition_ix < n_partitions))\r\n            {\r\n                part_start_ix = ready_ix;\r\n                uint count = 0u;\r\n                bool _1464 = th_ix < 128u;\r\n                bool _1472;\r\n                if (_1464)\r\n                {\r\n                    _1472 = (partition_ix + th_ix) < n_partitions;\r\n                }\r\n                else\r\n                {\r\n                    _1472 = _1464;\r\n                }\r\n                if (_1472)\r\n                {\r\n                    uint in_ix = (_1338.conf.bin_alloc.offset >> uint(2)) + ((((partition_ix + th_ix) * 128u) + bin_ix) * 2u);\r\n                    param_3.offset = _1338.conf.bin_alloc.offset;\r\n                    uint param_4 = in_ix;\r\n                    count = read_mem(param_3, param_4);\r\n                    param_5.offset = _1338.conf.bin_alloc.offset;\r\n                    uint param_6 = in_ix + 1u;\r\n                    uint offset = read_mem(param_5, param_6);\r\n                    uint param_7 = offset;\r\n                    uint param_8 = count * 4u;\r\n                    sh_part_elements[th_ix] = new_alloc(param_7, param_8);\r\n                }\r\n                for (uint i_1 = 0u; i_1 < 7u; i_1++)\r\n                {\r\n                    if (th_ix < 128u)\r\n                    {\r\n                        sh_part_count[th_ix] = count;\r\n                    }\r\n                    barrier();\r\n                    if (th_ix < 128u)\r\n                    {\r\n                        if (th_ix >= uint(1 << int(i_1)))\r\n                        {\r\n                            count += sh_part_count[th_ix - uint(1 << int(i_1))];\r\n                        }\r\n                    }\r\n                    barrier();\r\n                }\r\n                if (th_ix < 128u)\r\n                {\r\n                    sh_part_count[th_ix] = part_start_ix + count;\r\n                }\r\n                barrier();\r\n                ready_ix = sh_part_count[127];\r\n                partition_ix += 128u;\r\n            }\r\n            uint ix = rd_ix + th_ix;\r\n            if ((ix >= wr_ix) && (ix < ready_ix))\r\n            {\r\n                uint part_ix = 0u;\r\n                for (uint i_2 = 0u; i_2 < 7u; i_2++)\r\n                {\r\n                    uint probe = part_ix + uint(64 >> int(i_2));\r\n                    if (ix >= sh_part_count[probe - 1u])\r\n                    {\r\n                        part_ix = probe;\r\n                    }\r\n                }\r\n                if (part_ix > 0u)\r\n                {\r\n                    _1614 = sh_part_count[part_ix - 1u];\r\n                }\r\n                else\r\n                {\r\n                    _1614 = part_start_ix;\r\n                }\r\n                ix -= _1614;\r\n                Alloc bin_alloc = sh_part_elements[part_ix];\r\n                BinInstanceRef inst_ref = BinInstanceRef(bin_alloc.offset);\r\n                BinInstanceRef param_9 = inst_ref;\r\n                uint param_10 = ix;\r\n                Alloc param_11 = bin_alloc;\r\n                BinInstanceRef param_12 = BinInstance_index(param_9, param_10);\r\n                BinInstance inst = BinInstance_read(param_11, param_12);\r\n                sh_elements[th_ix] = inst.element_ix;\r\n            }\r\n            barrier();\r\n            wr_ix = min((rd_ix + 128u), ready_ix);\r\n            bool _1656 = (wr_ix - rd_ix) < 128u;\r\n            if (_1656)\r\n            {\r\n                _1666 = (wr_ix < ready_ix) || (partition_ix < n_partitions);\r\n            }\r\n            else\r\n            {\r\n                _1666 = _1656;\r\n            }\r\n            if (_1666)\r\n            {\r\n                continue;\r\n            }\r\n            else\r\n            {\r\n                break;\r\n            }\r\n        }\r\n        uint tag = 0u;\r\n        if ((th_ix + rd_ix) < wr_ix)\r\n        {\r\n            element_ix = sh_elements[th_ix];\r\n            ref = AnnotatedRef(_1338.conf.anno_alloc.offset + (element_ix * 52u));\r\n            param_13.offset = _1338.conf.anno_alloc.offset;\r\n            AnnotatedRef param_14 = ref;\r\n            tag = Annotated_tag(param_13, param_14);\r\n        }\r\n        switch (tag)\r\n        {\r\n            case 2u:\r\n            case 3u:\r\n            case 1u:\r\n            case 4u:\r\n            case 5u:\r\n            {\r\n                uint path_ix = element_ix;\r\n                param_15.offset = _1338.conf.tile_alloc.offset;\r\n                PathRef param_16 = PathRef(_1338.conf.tile_alloc.offset + (path_ix * 12u));\r\n                Path path = Path_read(param_15, param_16);\r\n                uint stride = path.bbox.z - path.bbox.x;\r\n                sh_tile_stride[th_ix] = stride;\r\n                int dx = int(path.bbox.x) - int(bin_tile_x);\r\n                int dy = int(path.bbox.y) - int(bin_tile_y);\r\n                int x0 = clamp(dx, 0, 16);\r\n                int y0 = clamp(dy, 0, 8);\r\n                int x1 = clamp(int(path.bbox.z) - int(bin_tile_x), 0, 16);\r\n                int y1 = clamp(int(path.bbox.w) - int(bin_tile_y), 0, 8);\r\n                sh_tile_width[th_ix] = uint(x1 - x0);\r\n                sh_tile_x0[th_ix] = uint(x0);\r\n                sh_tile_y0[th_ix] = uint(y0);\r\n                tile_count = uint(x1 - x0) * uint(y1 - y0);\r\n                uint base = path.tiles.offset - (((uint(dy) * stride) + uint(dx)) * 8u);\r\n                sh_tile_base[th_ix] = base;\r\n                uint param_17 = path.tiles.offset;\r\n                uint param_18 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;\r\n                Alloc path_alloc = new_alloc(param_17, param_18);\r\n                uint param_19 = th_ix;\r\n                Alloc param_20 = path_alloc;\r\n                write_tile_alloc(param_19, param_20);\r\n                break;\r\n            }\r\n            default:\r\n            {\r\n                tile_count = 0u;\r\n                break;\r\n            }\r\n        }\r\n        sh_tile_count[th_ix] = tile_count;\r\n        for (uint i_3 = 0u; i_3 < 7u; i_3++)\r\n        {\r\n            barrier();\r\n            if (th_ix >= uint(1 << int(i_3)))\r\n            {\r\n                tile_count += sh_tile_count[th_ix - uint(1 << int(i_3))];\r\n            }\r\n            barrier();\r\n            sh_tile_count[th_ix] = tile_count;\r\n        }\r\n        barrier();\r\n        uint total_tile_count = sh_tile_count[127];\r\n        for (uint ix_1 = th_ix; ix_1 < total_tile_count; ix_1 += 128u)\r\n        {\r\n            uint el_ix = 0u;\r\n            for (uint i_4 = 0u; i_4 < 7u; i_4++)\r\n            {\r\n                uint probe_1 = el_ix + uint(64 >> int(i_4));\r\n                if (ix_1 >= sh_tile_count[probe_1 - 1u])\r\n                {\r\n                    el_ix = probe_1;\r\n                }\r\n            }\r\n            AnnotatedRef ref_1 = AnnotatedRef(_1338.conf.anno_alloc.offset + (sh_elements[el_ix] * 52u));\r\n            param_21.offset = _1338.conf.anno_alloc.offset;\r\n            AnnotatedRef param_22 = ref_1;\r\n            uint tag_1 = Annotated_tag(param_21, param_22);\r\n            if (el_ix > 0u)\r\n            {\r\n                _1925 = sh_tile_count[el_ix - 1u];\r\n            }\r\n            else\r\n            {\r\n                _1925 = 0u;\r\n            }\r\n            uint seq_ix = ix_1 - _1925;\r\n            uint width = sh_tile_width[el_ix];\r\n            uint x = sh_tile_x0[el_ix] + (seq_ix % width);\r\n            uint y = sh_tile_y0[el_ix] + (seq_ix / width);\r\n            if ((tag_1 == 4u) || (tag_1 == 5u))\r\n            {\r\n                include_tile = true;\r\n            }\r\n            else\r\n            {\r\n                uint param_23 = el_ix;\r\n                Alloc param_24 = read_tile_alloc(param_23);\r\n                TileRef param_25 = TileRef(sh_tile_base[el_ix] + (((sh_tile_stride[el_ix] * y) + x) * 8u));\r\n                Tile tile = Tile_read(param_24, param_25);\r\n                bool _1986 = tile.tile.offset != 0u;\r\n                bool _1993;\r\n                if (!_1986)\r\n                {\r\n                    _1993 = tile.backdrop != 0;\r\n                }\r\n                else\r\n                {\r\n                    _1993 = _1986;\r\n                }\r\n                include_tile = _1993;\r\n            }\r\n            if (include_tile)\r\n            {\r\n                uint el_slice = el_ix / 32u;\r\n                uint el_mask = uint(1 << int(el_ix & 31u));\r\n                uint _2014 = atomicOr(sh_bitmaps[el_slice][(y * 16u) + x], el_mask);\r\n            }\r\n        }\r\n        barrier();\r\n        uint slice_ix = 0u;\r\n        uint bitmap = sh_bitmaps[0][th_ix];\r\n        while (true)\r\n        {\r\n            if (bitmap == 0u)\r\n            {\r\n                slice_ix++;\r\n                if (slice_ix == 4u)\r\n                {\r\n                    break;\r\n                }\r\n                bitmap = sh_bitmaps[slice_ix][th_ix];\r\n                if (bitmap == 0u)\r\n                {\r\n                    continue;\r\n                }\r\n            }\r\n            uint element_ref_ix = (slice_ix * 32u) + uint(findLSB(bitmap));\r\n            uint element_ix_1 = sh_elements[element_ref_ix];\r\n            bitmap &= (bitmap - 1u);\r\n            ref = AnnotatedRef(_1338.conf.anno_alloc.offset + (element_ix_1 * 52u));\r\n            param_26.offset = _1338.conf.anno_alloc.offset;\r\n            AnnotatedRef param_27 = ref;\r\n            tag = Annotated_tag(param_26, param_27);\r\n            if (clip_zero_depth == 0u)\r\n            {\r\n                switch (tag)\r\n                {\r\n                    case 2u:\r\n                    {\r\n                        uint param_28 = element_ref_ix;\r\n                        Alloc param_29 = read_tile_alloc(param_28);\r\n                        TileRef param_30 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));\r\n                        tile_1 = Tile_read(param_29, param_30);\r\n                        param_31.offset = _1338.conf.anno_alloc.offset;\r\n                        AnnotatedRef param_32 = ref;\r\n                        AnnoFill fill = Annotated_Fill_read(param_31, param_32);\r\n                        Alloc param_33 = cmd_alloc;\r\n                        CmdRef param_34 = cmd_ref;\r\n                        uint param_35 = cmd_limit;\r\n                        bool _2122 = alloc_cmd(param_33, param_34, param_35);\r\n                        cmd_alloc = param_33;\r\n                        cmd_ref = param_34;\r\n                        cmd_limit = param_35;\r\n                        if (!_2122)\r\n                        {\r\n                            break;\r\n                        }\r\n                        if (tile_1.tile.offset != 0u)\r\n                        {\r\n                            cmd_fill.tile_ref = tile_1.tile.offset;\r\n                            cmd_fill.backdrop = tile_1.backdrop;\r\n                            cmd_fill.rgba_color = fill.rgba_color;\r\n                            Alloc param_36 = cmd_alloc;\r\n                            CmdRef param_37 = cmd_ref;\r\n                            CmdFill param_38 = cmd_fill;\r\n                            Cmd_Fill_write(param_36, param_37, param_38);\r\n                        }\r\n                        else\r\n                        {\r\n                            Alloc param_39 = cmd_alloc;\r\n                            CmdRef param_40 = cmd_ref;\r\n                            CmdSolid param_41 = CmdSolid(fill.rgba_color);\r\n                            Cmd_Solid_write(param_39, param_40, param_41);\r\n                        }\r\n                        cmd_ref.offset += 44u;\r\n                        break;\r\n                    }\r\n                    case 3u:\r\n                    {\r\n                        uint param_42 = element_ref_ix;\r\n                        Alloc param_43 = read_tile_alloc(param_42);\r\n                        TileRef param_44 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));\r\n                        tile_1 = Tile_read(param_43, param_44);\r\n                        param_45.offset = _1338.conf.anno_alloc.offset;\r\n                        AnnotatedRef param_46 = ref;\r\n                        AnnoFillTexture fill_tex = Annotated_FillTexture_read(param_45, param_46);\r\n                        Alloc param_47 = cmd_alloc;\r\n                        CmdRef param_48 = cmd_ref;\r\n                        uint param_49 = cmd_limit;\r\n                        bool _2202 = alloc_cmd(param_47, param_48, param_49);\r\n                        cmd_alloc = param_47;\r\n                        cmd_ref = param_48;\r\n                        cmd_limit = param_49;\r\n                        if (!_2202)\r\n                        {\r\n                            break;\r\n                        }\r\n                        if (tile_1.tile.offset != 0u)\r\n                        {\r\n                            cmd_fill_tex.tile_ref = tile_1.tile.offset;\r\n                            cmd_fill_tex.backdrop = tile_1.backdrop;\r\n                            cmd_fill_tex.mat = fill_tex.mat;\r\n                            cmd_fill_tex.translate = fill_tex.translate;\r\n                            cmd_fill_tex.uv_bounds = fill_tex.uv_bounds;\r\n                            Alloc param_50 = cmd_alloc;\r\n                            CmdRef param_51 = cmd_ref;\r\n                            CmdFillTexture param_52 = cmd_fill_tex;\r\n                            Cmd_FillTexture_write(param_50, param_51, param_52);\r\n                        }\r\n                        else\r\n                        {\r\n                            cmd_solid_tex.mat = fill_tex.mat;\r\n                            cmd_solid_tex.translate = fill_tex.translate;\r\n                            cmd_solid_tex.uv_bounds = fill_tex.uv_bounds;\r\n                            Alloc param_53 = cmd_alloc;\r\n                            CmdRef param_54 = cmd_ref;\r\n                            CmdSolidTexture param_55 = cmd_solid_tex;\r\n                            Cmd_SolidTexture_write(param_53, param_54, param_55);\r\n                        }\r\n                        cmd_ref.offset += 44u;\r\n                        break;\r\n                    }\r\n                    case 4u:\r\n                    {\r\n                        uint param_56 = element_ref_ix;\r\n                        Alloc param_57 = read_tile_alloc(param_56);\r\n                        TileRef param_58 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));\r\n                        tile_1 = Tile_read(param_57, param_58);\r\n                        bool _2282 = tile_1.tile.offset == 0u;\r\n                        bool _2288;\r\n                        if (_2282)\r\n                        {\r\n                            _2288 = tile_1.backdrop == 0;\r\n                        }\r\n                        else\r\n                        {\r\n                            _2288 = _2282;\r\n                        }\r\n                        if (_2288)\r\n                        {\r\n                            clip_zero_depth = clip_depth + 1u;\r\n                        }\r\n                        else\r\n                        {\r\n                            if ((tile_1.tile.offset == 0u) && (clip_depth < 32u))\r\n                            {\r\n                                clip_one_mask |= uint(1 << int(clip_depth));\r\n                            }\r\n                            else\r\n                            {\r\n                                Alloc param_59 = cmd_alloc;\r\n                                CmdRef param_60 = cmd_ref;\r\n                                uint param_61 = cmd_limit;\r\n                                bool _2314 = alloc_cmd(param_59, param_60, param_61);\r\n                                cmd_alloc = param_59;\r\n                                cmd_ref = param_60;\r\n                                cmd_limit = param_61;\r\n                                if (!_2314)\r\n                                {\r\n                                    break;\r\n                                }\r\n                                if (tile_1.tile.offset != 0u)\r\n                                {\r\n                                    cmd_begin_clip.tile_ref = tile_1.tile.offset;\r\n                                    cmd_begin_clip.backdrop = tile_1.backdrop;\r\n                                    Alloc param_62 = cmd_alloc;\r\n                                    CmdRef param_63 = cmd_ref;\r\n                                    CmdBeginClip param_64 = cmd_begin_clip;\r\n                                    Cmd_BeginClip_write(param_62, param_63, param_64);\r\n                                }\r\n                                else\r\n                                {\r\n                                    float alpha = (tile_1.backdrop == 0) ? 0.0 : 1.0;\r\n                                    Alloc param_65 = cmd_alloc;\r\n                                    CmdRef param_66 = cmd_ref;\r\n                                    CmdBeginSolidClip param_67 = CmdBeginSolidClip(alpha);\r\n                                    Cmd_BeginSolidClip_write(param_65, param_66, param_67);\r\n                                }\r\n                                cmd_ref.offset += 44u;\r\n                                if (clip_depth < 32u)\r\n                                {\r\n                                    clip_one_mask &= uint(~(1 << int(clip_depth)));\r\n                                }\r\n                            }\r\n                        }\r\n                        clip_depth++;\r\n                        break;\r\n                    }\r\n                    case 5u:\r\n                    {\r\n                        clip_depth--;\r\n                        bool _2377 = clip_depth >= 32u;\r\n                        bool _2387;\r\n                        if (!_2377)\r\n                        {\r\n                            _2387 = (clip_one_mask & uint(1 << int(clip_depth))) == 0u;\r\n                        }\r\n                        else\r\n                        {\r\n                            _2387 = _2377;\r\n                        }\r\n                        if (_2387)\r\n                        {\r\n                            Alloc param_68 = cmd_alloc;\r\n                            CmdRef param_69 = cmd_ref;\r\n                            uint param_70 = cmd_limit;\r\n                            bool _2396 = alloc_cmd(param_68, param_69, param_70);\r\n                            cmd_alloc = param_68;\r\n                            cmd_ref = param_69;\r\n                            cmd_limit = param_70;\r\n                            if (!_2396)\r\n                            {\r\n                                break;\r\n                            }\r\n                            Alloc param_71 = cmd_alloc;\r\n                            CmdRef param_72 = cmd_ref;\r\n                            CmdEndClip param_73 = CmdEndClip(1.0);\r\n                            Cmd_EndClip_write(param_71, param_72, param_73);\r\n                            cmd_ref.offset += 44u;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case 1u:\r\n                    {\r\n                        uint param_74 = element_ref_ix;\r\n                        Alloc param_75 = read_tile_alloc(param_74);\r\n                        TileRef param_76 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));\r\n                        tile_1 = Tile_read(param_75, param_76);\r\n                        param_77.offset = _1338.conf.anno_alloc.offset;\r\n                        AnnotatedRef param_78 = ref;\r\n                        AnnoStroke stroke = Annotated_Stroke_read(param_77, param_78);\r\n                        cmd_stroke.tile_ref = tile_1.tile.offset;\r\n                        cmd_stroke.half_width = 0.5 * stroke.linewidth;\r\n                        cmd_stroke.rgba_color = stroke.rgba_color;\r\n                        Alloc param_79 = cmd_alloc;\r\n                        CmdRef param_80 = cmd_ref;\r\n                        uint param_81 = cmd_limit;\r\n                        bool _2462 = alloc_cmd(param_79, param_80, param_81);\r\n                        cmd_alloc = param_79;\r\n                        cmd_ref = param_80;\r\n                        cmd_limit = param_81;\r\n                        if (!_2462)\r\n                        {\r\n                            break;\r\n                        }\r\n                        Alloc param_82 = cmd_alloc;\r\n                        CmdRef param_83 = cmd_ref;\r\n                        CmdStroke param_84 = cmd_stroke;\r\n                        Cmd_Stroke_write(param_82, param_83, param_84);\r\n                        cmd_ref.offset += 44u;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                switch (tag)\r\n                {\r\n                    case 4u:\r\n                    {\r\n                        clip_depth++;\r\n                        break;\r\n                    }\r\n                    case 5u:\r\n                    {\r\n                        if (clip_depth == clip_zero_depth)\r\n                        {\r\n                            clip_zero_depth = 0u;\r\n                        }\r\n                        clip_depth--;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        barrier();\r\n        rd_ix += 128u;\r\n        if ((rd_ix >= ready_ix) && (partition_ix >= n_partitions))\r\n        {\r\n            break;\r\n        }\r\n    }\r\n    bool _2517 = (bin_tile_x + tile_x) < _1338.conf.width_in_tiles;\r\n    bool _2526;\r\n    if (_2517)\r\n    {\r\n        _2526 = (bin_tile_y + tile_y) < _1338.conf.height_in_tiles;\r\n    }\r\n    else\r\n    {\r\n        _2526 = _2517;\r\n    }\r\n    if (_2526)\r\n    {\r\n        Alloc param_85 = cmd_alloc;\r\n        CmdRef param_86 = cmd_ref;\r\n        Cmd_End_write(param_85, param_86);\r\n    }\r\n}\r\n\r\n",
	}
	shader_copy_frag = backend.ShaderSources{
		Name:      "copy.frag",
		Textures:  []backend.TextureBinding{{Name: "tex", Binding: 0}},
		GLSL100ES: "",
		GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\n\nlayout(location = 0) out highp vec4 fragColor;\n\nhighp vec3 sRGBtoRGB(highp vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));\n    highp vec3 below = rgb / vec3(12.9200000762939453125);\n    highp vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    highp vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);\n    highp vec3 param = texel.xyz;\n    highp vec3 rgb = sRGBtoRGB(param);\n    fragColor = vec4(rgb, texel.w);\n}\n\n",
		GLSL130:   "#version 130\n\nuniform sampler2D tex;\n\nout vec4 fragColor;\n\nvec3 sRGBtoRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));\n    vec3 below = rgb / vec3(12.9200000762939453125);\n    vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);\n    vec3 param = texel.xyz;\n    vec3 rgb = sRGBtoRGB(param);\n    fragColor = vec4(rgb, texel.w);\n}\n\n",
		GLSL150:   "#version 150\n\nuniform sampler2D tex;\n\nout vec4 fragColor;\n\nvec3 sRGBtoRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));\n    vec3 below = rgb / vec3(12.9200000762939453125);\n    vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);\n    vec3 param = texel.xyz;\n    vec3 rgb = sRGBtoRGB(param);\n    fragColor = vec4(rgb, texel.w);\n}\n\n",
		/*
		   Texture2D<float4> tex : register(t0);
		   SamplerState _tex_sampler : register(s0);

		   static float4 gl_FragCoord;
		   static float4 fragColor;

		   struct SPIRV_Cross_Input
		   {
		       float4 gl_FragCoord : SV_Position;
		   };

		   struct SPIRV_Cross_Output
		   {
		       float4 fragColor : SV_Target0;
		   };

		   float3 sRGBtoRGB(float3 rgb)
		   {
		       bool3 cutoff = bool3(rgb.x >= 0.040449999272823333740234375f.xxx.x, rgb.y >= 0.040449999272823333740234375f.xxx.y, rgb.z >= 0.040449999272823333740234375f.xxx.z);
		       float3 below = rgb / 12.9200000762939453125f.xxx;
		       float3 above = pow((rgb + 0.054999999701976776123046875f.xxx) / 1.05499994754791259765625f.xxx, 2.400000095367431640625f.xxx);
		       return float3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);
		   }

		   void frag_main()
		   {
		       float4 texel = tex.Load(int3(int2(gl_FragCoord.xy), 0));
		       float3 param = texel.xyz;
		       float3 rgb = sRGBtoRGB(param);
		       fragColor = float4(rgb, texel.w);
		   }

		   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
		   {
		       gl_FragCoord = stage_input.gl_FragCoord;
		       frag_main();
		       SPIRV_Cross_Output stage_output;
		       stage_output.fragColor = fragColor;
		       return stage_output;
		   }

		*/
		HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0xe6, 0x89, 0x5f, 0x74, 0x8b, 0xfc, 0xea, 0x38, 0xd9, 0x27, 0xad, 0x35, 0x2e, 0xc3, 0x88, 0x6b, 0x1, 0x0, 0x0, 0x0, 0x48, 0x3, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0xa4, 0x0, 0x0, 0x0, 0xd8, 0x0, 0x0, 0x0, 0xc, 0x1, 0x0, 0x0, 0xcc, 0x2, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x68, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x74, 0x65, 0x78, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x3, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab, 0x53, 0x48, 0x44, 0x52, 0xb8, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x6e, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x64, 0x20, 0x0, 0x4, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x3, 0x0, 0x0, 0x0, 0x1b, 0x0, 0x0, 0x5, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2d, 0x0, 0x0, 0x7, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0xae, 0x47, 0x61, 0x3d, 0xae, 0x47, 0x61, 0x3d, 0xae, 0x47, 0x61, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x6f, 0xa7, 0x72, 0x3f, 0x6f, 0xa7, 0x72, 0x3f, 0x6f, 0xa7, 0x72, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2f, 0x0, 0x0, 0x5, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x9a, 0x99, 0x19, 0x40, 0x9a, 0x99, 0x19, 0x40, 0x9a, 0x99, 0x19, 0x40, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x5, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1d, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0xe6, 0xae, 0x25, 0x3d, 0xe6, 0xae, 0x25, 0x3d, 0xe6, 0xae, 0x25, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x91, 0x83, 0x9e, 0x3d, 0x91, 0x83, 0x9e, 0x3d, 0x91, 0x83, 0x9e, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x82, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x72, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	}
	shader_copy_vert = backend.ShaderSources{
		Name:      "copy.vert",
		GLSL100ES: "\nvoid main()\n{\n    switch (gl_VertexID)\n    {\n        case 0:\n        {\n            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 1:\n        {\n            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 2:\n        {\n            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n        case 3:\n        {\n            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n    }\n}\n\n",
		GLSL300ES: "#version 300 es\n\nvoid main()\n{\n    switch (gl_VertexID)\n    {\n        case 0:\n        {\n            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 1:\n        {\n            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 2:\n        {\n            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n        case 3:\n        {\n            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n    }\n}\n\n",
		GLSL130:   "#version 130\n\nvoid main()\n{\n    switch (gl_VertexID)\n    {\n        case 0:\n        {\n            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 1:\n        {\n            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 2:\n        {\n            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n        case 3:\n        {\n            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n    }\n}\n\n",
		GLSL150:   "#version 150\n\nvoid main()\n{\n    switch (gl_VertexID)\n    {\n        case 0:\n        {\n            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 1:\n        {\n            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 2:\n        {\n            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n        case 3:\n        {\n            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n    }\n}\n\n",
		/*
		   static float4 gl_Position;
		   static int gl_VertexIndex;
		   struct SPIRV_Cross_Input
		   {
		       uint gl_VertexIndex : SV_VertexID;
		   };

		   struct SPIRV_Cross_Output
		   {
		       float4 gl_Position : SV_Position;
		   };

		   void vert_main()
		   {
		       switch (gl_VertexIndex)
		       {
		           case 0:
		           {
		               gl_Position = float4(-1.0f, 1.0f, 0.0f, 1.0f);
		               break;
		           }
		           case 1:
		           {
		               gl_Position = float4(1.0f, 1.0f, 0.0f, 1.0f);
		               break;
		           }
		           case 2:
		           {
		               gl_Position = float4(-1.0f, -1.0f, 0.0f, 1.0f);
		               break;
		           }
		           case 3:
		           {
		               gl_Position = float4(1.0f, -1.0f, 0.0f, 1.0f);
		               break;
		           }
		       }
		   }

		   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
		   {
		       gl_VertexIndex = int(stage_input.gl_VertexIndex);
		       vert_main();
		       SPIRV_Cross_Output stage_output;
		       stage_output.gl_Position = gl_Position;
		       return stage_output;
		   }

		*/
		HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0x99, 0xb4, 0x5b, 0xef, 0x5d, 0x49, 0x58, 0xa2, 0x51, 0x68, 0x9f, 0xb6, 0x21, 0x1c, 0x52, 0xe7, 0x1, 0x0, 0x0, 0x0, 0xc0, 0x2, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0xb4, 0x0, 0x0, 0x0, 0xe8, 0x0, 0x0, 0x0, 0x44, 0x2, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x44, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0x53, 0x48, 0x44, 0x52, 0x54, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x55, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x4, 0x12, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x4c, 0x0, 0x0, 0x3, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x3, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x6, 0x0, 0x0, 0x3, 0x1, 0x40, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x6, 0x0, 0x0, 0x3, 0x1, 0x40, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x6, 0x0, 0x0, 0x3, 0x1, 0x40, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0xa, 0x0, 0x0, 0x1, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x17, 0x0, 0x0, 0x1, 0x36, 0x0, 0x0, 0x5, 0xb2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x42, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x14, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	}
	shader_cover_frag = [...]backend.ShaderSources{
		{
			Name: "cover.frag",
			Uniforms: backend.UniformsReflection{
				Blocks:    []backend.UniformBlock{{Name: "Color", Binding: 0}},
				Locations: []backend.UniformLocation{{Name: "_12._color", Type: 0x0, Size: 4, Offset: 0}},
				Size:      16,
			},
			Textures:  []backend.TextureBinding{{Name: "cover", Binding: 1}},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nuniform mediump sampler2D cover;\n\nvarying highp vec2 vCoverUV;\nvarying vec2 vUV;\n\nvoid main()\n{\n    gl_FragData[0] = _12._color;\n    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);\n    gl_FragData[0] *= cover_1;\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nlayout(std140) uniform Color\n{\n    vec4 _color;\n} _12;\n\nuniform mediump sampler2D cover;\n\nlayout(location = 0) out vec4 fragColor;\nin highp vec2 vCoverUV;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL130:   "#version 130\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vCoverUV;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL150:   "#version 150\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vCoverUV;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			/*
			   cbuffer Color : register(b0)
			   {
			       float4 _12_color : packoffset(c0);
			   };

			   Texture2D<float4> cover : register(t1);
			   SamplerState _cover_sampler : register(s1);

			   static float4 fragColor;
			   static float2 vCoverUV;
			   static float2 vUV;

			   struct SPIRV_Cross_Input
			   {
			       float2 vCoverUV : TEXCOORD0;
			       float2 vUV : TEXCOORD1;
			   };

			   struct SPIRV_Cross_Output
			   {
			       float4 fragColor : SV_Target0;
			   };

			   void frag_main()
			   {
			       fragColor = _12_color;
			       float cover_1 = min(abs(cover.Sample(_cover_sampler, vCoverUV).x), 1.0f);
			       fragColor *= cover_1;
			   }

			   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
			   {
			       vCoverUV = stage_input.vCoverUV;
			       vUV = stage_input.vUV;
			       frag_main();
			       SPIRV_Cross_Output stage_output;
			       stage_output.fragColor = fragColor;
			       return stage_output;
			   }

			*/
			HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0xbe, 0xef, 0xbf, 0x69, 0x30, 0x75, 0x6b, 0x16, 0xde, 0xd0, 0xe2, 0x98, 0x38, 0x45, 0xf8, 0x59, 0x1, 0x0, 0x0, 0x0, 0xa0, 0x3, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x90, 0x1, 0x0, 0x0, 0xc, 0x2, 0x0, 0x0, 0x20, 0x3, 0x0, 0x0, 0x6c, 0x3, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x8c, 0x0, 0x0, 0x0, 0x8c, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x58, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x28, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x34, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x34, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0x23, 0x0, 0x0, 0x2, 0x0, 0x0, 0x11, 0x80, 0x0, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0xbc, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x2f, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x38, 0x0, 0x0, 0x8, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xc, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x98, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x7c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8b, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x91, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x0, 0xab, 0x91, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xb0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xd4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x44, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
		{
			Name: "cover.frag",
			Uniforms: backend.UniformsReflection{
				Blocks:    []backend.UniformBlock{{Name: "Gradient", Binding: 0}},
				Locations: []backend.UniformLocation{{Name: "_12._color1", Type: 0x0, Size: 4, Offset: 0}, {Name: "_12._color2", Type: 0x0, Size: 4, Offset: 16}},
				Size:      32,
			},
			Textures:  []backend.TextureBinding{{Name: "cover", Binding: 1}},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nuniform mediump sampler2D cover;\n\nvarying vec2 vUV;\nvarying highp vec2 vCoverUV;\n\nvoid main()\n{\n    gl_FragData[0] = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);\n    gl_FragData[0] *= cover_1;\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nlayout(std140) uniform Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n} _12;\n\nuniform mediump sampler2D cover;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\nin highp vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL130:   "#version 130\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vUV;\nin vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL150:   "#version 150\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vUV;\nin vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			/*
			   cbuffer Gradient : register(b0)
			   {
			       float4 _12_color1 : packoffset(c0);
			       float4 _12_color2 : packoffset(c1);
			   };

			   Texture2D<float4> cover : register(t1);
			   SamplerState _cover_sampler : register(s1);

			   static float4 fragColor;
			   static float2 vUV;
			   static float2 vCoverUV;

			   struct SPIRV_Cross_Input
			   {
			       float2 vCoverUV : TEXCOORD0;
			       float2 vUV : TEXCOORD1;
			   };

			   struct SPIRV_Cross_Output
			   {
			       float4 fragColor : SV_Target0;
			   };

			   void frag_main()
			   {
			       fragColor = lerp(_12_color1, _12_color2, clamp(vUV.x, 0.0f, 1.0f).xxxx);
			       float cover_1 = min(abs(cover.Sample(_cover_sampler, vCoverUV).x), 1.0f);
			       fragColor *= cover_1;
			   }

			   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
			   {
			       vUV = stage_input.vUV;
			       vCoverUV = stage_input.vCoverUV;
			       frag_main();
			       SPIRV_Cross_Output stage_output;
			       stage_output.fragColor = fragColor;
			       return stage_output;
			   }

			*/
			HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0xd2, 0x27, 0xbe, 0xa0, 0xfc, 0x1b, 0xe8, 0x79, 0xd, 0x99, 0xe5, 0xb7, 0xfe, 0x6f, 0x25, 0x6f, 0x1, 0x0, 0x0, 0x0, 0x70, 0x4, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x8, 0x1, 0x0, 0x0, 0x38, 0x2, 0x0, 0x0, 0xb4, 0x2, 0x0, 0x0, 0xf0, 0x3, 0x0, 0x0, 0x3c, 0x4, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xc8, 0x0, 0x0, 0x0, 0xc8, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x94, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x28, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x34, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x34, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x12, 0x80, 0x0, 0x0, 0xff, 0xb0, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0xf, 0x80, 0x1, 0x0, 0xe4, 0x81, 0x1, 0x0, 0xe4, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0xf, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x23, 0x0, 0x0, 0x2, 0x0, 0x0, 0x11, 0x80, 0x0, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x28, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x4a, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x42, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x36, 0x20, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x38, 0x0, 0x0, 0x7, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x34, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0xb, 0x1, 0x0, 0x0, 0x7c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8b, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x91, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0, 0x47, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x0, 0xab, 0xab, 0x91, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xb4, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x31, 0x0, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x32, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x44, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x4, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
		{
			Name:      "cover.frag",
			Textures:  []backend.TextureBinding{{Name: "tex", Binding: 0}, {Name: "cover", Binding: 1}},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\nuniform mediump sampler2D cover;\n\nvarying vec2 vUV;\nvarying highp vec2 vCoverUV;\n\nvoid main()\n{\n    gl_FragData[0] = texture2D(tex, vUV);\n    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);\n    gl_FragData[0] *= cover_1;\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\nuniform mediump sampler2D cover;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\nin highp vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL130:   "#version 130\n\nuniform sampler2D tex;\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vUV;\nin vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL150:   "#version 150\n\nuniform sampler2D tex;\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vUV;\nin vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			/*
			   Texture2D<float4> tex : register(t0);
			   SamplerState _tex_sampler : register(s0);
			   Texture2D<float4> cover : register(t1);
			   SamplerState _cover_sampler : register(s1);

			   static float4 fragColor;
			   static float2 vUV;
			   static float2 vCoverUV;

			   struct SPIRV_Cross_Input
			   {
			       float2 vCoverUV : TEXCOORD0;
			       float2 vUV : TEXCOORD1;
			   };

			   struct SPIRV_Cross_Output
			   {
			       float4 fragColor : SV_Target0;
			   };

			   void frag_main()
			   {
			       fragColor = tex.Sample(_tex_sampler, vUV);
			       float cover_1 = min(abs(cover.Sample(_cover_sampler, vCoverUV).x), 1.0f);
			       fragColor *= cover_1;
			   }

			   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
			   {
			       vUV = stage_input.vUV;
			       vCoverUV = stage_input.vCoverUV;
			       frag_main();
			       SPIRV_Cross_Output stage_output;
			       stage_output.fragColor = fragColor;
			       return stage_output;
			   }

			*/
			HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0x99, 0x16, 0x6c, 0x60, 0xf6, 0x3a, 0x6b, 0xa2, 0x59, 0x24, 0xa1, 0x2c, 0xfd, 0xcd, 0x4a, 0x45, 0x1, 0x0, 0x0, 0x0, 0xd8, 0x3, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xec, 0x0, 0x0, 0x0, 0xe8, 0x1, 0x0, 0x0, 0x64, 0x2, 0x0, 0x0, 0x58, 0x3, 0x0, 0x0, 0xa4, 0x3, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xac, 0x0, 0x0, 0x0, 0xac, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x2, 0x0, 0x24, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x1, 0x8, 0xf, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0x1b, 0xb0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x8, 0xe4, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x1, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x1, 0x8, 0xe4, 0xa0, 0x23, 0x0, 0x0, 0x2, 0x1, 0x0, 0x11, 0x80, 0x1, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0xf4, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x3d, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0xc2, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe6, 0x1a, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xec, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0xc2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa9, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xb8, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0xbc, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x5f, 0x74, 0x65, 0x78, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x74, 0x65, 0x78, 0x0, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x44, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xc, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
	}
	shader_cover_vert = backend.ShaderSources{
		Name:   "cover.vert",
		Inputs: []backend.InputLocation{{Name: "pos", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 2}},
		Uniforms: backend.UniformsReflection{
			Blocks:    []backend.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []backend.UniformLocation{{Name: "_53.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_53.uvCoverTransform", Type: 0x0, Size: 4, Offset: 16}, {Name: "_53.uvTransformR1", Type: 0x0, Size: 4, Offset: 32}, {Name: "_53.uvTransformR2", Type: 0x0, Size: 4, Offset: 48}, {Name: "_53.z", Type: 0x0, Size: 1, Offset: 64}},
			Size:      68,
		},
		GLSL100ES: "\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvCoverTransform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _53;\n\nattribute vec2 pos;\nvarying vec2 vUV;\nattribute vec2 uv;\nvarying vec2 vCoverUV;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec4 param = vec4((pos * _53.transform.xy) + _53.transform.zw, _53.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_53.uvTransformR1.xyz, _53.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_4 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_3, param_4);\n    vCoverUV = ((uv3 * vec3(_53.uvCoverTransform.xy, 1.0)) + vec3(_53.uvCoverTransform.zw, 0.0)).xy;\n}\n\n",
		GLSL300ES: "#version 300 es\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nlayout(std140) uniform Block\n{\n    vec4 transform;\n    vec4 uvCoverTransform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n} _53;\n\nlayout(location = 0) in vec2 pos;\nout vec2 vUV;\nlayout(location = 1) in vec2 uv;\nout vec2 vCoverUV;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec4 param = vec4((pos * _53.transform.xy) + _53.transform.zw, _53.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_53.uvTransformR1.xyz, _53.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_4 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_3, param_4);\n    vCoverUV = ((uv3 * vec3(_53.uvCoverTransform.xy, 1.0)) + vec3(_53.uvCoverTransform.zw, 0.0)).xy;\n}\n\n",
		GLSL130:   "#version 130\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvCoverTransform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _53;\n\nin vec2 pos;\nout vec2 vUV;\nin vec2 uv;\nout vec2 vCoverUV;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec4 param = vec4((pos * _53.transform.xy) + _53.transform.zw, _53.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_53.uvTransformR1.xyz, _53.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_4 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_3, param_4);\n    vCoverUV = ((uv3 * vec3(_53.uvCoverTransform.xy, 1.0)) + vec3(_53.uvCoverTransform.zw, 0.0)).xy;\n}\n\n",
		GLSL150:   "#version 150\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvCoverTransform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _53;\n\nin vec2 pos;\nout vec2 vUV;\nin vec2 uv;\nout vec2 vCoverUV;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec4 param = vec4((pos * _53.transform.xy) + _53.transform.zw, _53.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_53.uvTransformR1.xyz, _53.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_4 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_3, param_4);\n    vCoverUV = ((uv3 * vec3(_53.uvCoverTransform.xy, 1.0)) + vec3(_53.uvCoverTransform.zw, 0.0)).xy;\n}\n\n",
		/*
		   struct m3x2
		   {
		       float3 r0;
		       float3 r1;
		   };

		   static const m3x2 _115 = { float3(1.0f, 0.0f, 0.0f), float3(0.0f, -1.0f, 1.0f) };
		   static const m3x2 _141 = { float3(1.0f, 0.0f, 0.0f), float3(0.0f, 1.0f, 0.0f) };

		   cbuffer Block : register(b0)
		   {
		       float4 _70_transform : packoffset(c0);
		       float4 _70_uvCoverTransform : packoffset(c1);
		       float4 _70_uvTransformR1 : packoffset(c2);
		       float4 _70_uvTransformR2 : packoffset(c3);
		       float _70_z : packoffset(c4);
		   };


		   static float4 gl_Position;
		   static float2 pos;
		   static float2 vUV;
		   static float2 uv;
		   static float2 vCoverUV;

		   struct SPIRV_Cross_Input
		   {
		       float2 pos : POSITION;
		       float2 uv : NORMAL;
		   };

		   struct SPIRV_Cross_Output
		   {
		       float2 vCoverUV : TEXCOORD0;
		       float2 vUV : TEXCOORD1;
		       float4 gl_Position : SV_Position;
		   };

		   float4 toClipSpace(float4 pos_1)
		   {
		       return float4(pos_1.xy, (pos_1.z + pos_1.w) * 0.5f, pos_1.w);
		   }

		   float3 transform3x2(m3x2 t, float3 v)
		   {
		       return float3(dot(t.r0, v), dot(t.r1, v), dot(float3(0.0f, 0.0f, 1.0f), v));
		   }

		   void vert_main()
		   {
		       float4 param = float4((pos * _70_transform.xy) + _70_transform.zw, _70_z, 1.0f);
		       gl_Position = toClipSpace(param);
		       m3x2 _101 = { _70_uvTransformR1.xyz, _70_uvTransformR2.xyz };
		       m3x2 param_1 = _101;
		       float3 param_2 = float3(uv, 1.0f);
		       vUV = transform3x2(param_1, param_2).xy;
		       m3x2 param_3 = _115;
		       float3 param_4 = float3(uv, 1.0f);
		       float3 uv3 = transform3x2(param_3, param_4);
		       vCoverUV = ((uv3 * float3(_70_uvCoverTransform.xy, 1.0f)) + float3(_70_uvCoverTransform.zw, 0.0f)).xy;
		   }

		   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
		   {
		       pos = stage_input.pos;
		       uv = stage_input.uv;
		       vert_main();
		       SPIRV_Cross_Output stage_output;
		       stage_output.gl_Position = gl_Position;
		       stage_output.vUV = vUV;
		       stage_output.vCoverUV = vCoverUV;
		       return stage_output;
		   }

		*/
		HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0xb3, 0x71, 0x8c, 0x9f, 0x3e, 0x4f, 0x8b, 0x50, 0xb7, 0xa2, 0x4b, 0xfb, 0xad, 0x7d, 0xc8, 0x71, 0x1, 0x0, 0x0, 0x0, 0xcc, 0x5, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x78, 0x1, 0x0, 0x0, 0x1c, 0x3, 0x0, 0x0, 0x98, 0x3, 0x0, 0x0, 0xc, 0x5, 0x0, 0x0, 0x5c, 0x5, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x38, 0x1, 0x0, 0x0, 0x38, 0x1, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x4, 0x1, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x6, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x0, 0x3f, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x7, 0x80, 0x1, 0x0, 0xc4, 0x90, 0x6, 0x0, 0xd0, 0xa0, 0x6, 0x0, 0xc5, 0xa0, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x8, 0xe0, 0x3, 0x0, 0xe4, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x4, 0xe0, 0x4, 0x0, 0xe4, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x1, 0x0, 0xe1, 0x90, 0x6, 0x0, 0xe4, 0xa0, 0x6, 0x0, 0xe1, 0xa0, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x6, 0x0, 0xe2, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0xe0, 0x0, 0x0, 0xe4, 0x80, 0x2, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0xee, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x90, 0x1, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0xee, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xb, 0x80, 0x6, 0x0, 0xe4, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0xc, 0xc0, 0x5, 0x0, 0x0, 0xa0, 0x0, 0x0, 0x74, 0x80, 0x0, 0x0, 0x34, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x9c, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x67, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xc2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x42, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0xf, 0x0, 0x0, 0xa, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96, 0x5, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x8, 0x42, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x82, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x8, 0x82, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x82, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0x42, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x36, 0x0, 0x0, 0x5, 0x82, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0xb, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x6c, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0x44, 0x1, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf4, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0x1, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1b, 0x1, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2d, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x34, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x75, 0x76, 0x43, 0x6f, 0x76, 0x65, 0x72, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x52, 0x31, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x52, 0x32, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x7a, 0x0, 0xab, 0x0, 0x0, 0x3, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x48, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x68, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x3, 0x0, 0x0, 0x59, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_elements_comp = backend.ShaderSources{
		Name:      "elements.comp",
		GLSL310ES: "#version 310 es\r\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;\r\n\r\nstruct Alloc\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct ElementRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct LineSegRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct LineSeg\r\n{\r\n    vec2 p0;\r\n    vec2 p1;\r\n};\r\n\r\nstruct QuadSegRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct QuadSeg\r\n{\r\n    vec2 p0;\r\n    vec2 p1;\r\n    vec2 p2;\r\n};\r\n\r\nstruct CubicSegRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CubicSeg\r\n{\r\n    vec2 p0;\r\n    vec2 p1;\r\n    vec2 p2;\r\n    vec2 p3;\r\n};\r\n\r\nstruct FillRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Fill\r\n{\r\n    uint rgba_color;\r\n};\r\n\r\nstruct FillTextureRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct FillTexture\r\n{\r\n    uvec2 uv_bounds;\r\n};\r\n\r\nstruct StrokeRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Stroke\r\n{\r\n    uint rgba_color;\r\n};\r\n\r\nstruct SetLineWidthRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct SetLineWidth\r\n{\r\n    float width;\r\n};\r\n\r\nstruct TransformRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Transform\r\n{\r\n    vec4 mat;\r\n    vec2 translate;\r\n};\r\n\r\nstruct ClipRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Clip\r\n{\r\n    vec4 bbox;\r\n};\r\n\r\nstruct StateRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct State\r\n{\r\n    vec4 mat;\r\n    vec2 translate;\r\n    vec4 bbox;\r\n    float linewidth;\r\n    uint flags;\r\n    uint path_count;\r\n    uint pathseg_count;\r\n};\r\n\r\nstruct AnnoFillRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoFill\r\n{\r\n    vec4 bbox;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct AnnoFillTextureRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoFillTexture\r\n{\r\n    vec4 bbox;\r\n    vec4 mat;\r\n    vec2 translate;\r\n    uvec2 uv_bounds;\r\n};\r\n\r\nstruct AnnoStrokeRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoStroke\r\n{\r\n    vec4 bbox;\r\n    uint rgba_color;\r\n    float linewidth;\r\n};\r\n\r\nstruct AnnoClipRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoClip\r\n{\r\n    vec4 bbox;\r\n};\r\n\r\nstruct AnnotatedRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct PathStrokeCubicRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct PathStrokeCubic\r\n{\r\n    vec2 p0;\r\n    vec2 p1;\r\n    vec2 p2;\r\n    vec2 p3;\r\n    uint path_ix;\r\n    vec2 stroke;\r\n};\r\n\r\nstruct PathSegRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Config\r\n{\r\n    uint n_elements;\r\n    uint n_pathseg;\r\n    uint width_in_tiles;\r\n    uint height_in_tiles;\r\n    Alloc tile_alloc;\r\n    Alloc bin_alloc;\r\n    Alloc ptcl_alloc;\r\n    Alloc pathseg_alloc;\r\n    Alloc anno_alloc;\r\n};\r\n\r\nlayout(binding = 0, std430) buffer Memory\r\n{\r\n    uint mem_offset;\r\n    uint mem_error;\r\n    uint memory[];\r\n} _281;\r\n\r\nlayout(binding = 2, std430) readonly buffer SceneBuf\r\n{\r\n    uint scene[];\r\n} _306;\r\n\r\nlayout(binding = 3, std430) coherent buffer StateBuf\r\n{\r\n    uint part_counter;\r\n    uint state[];\r\n} _772;\r\n\r\nlayout(binding = 1, std430) readonly buffer ConfigBuf\r\n{\r\n    Config conf;\r\n} _2473;\r\n\r\nshared uint sh_part_ix;\r\nshared vec4 sh_mat[32];\r\nshared vec2 sh_translate[32];\r\nshared vec4 sh_bbox[32];\r\nshared float sh_width[32];\r\nshared uint sh_flags[32];\r\nshared uint sh_path_count[32];\r\nshared uint sh_pathseg_count[32];\r\nshared State sh_prefix;\r\n\r\nuint Element_tag(ElementRef ref)\r\n{\r\n    return _306.scene[ref.offset >> uint(2)];\r\n}\r\n\r\nLineSeg LineSeg_read(LineSegRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    uint raw1 = _306.scene[ix + 1u];\r\n    uint raw2 = _306.scene[ix + 2u];\r\n    uint raw3 = _306.scene[ix + 3u];\r\n    LineSeg s;\r\n    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\r\n    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    return s;\r\n}\r\n\r\nLineSeg Element_FillLine_read(ElementRef ref)\r\n{\r\n    LineSegRef param = LineSegRef(ref.offset + 4u);\r\n    return LineSeg_read(param);\r\n}\r\n\r\nQuadSeg QuadSeg_read(QuadSegRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    uint raw1 = _306.scene[ix + 1u];\r\n    uint raw2 = _306.scene[ix + 2u];\r\n    uint raw3 = _306.scene[ix + 3u];\r\n    uint raw4 = _306.scene[ix + 4u];\r\n    uint raw5 = _306.scene[ix + 5u];\r\n    QuadSeg s;\r\n    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\r\n    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\r\n    return s;\r\n}\r\n\r\nQuadSeg Element_FillQuad_read(ElementRef ref)\r\n{\r\n    QuadSegRef param = QuadSegRef(ref.offset + 4u);\r\n    return QuadSeg_read(param);\r\n}\r\n\r\nCubicSeg CubicSeg_read(CubicSegRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    uint raw1 = _306.scene[ix + 1u];\r\n    uint raw2 = _306.scene[ix + 2u];\r\n    uint raw3 = _306.scene[ix + 3u];\r\n    uint raw4 = _306.scene[ix + 4u];\r\n    uint raw5 = _306.scene[ix + 5u];\r\n    uint raw6 = _306.scene[ix + 6u];\r\n    uint raw7 = _306.scene[ix + 7u];\r\n    CubicSeg s;\r\n    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\r\n    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\r\n    s.p3 = vec2(uintBitsToFloat(raw6), uintBitsToFloat(raw7));\r\n    return s;\r\n}\r\n\r\nCubicSeg Element_FillCubic_read(ElementRef ref)\r\n{\r\n    CubicSegRef param = CubicSegRef(ref.offset + 4u);\r\n    return CubicSeg_read(param);\r\n}\r\n\r\nSetLineWidth SetLineWidth_read(SetLineWidthRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    SetLineWidth s;\r\n    s.width = uintBitsToFloat(raw0);\r\n    return s;\r\n}\r\n\r\nSetLineWidth Element_SetLineWidth_read(ElementRef ref)\r\n{\r\n    SetLineWidthRef param = SetLineWidthRef(ref.offset + 4u);\r\n    return SetLineWidth_read(param);\r\n}\r\n\r\nTransform Transform_read(TransformRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    uint raw1 = _306.scene[ix + 1u];\r\n    uint raw2 = _306.scene[ix + 2u];\r\n    uint raw3 = _306.scene[ix + 3u];\r\n    uint raw4 = _306.scene[ix + 4u];\r\n    uint raw5 = _306.scene[ix + 5u];\r\n    Transform s;\r\n    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\r\n    return s;\r\n}\r\n\r\nTransform Element_Transform_read(ElementRef ref)\r\n{\r\n    TransformRef param = TransformRef(ref.offset + 4u);\r\n    return Transform_read(param);\r\n}\r\n\r\nState map_element(ElementRef ref)\r\n{\r\n    ElementRef param = ref;\r\n    uint tag = Element_tag(param);\r\n    State c;\r\n    c.bbox = vec4(0.0);\r\n    c.mat = vec4(1.0, 0.0, 0.0, 1.0);\r\n    c.translate = vec2(0.0);\r\n    c.linewidth = 1.0;\r\n    c.flags = 0u;\r\n    c.path_count = 0u;\r\n    c.pathseg_count = 0u;\r\n    switch (tag)\r\n    {\r\n        case 2u:\r\n        case 1u:\r\n        {\r\n            ElementRef param_1 = ref;\r\n            LineSeg line = Element_FillLine_read(param_1);\r\n            vec2 _1821 = min(line.p0, line.p1);\r\n            c.bbox = vec4(_1821.x, _1821.y, c.bbox.z, c.bbox.w);\r\n            vec2 _1829 = max(line.p0, line.p1);\r\n            c.bbox = vec4(c.bbox.x, c.bbox.y, _1829.x, _1829.y);\r\n            c.pathseg_count = 1u;\r\n            break;\r\n        }\r\n        case 4u:\r\n        case 3u:\r\n        {\r\n            ElementRef param_2 = ref;\r\n            QuadSeg quad = Element_FillQuad_read(param_2);\r\n            vec2 _1846 = min(min(quad.p0, quad.p1), quad.p2);\r\n            c.bbox = vec4(_1846.x, _1846.y, c.bbox.z, c.bbox.w);\r\n            vec2 _1857 = max(max(quad.p0, quad.p1), quad.p2);\r\n            c.bbox = vec4(c.bbox.x, c.bbox.y, _1857.x, _1857.y);\r\n            c.pathseg_count = 1u;\r\n            break;\r\n        }\r\n        case 6u:\r\n        case 5u:\r\n        {\r\n            ElementRef param_3 = ref;\r\n            CubicSeg cubic = Element_FillCubic_read(param_3);\r\n            vec2 _1877 = min(min(cubic.p0, cubic.p1), min(cubic.p2, cubic.p3));\r\n            c.bbox = vec4(_1877.x, _1877.y, c.bbox.z, c.bbox.w);\r\n            vec2 _1891 = max(max(cubic.p0, cubic.p1), max(cubic.p2, cubic.p3));\r\n            c.bbox = vec4(c.bbox.x, c.bbox.y, _1891.x, _1891.y);\r\n            c.pathseg_count = 1u;\r\n            break;\r\n        }\r\n        case 8u:\r\n        case 13u:\r\n        case 7u:\r\n        case 11u:\r\n        {\r\n            c.flags = 4u;\r\n            c.path_count = 1u;\r\n            break;\r\n        }\r\n        case 12u:\r\n        {\r\n            c.path_count = 1u;\r\n            break;\r\n        }\r\n        case 9u:\r\n        {\r\n            ElementRef param_4 = ref;\r\n            SetLineWidth lw = Element_SetLineWidth_read(param_4);\r\n            c.linewidth = lw.width;\r\n            c.flags = 1u;\r\n            break;\r\n        }\r\n        case 10u:\r\n        {\r\n            ElementRef param_5 = ref;\r\n            Transform t = Element_Transform_read(param_5);\r\n            c.mat = t.mat;\r\n            c.translate = t.translate;\r\n            break;\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\nElementRef Element_index(ElementRef ref, uint index)\r\n{\r\n    return ElementRef(ref.offset + (index * 36u));\r\n}\r\n\r\nState combine_state(State a, State b)\r\n{\r\n    State c;\r\n    c.bbox.x = (min(a.mat.x * b.bbox.x, a.mat.x * b.bbox.z) + min(a.mat.z * b.bbox.y, a.mat.z * b.bbox.w)) + a.translate.x;\r\n    c.bbox.y = (min(a.mat.y * b.bbox.x, a.mat.y * b.bbox.z) + min(a.mat.w * b.bbox.y, a.mat.w * b.bbox.w)) + a.translate.y;\r\n    c.bbox.z = (max(a.mat.x * b.bbox.x, a.mat.x * b.bbox.z) + max(a.mat.z * b.bbox.y, a.mat.z * b.bbox.w)) + a.translate.x;\r\n    c.bbox.w = (max(a.mat.y * b.bbox.x, a.mat.y * b.bbox.z) + max(a.mat.w * b.bbox.y, a.mat.w * b.bbox.w)) + a.translate.y;\r\n    bool _1592 = (a.flags & 4u) == 0u;\r\n    bool _1600;\r\n    if (_1592)\r\n    {\r\n        _1600 = b.bbox.z <= b.bbox.x;\r\n    }\r\n    else\r\n    {\r\n        _1600 = _1592;\r\n    }\r\n    bool _1608;\r\n    if (_1600)\r\n    {\r\n        _1608 = b.bbox.w <= b.bbox.y;\r\n    }\r\n    else\r\n    {\r\n        _1608 = _1600;\r\n    }\r\n    if (_1608)\r\n    {\r\n        c.bbox = a.bbox;\r\n    }\r\n    else\r\n    {\r\n        bool _1618 = (a.flags & 4u) == 0u;\r\n        bool _1625;\r\n        if (_1618)\r\n        {\r\n            _1625 = (b.flags & 2u) == 0u;\r\n        }\r\n        else\r\n        {\r\n            _1625 = _1618;\r\n        }\r\n        bool _1642;\r\n        if (_1625)\r\n        {\r\n            bool _1632 = a.bbox.z > a.bbox.x;\r\n            bool _1641;\r\n            if (!_1632)\r\n            {\r\n                _1641 = a.bbox.w > a.bbox.y;\r\n            }\r\n            else\r\n            {\r\n                _1641 = _1632;\r\n            }\r\n            _1642 = _1641;\r\n        }\r\n        else\r\n        {\r\n            _1642 = _1625;\r\n        }\r\n        if (_1642)\r\n        {\r\n            vec2 _1651 = min(a.bbox.xy, c.bbox.xy);\r\n            c.bbox = vec4(_1651.x, _1651.y, c.bbox.z, c.bbox.w);\r\n            vec2 _1661 = max(a.bbox.zw, c.bbox.zw);\r\n            c.bbox = vec4(c.bbox.x, c.bbox.y, _1661.x, _1661.y);\r\n        }\r\n    }\r\n    c.mat.x = (a.mat.x * b.mat.x) + (a.mat.z * b.mat.y);\r\n    c.mat.y = (a.mat.y * b.mat.x) + (a.mat.w * b.mat.y);\r\n    c.mat.z = (a.mat.x * b.mat.z) + (a.mat.z * b.mat.w);\r\n    c.mat.w = (a.mat.y * b.mat.z) + (a.mat.w * b.mat.w);\r\n    c.translate.x = ((a.mat.x * b.translate.x) + (a.mat.z * b.translate.y)) + a.translate.x;\r\n    c.translate.y = ((a.mat.y * b.translate.x) + (a.mat.w * b.translate.y)) + a.translate.y;\r\n    float _1747;\r\n    if ((b.flags & 1u) == 0u)\r\n    {\r\n        _1747 = a.linewidth;\r\n    }\r\n    else\r\n    {\r\n        _1747 = b.linewidth;\r\n    }\r\n    c.linewidth = _1747;\r\n    c.flags = (a.flags & 3u) | b.flags;\r\n    c.flags |= ((a.flags & 4u) >> uint(1));\r\n    c.path_count = a.path_count + b.path_count;\r\n    c.pathseg_count = a.pathseg_count + b.pathseg_count;\r\n    return c;\r\n}\r\n\r\nStateRef state_aggregate_ref(uint partition_ix)\r\n{\r\n    return StateRef(4u + (partition_ix * 116u));\r\n}\r\n\r\nvoid State_write(StateRef ref, State s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    _772.state[ix + 0u] = floatBitsToUint(s.mat.x);\r\n    _772.state[ix + 1u] = floatBitsToUint(s.mat.y);\r\n    _772.state[ix + 2u] = floatBitsToUint(s.mat.z);\r\n    _772.state[ix + 3u] = floatBitsToUint(s.mat.w);\r\n    _772.state[ix + 4u] = floatBitsToUint(s.translate.x);\r\n    _772.state[ix + 5u] = floatBitsToUint(s.translate.y);\r\n    _772.state[ix + 6u] = floatBitsToUint(s.bbox.x);\r\n    _772.state[ix + 7u] = floatBitsToUint(s.bbox.y);\r\n    _772.state[ix + 8u] = floatBitsToUint(s.bbox.z);\r\n    _772.state[ix + 9u] = floatBitsToUint(s.bbox.w);\r\n    _772.state[ix + 10u] = floatBitsToUint(s.linewidth);\r\n    _772.state[ix + 11u] = s.flags;\r\n    _772.state[ix + 12u] = s.path_count;\r\n    _772.state[ix + 13u] = s.pathseg_count;\r\n}\r\n\r\nStateRef state_prefix_ref(uint partition_ix)\r\n{\r\n    return StateRef((4u + (partition_ix * 116u)) + 56u);\r\n}\r\n\r\nuint state_flag_index(uint partition_ix)\r\n{\r\n    return partition_ix * 29u;\r\n}\r\n\r\nState State_read(StateRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _772.state[ix + 0u];\r\n    uint raw1 = _772.state[ix + 1u];\r\n    uint raw2 = _772.state[ix + 2u];\r\n    uint raw3 = _772.state[ix + 3u];\r\n    uint raw4 = _772.state[ix + 4u];\r\n    uint raw5 = _772.state[ix + 5u];\r\n    uint raw6 = _772.state[ix + 6u];\r\n    uint raw7 = _772.state[ix + 7u];\r\n    uint raw8 = _772.state[ix + 8u];\r\n    uint raw9 = _772.state[ix + 9u];\r\n    uint raw10 = _772.state[ix + 10u];\r\n    uint raw11 = _772.state[ix + 11u];\r\n    uint raw12 = _772.state[ix + 12u];\r\n    uint raw13 = _772.state[ix + 13u];\r\n    State s;\r\n    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\r\n    s.bbox = vec4(uintBitsToFloat(raw6), uintBitsToFloat(raw7), uintBitsToFloat(raw8), uintBitsToFloat(raw9));\r\n    s.linewidth = uintBitsToFloat(raw10);\r\n    s.flags = raw11;\r\n    s.path_count = raw12;\r\n    s.pathseg_count = raw13;\r\n    return s;\r\n}\r\n\r\nLineSeg Element_StrokeLine_read(ElementRef ref)\r\n{\r\n    LineSegRef param = LineSegRef(ref.offset + 4u);\r\n    return LineSeg_read(param);\r\n}\r\n\r\nvec2 get_linewidth(State st)\r\n{\r\n    return vec2(length(st.mat.xz), length(st.mat.yw)) * (0.5 * st.linewidth);\r\n}\r\n\r\nbool touch_mem(Alloc alloc, uint offset)\r\n{\r\n    return true;\r\n}\r\n\r\nvoid write_mem(Alloc alloc, uint offset, uint val)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return;\r\n    }\r\n    _281.memory[offset] = val;\r\n}\r\n\r\nvoid PathStrokeCubic_write(Alloc a, PathStrokeCubicRef ref, PathStrokeCubic s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.p0.x);\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = floatBitsToUint(s.p0.y);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = floatBitsToUint(s.p1.x);\r\n    write_mem(param_6, param_7, param_8);\r\n    Alloc param_9 = a;\r\n    uint param_10 = ix + 3u;\r\n    uint param_11 = floatBitsToUint(s.p1.y);\r\n    write_mem(param_9, param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 4u;\r\n    uint param_14 = floatBitsToUint(s.p2.x);\r\n    write_mem(param_12, param_13, param_14);\r\n    Alloc param_15 = a;\r\n    uint param_16 = ix + 5u;\r\n    uint param_17 = floatBitsToUint(s.p2.y);\r\n    write_mem(param_15, param_16, param_17);\r\n    Alloc param_18 = a;\r\n    uint param_19 = ix + 6u;\r\n    uint param_20 = floatBitsToUint(s.p3.x);\r\n    write_mem(param_18, param_19, param_20);\r\n    Alloc param_21 = a;\r\n    uint param_22 = ix + 7u;\r\n    uint param_23 = floatBitsToUint(s.p3.y);\r\n    write_mem(param_21, param_22, param_23);\r\n    Alloc param_24 = a;\r\n    uint param_25 = ix + 8u;\r\n    uint param_26 = s.path_ix;\r\n    write_mem(param_24, param_25, param_26);\r\n    Alloc param_27 = a;\r\n    uint param_28 = ix + 9u;\r\n    uint param_29 = floatBitsToUint(s.stroke.x);\r\n    write_mem(param_27, param_28, param_29);\r\n    Alloc param_30 = a;\r\n    uint param_31 = ix + 10u;\r\n    uint param_32 = floatBitsToUint(s.stroke.y);\r\n    write_mem(param_30, param_31, param_32);\r\n}\r\n\r\nQuadSeg Element_StrokeQuad_read(ElementRef ref)\r\n{\r\n    QuadSegRef param = QuadSegRef(ref.offset + 4u);\r\n    return QuadSeg_read(param);\r\n}\r\n\r\nCubicSeg Element_StrokeCubic_read(ElementRef ref)\r\n{\r\n    CubicSegRef param = CubicSegRef(ref.offset + 4u);\r\n    return CubicSeg_read(param);\r\n}\r\n\r\nStroke Stroke_read(StrokeRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    Stroke s;\r\n    s.rgba_color = raw0;\r\n    return s;\r\n}\r\n\r\nStroke Element_Stroke_read(ElementRef ref)\r\n{\r\n    StrokeRef param = StrokeRef(ref.offset + 4u);\r\n    return Stroke_read(param);\r\n}\r\n\r\nvoid AnnoStroke_write(Alloc a, AnnoStrokeRef ref, AnnoStroke s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.bbox.x);\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = floatBitsToUint(s.bbox.y);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = floatBitsToUint(s.bbox.z);\r\n    write_mem(param_6, param_7, param_8);\r\n    Alloc param_9 = a;\r\n    uint param_10 = ix + 3u;\r\n    uint param_11 = floatBitsToUint(s.bbox.w);\r\n    write_mem(param_9, param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 4u;\r\n    uint param_14 = s.rgba_color;\r\n    write_mem(param_12, param_13, param_14);\r\n    Alloc param_15 = a;\r\n    uint param_16 = ix + 5u;\r\n    uint param_17 = floatBitsToUint(s.linewidth);\r\n    write_mem(param_15, param_16, param_17);\r\n}\r\n\r\nvoid Annotated_Stroke_write(Alloc a, AnnotatedRef ref, AnnoStroke s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 1u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    AnnoStrokeRef param_4 = AnnoStrokeRef(ref.offset + 4u);\r\n    AnnoStroke param_5 = s;\r\n    AnnoStroke_write(param_3, param_4, param_5);\r\n}\r\n\r\nFill Fill_read(FillRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    Fill s;\r\n    s.rgba_color = raw0;\r\n    return s;\r\n}\r\n\r\nFill Element_Fill_read(ElementRef ref)\r\n{\r\n    FillRef param = FillRef(ref.offset + 4u);\r\n    return Fill_read(param);\r\n}\r\n\r\nvoid AnnoFill_write(Alloc a, AnnoFillRef ref, AnnoFill s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.bbox.x);\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = floatBitsToUint(s.bbox.y);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = floatBitsToUint(s.bbox.z);\r\n    write_mem(param_6, param_7, param_8);\r\n    Alloc param_9 = a;\r\n    uint param_10 = ix + 3u;\r\n    uint param_11 = floatBitsToUint(s.bbox.w);\r\n    write_mem(param_9, param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 4u;\r\n    uint param_14 = s.rgba_color;\r\n    write_mem(param_12, param_13, param_14);\r\n}\r\n\r\nvoid Annotated_Fill_write(Alloc a, AnnotatedRef ref, AnnoFill s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 2u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    AnnoFillRef param_4 = AnnoFillRef(ref.offset + 4u);\r\n    AnnoFill param_5 = s;\r\n    AnnoFill_write(param_3, param_4, param_5);\r\n}\r\n\r\nFillTexture FillTexture_read(FillTextureRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    uint raw1 = _306.scene[ix + 1u];\r\n    FillTexture s;\r\n    s.uv_bounds = uvec2(raw0, raw1);\r\n    return s;\r\n}\r\n\r\nFillTexture Element_FillTexture_read(ElementRef ref)\r\n{\r\n    FillTextureRef param = FillTextureRef(ref.offset + 4u);\r\n    return FillTexture_read(param);\r\n}\r\n\r\nvoid AnnoFillTexture_write(Alloc a, AnnoFillTextureRef ref, AnnoFillTexture s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.bbox.x);\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = floatBitsToUint(s.bbox.y);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = floatBitsToUint(s.bbox.z);\r\n    write_mem(param_6, param_7, param_8);\r\n    Alloc param_9 = a;\r\n    uint param_10 = ix + 3u;\r\n    uint param_11 = floatBitsToUint(s.bbox.w);\r\n    write_mem(param_9, param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 4u;\r\n    uint param_14 = floatBitsToUint(s.mat.x);\r\n    write_mem(param_12, param_13, param_14);\r\n    Alloc param_15 = a;\r\n    uint param_16 = ix + 5u;\r\n    uint param_17 = floatBitsToUint(s.mat.y);\r\n    write_mem(param_15, param_16, param_17);\r\n    Alloc param_18 = a;\r\n    uint param_19 = ix + 6u;\r\n    uint param_20 = floatBitsToUint(s.mat.z);\r\n    write_mem(param_18, param_19, param_20);\r\n    Alloc param_21 = a;\r\n    uint param_22 = ix + 7u;\r\n    uint param_23 = floatBitsToUint(s.mat.w);\r\n    write_mem(param_21, param_22, param_23);\r\n    Alloc param_24 = a;\r\n    uint param_25 = ix + 8u;\r\n    uint param_26 = floatBitsToUint(s.translate.x);\r\n    write_mem(param_24, param_25, param_26);\r\n    Alloc param_27 = a;\r\n    uint param_28 = ix + 9u;\r\n    uint param_29 = floatBitsToUint(s.translate.y);\r\n    write_mem(param_27, param_28, param_29);\r\n    Alloc param_30 = a;\r\n    uint param_31 = ix + 10u;\r\n    uint param_32 = s.uv_bounds.x;\r\n    write_mem(param_30, param_31, param_32);\r\n    Alloc param_33 = a;\r\n    uint param_34 = ix + 11u;\r\n    uint param_35 = s.uv_bounds.y;\r\n    write_mem(param_33, param_34, param_35);\r\n}\r\n\r\nvoid Annotated_FillTexture_write(Alloc a, AnnotatedRef ref, AnnoFillTexture s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 3u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    AnnoFillTextureRef param_4 = AnnoFillTextureRef(ref.offset + 4u);\r\n    AnnoFillTexture param_5 = s;\r\n    AnnoFillTexture_write(param_3, param_4, param_5);\r\n}\r\n\r\nClip Clip_read(ClipRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    uint raw0 = _306.scene[ix + 0u];\r\n    uint raw1 = _306.scene[ix + 1u];\r\n    uint raw2 = _306.scene[ix + 2u];\r\n    uint raw3 = _306.scene[ix + 3u];\r\n    Clip s;\r\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    return s;\r\n}\r\n\r\nClip Element_BeginClip_read(ElementRef ref)\r\n{\r\n    ClipRef param = ClipRef(ref.offset + 4u);\r\n    return Clip_read(param);\r\n}\r\n\r\nvoid AnnoClip_write(Alloc a, AnnoClipRef ref, AnnoClip s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.bbox.x);\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = floatBitsToUint(s.bbox.y);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = floatBitsToUint(s.bbox.z);\r\n    write_mem(param_6, param_7, param_8);\r\n    Alloc param_9 = a;\r\n    uint param_10 = ix + 3u;\r\n    uint param_11 = floatBitsToUint(s.bbox.w);\r\n    write_mem(param_9, param_10, param_11);\r\n}\r\n\r\nvoid Annotated_BeginClip_write(Alloc a, AnnotatedRef ref, AnnoClip s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 4u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    AnnoClipRef param_4 = AnnoClipRef(ref.offset + 4u);\r\n    AnnoClip param_5 = s;\r\n    AnnoClip_write(param_3, param_4, param_5);\r\n}\r\n\r\nClip Element_EndClip_read(ElementRef ref)\r\n{\r\n    ClipRef param = ClipRef(ref.offset + 4u);\r\n    return Clip_read(param);\r\n}\r\n\r\nvoid Annotated_EndClip_write(Alloc a, AnnotatedRef ref, AnnoClip s)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    uint param_2 = 5u;\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    AnnoClipRef param_4 = AnnoClipRef(ref.offset + 4u);\r\n    AnnoClip param_5 = s;\r\n    AnnoClip_write(param_3, param_4, param_5);\r\n}\r\n\r\nvoid main()\r\n{\r\n    if (_281.mem_error != 0u)\r\n    {\r\n        return;\r\n    }\r\n    if (gl_LocalInvocationID.x == 0u)\r\n    {\r\n        uint _1960 = atomicAdd(_772.part_counter, 1u);\r\n        sh_part_ix = _1960;\r\n    }\r\n    barrier();\r\n    uint part_ix = sh_part_ix;\r\n    uint ix = (part_ix * 128u) + (gl_LocalInvocationID.x * 4u);\r\n    ElementRef ref = ElementRef(ix * 36u);\r\n    ElementRef param = ref;\r\n    State th_state[4];\r\n    th_state[0] = map_element(param);\r\n    for (uint i = 1u; i < 4u; i++)\r\n    {\r\n        ElementRef param_1 = ref;\r\n        uint param_2 = i;\r\n        ElementRef param_3 = Element_index(param_1, param_2);\r\n        State param_4 = th_state[i - 1u];\r\n        State param_5 = map_element(param_3);\r\n        th_state[i] = combine_state(param_4, param_5);\r\n    }\r\n    State agg = th_state[3];\r\n    sh_mat[gl_LocalInvocationID.x] = agg.mat;\r\n    sh_translate[gl_LocalInvocationID.x] = agg.translate;\r\n    sh_bbox[gl_LocalInvocationID.x] = agg.bbox;\r\n    sh_width[gl_LocalInvocationID.x] = agg.linewidth;\r\n    sh_flags[gl_LocalInvocationID.x] = agg.flags;\r\n    sh_path_count[gl_LocalInvocationID.x] = agg.path_count;\r\n    sh_pathseg_count[gl_LocalInvocationID.x] = agg.pathseg_count;\r\n    State other;\r\n    for (uint i_1 = 0u; i_1 < 5u; i_1++)\r\n    {\r\n        barrier();\r\n        if (gl_LocalInvocationID.x >= uint(1 << int(i_1)))\r\n        {\r\n            uint ix_1 = gl_LocalInvocationID.x - uint(1 << int(i_1));\r\n            other.mat = sh_mat[ix_1];\r\n            other.translate = sh_translate[ix_1];\r\n            other.bbox = sh_bbox[ix_1];\r\n            other.linewidth = sh_width[ix_1];\r\n            other.flags = sh_flags[ix_1];\r\n            other.path_count = sh_path_count[ix_1];\r\n            other.pathseg_count = sh_pathseg_count[ix_1];\r\n            State param_6 = other;\r\n            State param_7 = agg;\r\n            agg = combine_state(param_6, param_7);\r\n        }\r\n        barrier();\r\n        sh_mat[gl_LocalInvocationID.x] = agg.mat;\r\n        sh_translate[gl_LocalInvocationID.x] = agg.translate;\r\n        sh_bbox[gl_LocalInvocationID.x] = agg.bbox;\r\n        sh_width[gl_LocalInvocationID.x] = agg.linewidth;\r\n        sh_flags[gl_LocalInvocationID.x] = agg.flags;\r\n        sh_path_count[gl_LocalInvocationID.x] = agg.path_count;\r\n        sh_pathseg_count[gl_LocalInvocationID.x] = agg.pathseg_count;\r\n    }\r\n    State exclusive;\r\n    exclusive.bbox = vec4(0.0);\r\n    exclusive.mat = vec4(1.0, 0.0, 0.0, 1.0);\r\n    exclusive.translate = vec2(0.0);\r\n    exclusive.linewidth = 1.0;\r\n    exclusive.flags = 0u;\r\n    exclusive.path_count = 0u;\r\n    exclusive.pathseg_count = 0u;\r\n    if (gl_LocalInvocationID.x == 31u)\r\n    {\r\n        uint param_8 = part_ix;\r\n        StateRef param_9 = state_aggregate_ref(param_8);\r\n        State param_10 = agg;\r\n        State_write(param_9, param_10);\r\n        uint flag = 1u;\r\n        memoryBarrierBuffer();\r\n        if (part_ix == 0u)\r\n        {\r\n            uint param_11 = part_ix;\r\n            StateRef param_12 = state_prefix_ref(param_11);\r\n            State param_13 = agg;\r\n            State_write(param_12, param_13);\r\n            flag = 2u;\r\n        }\r\n        uint param_14 = part_ix;\r\n        _772.state[state_flag_index(param_14)] = flag;\r\n        if (part_ix != 0u)\r\n        {\r\n            uint look_back_ix = part_ix - 1u;\r\n            uint their_ix = 0u;\r\n            State their_agg;\r\n            while (true)\r\n            {\r\n                uint param_15 = look_back_ix;\r\n                flag = _772.state[state_flag_index(param_15)];\r\n                if (flag == 2u)\r\n                {\r\n                    uint param_16 = look_back_ix;\r\n                    StateRef param_17 = state_prefix_ref(param_16);\r\n                    State their_prefix = State_read(param_17);\r\n                    State param_18 = their_prefix;\r\n                    State param_19 = exclusive;\r\n                    exclusive = combine_state(param_18, param_19);\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    if (flag == 1u)\r\n                    {\r\n                        uint param_20 = look_back_ix;\r\n                        StateRef param_21 = state_aggregate_ref(param_20);\r\n                        their_agg = State_read(param_21);\r\n                        State param_22 = their_agg;\r\n                        State param_23 = exclusive;\r\n                        exclusive = combine_state(param_22, param_23);\r\n                        look_back_ix--;\r\n                        their_ix = 0u;\r\n                        continue;\r\n                    }\r\n                }\r\n                ElementRef ref_1 = ElementRef(((look_back_ix * 128u) + their_ix) * 36u);\r\n                ElementRef param_24 = ref_1;\r\n                State s = map_element(param_24);\r\n                if (their_ix == 0u)\r\n                {\r\n                    their_agg = s;\r\n                }\r\n                else\r\n                {\r\n                    State param_25 = their_agg;\r\n                    State param_26 = s;\r\n                    their_agg = combine_state(param_25, param_26);\r\n                }\r\n                their_ix++;\r\n                if (their_ix == 128u)\r\n                {\r\n                    State param_27 = their_agg;\r\n                    State param_28 = exclusive;\r\n                    exclusive = combine_state(param_27, param_28);\r\n                    if (look_back_ix == 0u)\r\n                    {\r\n                        break;\r\n                    }\r\n                    look_back_ix--;\r\n                    their_ix = 0u;\r\n                }\r\n            }\r\n            State param_29 = exclusive;\r\n            State param_30 = agg;\r\n            State inclusive_prefix = combine_state(param_29, param_30);\r\n            sh_prefix = exclusive;\r\n            uint param_31 = part_ix;\r\n            StateRef param_32 = state_prefix_ref(param_31);\r\n            State param_33 = inclusive_prefix;\r\n            State_write(param_32, param_33);\r\n            memoryBarrierBuffer();\r\n            flag = 2u;\r\n            uint param_34 = part_ix;\r\n            _772.state[state_flag_index(param_34)] = flag;\r\n        }\r\n    }\r\n    barrier();\r\n    if (part_ix != 0u)\r\n    {\r\n        exclusive = sh_prefix;\r\n    }\r\n    State row = exclusive;\r\n    if (gl_LocalInvocationID.x > 0u)\r\n    {\r\n        uint ix_2 = gl_LocalInvocationID.x - 1u;\r\n        State other_1;\r\n        other_1.mat = sh_mat[ix_2];\r\n        other_1.translate = sh_translate[ix_2];\r\n        other_1.bbox = sh_bbox[ix_2];\r\n        other_1.linewidth = sh_width[ix_2];\r\n        other_1.flags = sh_flags[ix_2];\r\n        other_1.path_count = sh_path_count[ix_2];\r\n        other_1.pathseg_count = sh_pathseg_count[ix_2];\r\n        State param_35 = row;\r\n        State param_36 = other_1;\r\n        row = combine_state(param_35, param_36);\r\n    }\r\n    vec2 p0;\r\n    vec2 p1;\r\n    PathStrokeCubic path_cubic;\r\n    PathSegRef path_out_ref;\r\n    uint out_tag;\r\n    Alloc param_44;\r\n    Alloc param_47;\r\n    Alloc param_52;\r\n    Alloc param_55;\r\n    Alloc param_60;\r\n    Alloc param_63;\r\n    AnnoStroke anno_stroke;\r\n    AnnotatedRef out_ref;\r\n    Alloc param_68;\r\n    AnnoFill anno_fill;\r\n    Alloc param_72;\r\n    AnnoFillTexture anno_fill_tex;\r\n    Alloc param_76;\r\n    Alloc param_80;\r\n    Alloc param_84;\r\n    for (uint i_2 = 0u; i_2 < 4u; i_2++)\r\n    {\r\n        State param_37 = row;\r\n        State param_38 = th_state[i_2];\r\n        State st = combine_state(param_37, param_38);\r\n        ElementRef param_39 = ref;\r\n        uint param_40 = i_2;\r\n        ElementRef this_ref = Element_index(param_39, param_40);\r\n        ElementRef param_41 = this_ref;\r\n        uint tag = Element_tag(param_41);\r\n        switch (tag)\r\n        {\r\n            case 2u:\r\n            case 1u:\r\n            {\r\n                ElementRef param_42 = this_ref;\r\n                LineSeg line = Element_StrokeLine_read(param_42);\r\n                p0 = ((st.mat.xy * line.p0.x) + (st.mat.zw * line.p0.y)) + st.translate;\r\n                p1 = ((st.mat.xy * line.p1.x) + (st.mat.zw * line.p1.y)) + st.translate;\r\n                path_cubic.p0 = p0;\r\n                path_cubic.p1 = mix(p0, p1, vec2(0.3333333432674407958984375));\r\n                path_cubic.p2 = mix(p1, p0, vec2(0.3333333432674407958984375));\r\n                path_cubic.p3 = p1;\r\n                path_cubic.path_ix = st.path_count;\r\n                if (tag == 1u)\r\n                {\r\n                    State param_43 = st;\r\n                    path_cubic.stroke = get_linewidth(param_43);\r\n                }\r\n                else\r\n                {\r\n                    path_cubic.stroke = vec2(0.0);\r\n                }\r\n                path_out_ref = PathSegRef(_2473.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 48u));\r\n                out_tag = uint((tag == 2u) ? 3 : 4);\r\n                param_44.offset = _2473.conf.pathseg_alloc.offset;\r\n                uint param_45 = path_out_ref.offset >> uint(2);\r\n                uint param_46 = out_tag;\r\n                write_mem(param_44, param_45, param_46);\r\n                param_47.offset = _2473.conf.pathseg_alloc.offset;\r\n                PathStrokeCubicRef param_48 = PathStrokeCubicRef(path_out_ref.offset + 4u);\r\n                PathStrokeCubic param_49 = path_cubic;\r\n                PathStrokeCubic_write(param_47, param_48, param_49);\r\n                break;\r\n            }\r\n            case 4u:\r\n            case 3u:\r\n            {\r\n                ElementRef param_50 = this_ref;\r\n                QuadSeg quad = Element_StrokeQuad_read(param_50);\r\n                p0 = ((st.mat.xy * quad.p0.x) + (st.mat.zw * quad.p0.y)) + st.translate;\r\n                p1 = ((st.mat.xy * quad.p1.x) + (st.mat.zw * quad.p1.y)) + st.translate;\r\n                vec2 p2 = ((st.mat.xy * quad.p2.x) + (st.mat.zw * quad.p2.y)) + st.translate;\r\n                path_cubic.p0 = p0;\r\n                path_cubic.p1 = mix(p1, p0, vec2(0.3333333432674407958984375));\r\n                path_cubic.p2 = mix(p1, p2, vec2(0.3333333432674407958984375));\r\n                path_cubic.p3 = p2;\r\n                path_cubic.path_ix = st.path_count;\r\n                if (tag == 3u)\r\n                {\r\n                    State param_51 = st;\r\n                    path_cubic.stroke = get_linewidth(param_51);\r\n                }\r\n                else\r\n                {\r\n                    path_cubic.stroke = vec2(0.0);\r\n                }\r\n                path_out_ref = PathSegRef(_2473.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 48u));\r\n                out_tag = uint((tag == 4u) ? 3 : 4);\r\n                param_52.offset = _2473.conf.pathseg_alloc.offset;\r\n                uint param_53 = path_out_ref.offset >> uint(2);\r\n                uint param_54 = out_tag;\r\n                write_mem(param_52, param_53, param_54);\r\n                param_55.offset = _2473.conf.pathseg_alloc.offset;\r\n                PathStrokeCubicRef param_56 = PathStrokeCubicRef(path_out_ref.offset + 4u);\r\n                PathStrokeCubic param_57 = path_cubic;\r\n                PathStrokeCubic_write(param_55, param_56, param_57);\r\n                break;\r\n            }\r\n            case 6u:\r\n            case 5u:\r\n            {\r\n                ElementRef param_58 = this_ref;\r\n                CubicSeg cubic = Element_StrokeCubic_read(param_58);\r\n                path_cubic.p0 = ((st.mat.xy * cubic.p0.x) + (st.mat.zw * cubic.p0.y)) + st.translate;\r\n                path_cubic.p1 = ((st.mat.xy * cubic.p1.x) + (st.mat.zw * cubic.p1.y)) + st.translate;\r\n                path_cubic.p2 = ((st.mat.xy * cubic.p2.x) + (st.mat.zw * cubic.p2.y)) + st.translate;\r\n                path_cubic.p3 = ((st.mat.xy * cubic.p3.x) + (st.mat.zw * cubic.p3.y)) + st.translate;\r\n                path_cubic.path_ix = st.path_count;\r\n                if (tag == 5u)\r\n                {\r\n                    State param_59 = st;\r\n                    path_cubic.stroke = get_linewidth(param_59);\r\n                }\r\n                else\r\n                {\r\n                    path_cubic.stroke = vec2(0.0);\r\n                }\r\n                path_out_ref = PathSegRef(_2473.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 48u));\r\n                out_tag = uint((tag == 6u) ? 3 : 4);\r\n                param_60.offset = _2473.conf.pathseg_alloc.offset;\r\n                uint param_61 = path_out_ref.offset >> uint(2);\r\n                uint param_62 = out_tag;\r\n                write_mem(param_60, param_61, param_62);\r\n                param_63.offset = _2473.conf.pathseg_alloc.offset;\r\n                PathStrokeCubicRef param_64 = PathStrokeCubicRef(path_out_ref.offset + 4u);\r\n                PathStrokeCubic param_65 = path_cubic;\r\n                PathStrokeCubic_write(param_63, param_64, param_65);\r\n                break;\r\n            }\r\n            case 7u:\r\n            {\r\n                ElementRef param_66 = this_ref;\r\n                Stroke stroke = Element_Stroke_read(param_66);\r\n                anno_stroke.rgba_color = stroke.rgba_color;\r\n                State param_67 = st;\r\n                vec2 lw = get_linewidth(param_67);\r\n                anno_stroke.bbox = st.bbox + vec4(-lw, lw);\r\n                anno_stroke.linewidth = st.linewidth * sqrt(abs((st.mat.x * st.mat.w) - (st.mat.y * st.mat.z)));\r\n                out_ref = AnnotatedRef(_2473.conf.anno_alloc.offset + ((st.path_count - 1u) * 52u));\r\n                param_68.offset = _2473.conf.anno_alloc.offset;\r\n                AnnotatedRef param_69 = out_ref;\r\n                AnnoStroke param_70 = anno_stroke;\r\n                Annotated_Stroke_write(param_68, param_69, param_70);\r\n                break;\r\n            }\r\n            case 8u:\r\n            {\r\n                ElementRef param_71 = this_ref;\r\n                Fill fill = Element_Fill_read(param_71);\r\n                anno_fill.rgba_color = fill.rgba_color;\r\n                anno_fill.bbox = st.bbox;\r\n                out_ref = AnnotatedRef(_2473.conf.anno_alloc.offset + ((st.path_count - 1u) * 52u));\r\n                param_72.offset = _2473.conf.anno_alloc.offset;\r\n                AnnotatedRef param_73 = out_ref;\r\n                AnnoFill param_74 = anno_fill;\r\n                Annotated_Fill_write(param_72, param_73, param_74);\r\n                break;\r\n            }\r\n            case 13u:\r\n            {\r\n                ElementRef param_75 = this_ref;\r\n                FillTexture fill_tex = Element_FillTexture_read(param_75);\r\n                anno_fill_tex.uv_bounds = fill_tex.uv_bounds;\r\n                anno_fill_tex.bbox = st.bbox;\r\n                anno_fill_tex.mat = st.mat;\r\n                anno_fill_tex.translate = st.translate;\r\n                out_ref = AnnotatedRef(_2473.conf.anno_alloc.offset + ((st.path_count - 1u) * 52u));\r\n                param_76.offset = _2473.conf.anno_alloc.offset;\r\n                AnnotatedRef param_77 = out_ref;\r\n                AnnoFillTexture param_78 = anno_fill_tex;\r\n                Annotated_FillTexture_write(param_76, param_77, param_78);\r\n                break;\r\n            }\r\n            case 11u:\r\n            {\r\n                ElementRef param_79 = this_ref;\r\n                Clip begin_clip = Element_BeginClip_read(param_79);\r\n                AnnoClip anno_begin_clip = AnnoClip(begin_clip.bbox);\r\n                anno_begin_clip.bbox = begin_clip.bbox;\r\n                out_ref = AnnotatedRef(_2473.conf.anno_alloc.offset + ((st.path_count - 1u) * 52u));\r\n                param_80.offset = _2473.conf.anno_alloc.offset;\r\n                AnnotatedRef param_81 = out_ref;\r\n                AnnoClip param_82 = anno_begin_clip;\r\n                Annotated_BeginClip_write(param_80, param_81, param_82);\r\n                break;\r\n            }\r\n            case 12u:\r\n            {\r\n                ElementRef param_83 = this_ref;\r\n                Clip end_clip = Element_EndClip_read(param_83);\r\n                AnnoClip anno_end_clip = AnnoClip(end_clip.bbox);\r\n                out_ref = AnnotatedRef(_2473.conf.anno_alloc.offset + ((st.path_count - 1u) * 52u));\r\n                param_84.offset = _2473.conf.anno_alloc.offset;\r\n                AnnotatedRef param_85 = out_ref;\r\n                AnnoClip param_86 = anno_end_clip;\r\n                Annotated_EndClip_write(param_84, param_85, param_86);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n",
	}
	shader_intersect_frag = backend.ShaderSources{
		Name:      "intersect.frag",
		Textures:  []backend.TextureBinding{{Name: "cover", Binding: 0}},
		GLSL100ES: "precision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D cover;\n\nvarying highp vec2 vUV;\n\nvoid main()\n{\n    float cover_1 = abs(texture2D(cover, vUV).x);\n    gl_FragData[0].x = cover_1;\n}\n\n",
		GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D cover;\n\nin highp vec2 vUV;\nlayout(location = 0) out vec4 fragColor;\n\nvoid main()\n{\n    float cover_1 = abs(texture(cover, vUV).x);\n    fragColor.x = cover_1;\n}\n\n",
		GLSL130:   "#version 130\n\nuniform sampler2D cover;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvoid main()\n{\n    float cover_1 = abs(texture(cover, vUV).x);\n    fragColor.x = cover_1;\n}\n\n",
		GLSL150:   "#version 150\n\nuniform sampler2D cover;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvoid main()\n{\n    float cover_1 = abs(texture(cover, vUV).x);\n    fragColor.x = cover_1;\n}\n\n",
		/*
		   Texture2D<float4> cover : register(t0);
		   SamplerState _cover_sampler : register(s0);

		   static float2 vUV;
		   static float4 fragColor;

		   struct SPIRV_Cross_Input
		   {
		       float2 vUV : TEXCOORD0;
		   };

		   struct SPIRV_Cross_Output
		   {
		       float4 fragColor : SV_Target0;
		   };

		   void frag_main()
		   {
		       float cover_1 = abs(cover.Sample(_cover_sampler, vUV).x);
		       fragColor.x = cover_1;
		   }

		   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
		   {
		       vUV = stage_input.vUV;
		       frag_main();
		       SPIRV_Cross_Output stage_output;
		       stage_output.fragColor = fragColor;
		       return stage_output;
		   }

		*/
		HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0xe0, 0xe4, 0x3, 0x8c, 0xac, 0x56, 0x46, 0x82, 0x6c, 0xe7, 0x7c, 0xc3, 0x54, 0xa6, 0x27, 0xef, 0x1, 0x0, 0x0, 0x0, 0x8, 0x3, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xd4, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0xfc, 0x1, 0x0, 0x0, 0xa0, 0x2, 0x0, 0x0, 0xd4, 0x2, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x94, 0x0, 0x0, 0x0, 0x94, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x6c, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x51, 0x0, 0x0, 0x5, 0x0, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x3, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0x23, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xe, 0x80, 0x0, 0x0, 0x0, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0xa4, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x29, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x6, 0x12, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xe2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x71, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6b, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
	}
	shader_intersect_vert = backend.ShaderSources{
		Name:   "intersect.vert",
		Inputs: []backend.InputLocation{{Name: "pos", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 2}},
		Uniforms: backend.UniformsReflection{
			Blocks:    []backend.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []backend.UniformLocation{{Name: "_78.uvTransform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_78.subUVTransform", Type: 0x0, Size: 4, Offset: 16}},
			Size:      32,
		},
		GLSL100ES: "\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 uvTransform;\n    vec4 subUVTransform;\n};\n\nuniform Block _78;\n\nattribute vec2 pos;\nattribute vec2 uv;\nvarying vec2 vUV;\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    vec3 param_1 = vec3(pos, 1.0);\n    vec3 p = transform3x2(param, param_1);\n    gl_Position = vec4(p, 1.0);\n    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_3 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_2, param_3);\n    vUV = (uv3.xy * _78.subUVTransform.xy) + _78.subUVTransform.zw;\n    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_5 = vec3(vUV, 1.0);\n    vUV = transform3x2(param_4, param_5).xy;\n    vUV = (vUV * _78.uvTransform.xy) + _78.uvTransform.zw;\n}\n\n",
		GLSL300ES: "#version 300 es\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nlayout(std140) uniform Block\n{\n    vec4 uvTransform;\n    vec4 subUVTransform;\n} _78;\n\nlayout(location = 0) in vec2 pos;\nlayout(location = 1) in vec2 uv;\nout vec2 vUV;\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    vec3 param_1 = vec3(pos, 1.0);\n    vec3 p = transform3x2(param, param_1);\n    gl_Position = vec4(p, 1.0);\n    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_3 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_2, param_3);\n    vUV = (uv3.xy * _78.subUVTransform.xy) + _78.subUVTransform.zw;\n    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_5 = vec3(vUV, 1.0);\n    vUV = transform3x2(param_4, param_5).xy;\n    vUV = (vUV * _78.uvTransform.xy) + _78.uvTransform.zw;\n}\n\n",
		GLSL130:   "#version 130\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 uvTransform;\n    vec4 subUVTransform;\n};\n\nuniform Block _78;\n\nin vec2 pos;\nin vec2 uv;\nout vec2 vUV;\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    vec3 param_1 = vec3(pos, 1.0);\n    vec3 p = transform3x2(param, param_1);\n    gl_Position = vec4(p, 1.0);\n    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_3 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_2, param_3);\n    vUV = (uv3.xy * _78.subUVTransform.xy) + _78.subUVTransform.zw;\n    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_5 = vec3(vUV, 1.0);\n    vUV = transform3x2(param_4, param_5).xy;\n    vUV = (vUV * _78.uvTransform.xy) + _78.uvTransform.zw;\n}\n\n",
		GLSL150:   "#version 150\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 uvTransform;\n    vec4 subUVTransform;\n};\n\nuniform Block _78;\n\nin vec2 pos;\nin vec2 uv;\nout vec2 vUV;\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    vec3 param_1 = vec3(pos, 1.0);\n    vec3 p = transform3x2(param, param_1);\n    gl_Position = vec4(p, 1.0);\n    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_3 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_2, param_3);\n    vUV = (uv3.xy * _78.subUVTransform.xy) + _78.subUVTransform.zw;\n    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_5 = vec3(vUV, 1.0);\n    vUV = transform3x2(param_4, param_5).xy;\n    vUV = (vUV * _78.uvTransform.xy) + _78.uvTransform.zw;\n}\n\n",
		/*
		   struct m3x2
		   {
		       float3 r0;
		       float3 r1;
		   };

		   static const m3x2 _38 = { float3(1.0f, 0.0f, 0.0f), float3(0.0f, 1.0f, 0.0f) };
		   static const m3x2 _63 = { float3(1.0f, 0.0f, 0.0f), float3(0.0f, -1.0f, 1.0f) };

		   cbuffer Block : register(b0)
		   {
		       float4 _78_uvTransform : packoffset(c0);
		       float4 _78_subUVTransform : packoffset(c1);
		   };


		   static float4 gl_Position;
		   static float2 pos;
		   static float2 uv;
		   static float2 vUV;

		   struct SPIRV_Cross_Input
		   {
		       float2 pos : POSITION;
		       float2 uv : NORMAL;
		   };

		   struct SPIRV_Cross_Output
		   {
		       float2 vUV : TEXCOORD0;
		       float4 gl_Position : SV_Position;
		   };

		   float3 transform3x2(m3x2 t, float3 v)
		   {
		       return float3(dot(t.r0, v), dot(t.r1, v), dot(float3(0.0f, 0.0f, 1.0f), v));
		   }

		   void vert_main()
		   {
		       m3x2 param = _38;
		       float3 param_1 = float3(pos, 1.0f);
		       float3 p = transform3x2(param, param_1);
		       gl_Position = float4(p, 1.0f);
		       m3x2 param_2 = _63;
		       float3 param_3 = float3(uv, 1.0f);
		       float3 uv3 = transform3x2(param_2, param_3);
		       vUV = (uv3.xy * _78_subUVTransform.xy) + _78_subUVTransform.zw;
		       m3x2 param_4 = _63;
		       float3 param_5 = float3(vUV, 1.0f);
		       vUV = transform3x2(param_4, param_5).xy;
		       vUV = (vUV * _78_uvTransform.xy) + _78_uvTransform.zw;
		   }

		   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
		   {
		       pos = stage_input.pos;
		       uv = stage_input.uv;
		       vert_main();
		       SPIRV_Cross_Output stage_output;
		       stage_output.gl_Position = gl_Position;
		       stage_output.vUV = vUV;
		       return stage_output;
		   }

		*/
		HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0x27, 0x8, 0x9f, 0xbf, 0x30, 0xa, 0x5b, 0x38, 0xe, 0x78, 0x0, 0x22, 0xdb, 0x3b, 0x30, 0x54, 0x1, 0x0, 0x0, 0x0, 0xd8, 0x4, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x4c, 0x1, 0x0, 0x0, 0xc4, 0x2, 0x0, 0x0, 0x40, 0x3, 0x0, 0x0, 0x30, 0x4, 0x0, 0x0, 0x80, 0x4, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xc, 0x1, 0x0, 0x0, 0xc, 0x1, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0xd8, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x3, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x1, 0x0, 0x55, 0x90, 0x3, 0x0, 0xe4, 0xa0, 0x3, 0x0, 0xe1, 0xa0, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x3, 0x0, 0xe2, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x2, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0xee, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x4, 0x80, 0x3, 0x0, 0x0, 0xa0, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x8, 0x80, 0x3, 0x0, 0xc9, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0xe0, 0x0, 0x0, 0xec, 0x80, 0x1, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0xee, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x90, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xc, 0xc0, 0x3, 0x0, 0x0, 0xa0, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x70, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x36, 0x0, 0x0, 0x5, 0x52, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0x14, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0xa, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0xa, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0xf, 0x0, 0x0, 0xa, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96, 0x5, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xc2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0xa, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xe8, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xac, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x37, 0x38, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x37, 0x38, 0x5f, 0x73, 0x75, 0x62, 0x55, 0x56, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x48, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x50, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_kernel4_comp = backend.ShaderSources{
		Name:      "kernel4.comp",
		GLSL310ES: "#version 310 es\r\nlayout(local_size_x = 32, local_size_y = 4, local_size_z = 1) in;\r\n\r\nstruct Alloc\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct MallocResult\r\n{\r\n    Alloc alloc;\r\n    bool failed;\r\n};\r\n\r\nstruct CmdCircleRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdCircle\r\n{\r\n    vec2 center;\r\n    float radius;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct CmdStrokeRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdStroke\r\n{\r\n    uint tile_ref;\r\n    float half_width;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct CmdFillRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdFill\r\n{\r\n    uint tile_ref;\r\n    int backdrop;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct CmdFillTextureRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdFillTexture\r\n{\r\n    uint tile_ref;\r\n    int backdrop;\r\n    vec4 mat;\r\n    vec2 translate;\r\n    uvec2 uv_bounds;\r\n};\r\n\r\nstruct CmdBeginClipRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdBeginClip\r\n{\r\n    uint tile_ref;\r\n    int backdrop;\r\n};\r\n\r\nstruct CmdBeginSolidClipRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdBeginSolidClip\r\n{\r\n    float alpha;\r\n};\r\n\r\nstruct CmdEndClipRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdEndClip\r\n{\r\n    float alpha;\r\n};\r\n\r\nstruct CmdSolidRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdSolid\r\n{\r\n    uint rgba_color;\r\n};\r\n\r\nstruct CmdSolidTextureRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdSolidTexture\r\n{\r\n    vec4 mat;\r\n    vec2 translate;\r\n    uvec2 uv_bounds;\r\n};\r\n\r\nstruct CmdSolidMaskRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdSolidMask\r\n{\r\n    float mask;\r\n};\r\n\r\nstruct CmdJumpRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct CmdJump\r\n{\r\n    uint new_ref;\r\n};\r\n\r\nstruct CmdRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct TileSegRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct TileSeg\r\n{\r\n    vec2 origin;\r\n    vec2 vector;\r\n    float y_edge;\r\n    TileSegRef next;\r\n};\r\n\r\nstruct Config\r\n{\r\n    uint n_elements;\r\n    uint n_pathseg;\r\n    uint width_in_tiles;\r\n    uint height_in_tiles;\r\n    Alloc tile_alloc;\r\n    Alloc bin_alloc;\r\n    Alloc ptcl_alloc;\r\n    Alloc pathseg_alloc;\r\n    Alloc anno_alloc;\r\n};\r\n\r\nlayout(binding = 0, std430) buffer Memory\r\n{\r\n    uint mem_offset;\r\n    uint mem_error;\r\n    uint memory[];\r\n} _258;\r\n\r\nlayout(binding = 1, std430) readonly buffer ConfigBuf\r\n{\r\n    Config conf;\r\n} _1374;\r\n\r\nlayout(binding = 3) uniform highp sampler2D atlas;\r\nlayout(binding = 2, rgba8) uniform writeonly highp image2D image;\r\n\r\nshared MallocResult sh_clip_alloc;\r\n\r\nAlloc new_alloc(uint offset, uint size)\r\n{\r\n    Alloc a;\r\n    a.offset = offset;\r\n    return a;\r\n}\r\n\r\nAlloc slice_mem(Alloc a, uint offset, uint size)\r\n{\r\n    uint param = a.offset + offset;\r\n    uint param_1 = size;\r\n    return new_alloc(param, param_1);\r\n}\r\n\r\nbool touch_mem(Alloc alloc, uint offset)\r\n{\r\n    return true;\r\n}\r\n\r\nuint read_mem(Alloc alloc, uint offset)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return 0u;\r\n    }\r\n    uint v = _258.memory[offset];\r\n    return v;\r\n}\r\n\r\nuint Cmd_tag(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    return read_mem(param, param_1);\r\n}\r\n\r\nCmdCircle CmdCircle_read(Alloc a, CmdCircleRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    CmdCircle s;\r\n    s.center = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\r\n    s.radius = uintBitsToFloat(raw2);\r\n    s.rgba_color = raw3;\r\n    return s;\r\n}\r\n\r\nCmdCircle Cmd_Circle_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdCircleRef param_1 = CmdCircleRef(ref.offset + 4u);\r\n    return CmdCircle_read(param, param_1);\r\n}\r\n\r\nvec4 unpacksRGB(uint srgba)\r\n{\r\n    vec4 color = unpackUnorm4x8(srgba).wzyx;\r\n    vec3 rgb = color.xyz;\r\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));\r\n    vec3 below = rgb / vec3(12.9200000762939453125);\r\n    vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));\r\n    rgb = mix(below, above, cutoff);\r\n    return vec4(rgb, color.w);\r\n}\r\n\r\nCmdStroke CmdStroke_read(Alloc a, CmdStrokeRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    CmdStroke s;\r\n    s.tile_ref = raw0;\r\n    s.half_width = uintBitsToFloat(raw1);\r\n    s.rgba_color = raw2;\r\n    return s;\r\n}\r\n\r\nCmdStroke Cmd_Stroke_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdStrokeRef param_1 = CmdStrokeRef(ref.offset + 4u);\r\n    return CmdStroke_read(param, param_1);\r\n}\r\n\r\nTileSeg TileSeg_read(Alloc a, TileSegRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    Alloc param_10 = a;\r\n    uint param_11 = ix + 5u;\r\n    uint raw5 = read_mem(param_10, param_11);\r\n    TileSeg s;\r\n    s.origin = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\r\n    s.vector = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.y_edge = uintBitsToFloat(raw4);\r\n    s.next = TileSegRef(raw5);\r\n    return s;\r\n}\r\n\r\nCmdFill CmdFill_read(Alloc a, CmdFillRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    CmdFill s;\r\n    s.tile_ref = raw0;\r\n    s.backdrop = int(raw1);\r\n    s.rgba_color = raw2;\r\n    return s;\r\n}\r\n\r\nCmdFill Cmd_Fill_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdFillRef param_1 = CmdFillRef(ref.offset + 4u);\r\n    return CmdFill_read(param, param_1);\r\n}\r\n\r\nfloat[8] computeArea(vec2 xy, int backdrop, uint tile_ref)\r\n{\r\n    float area[8];\r\n    for (uint k = 0u; k < 8u; k++)\r\n    {\r\n        area[k] = float(backdrop);\r\n    }\r\n    TileSegRef tile_seg_ref = TileSegRef(tile_ref);\r\n    do\r\n    {\r\n        uint param = tile_seg_ref.offset;\r\n        uint param_1 = 24u;\r\n        Alloc param_2 = new_alloc(param, param_1);\r\n        TileSegRef param_3 = tile_seg_ref;\r\n        TileSeg seg = TileSeg_read(param_2, param_3);\r\n        for (uint k_1 = 0u; k_1 < 8u; k_1++)\r\n        {\r\n            vec2 my_xy = vec2(xy.x, xy.y + float(k_1 * 4u));\r\n            vec2 start = seg.origin - my_xy;\r\n            vec2 end = start + seg.vector;\r\n            vec2 window = clamp(vec2(start.y, end.y), vec2(0.0), vec2(1.0));\r\n            if (!(window.x == window.y))\r\n            {\r\n                vec2 t = (window - vec2(start.y)) / vec2(seg.vector.y);\r\n                vec2 xs = vec2(mix(start.x, end.x, t.x), mix(start.x, end.x, t.y));\r\n                float xmin = min(min(xs.x, xs.y), 1.0) - 9.9999999747524270787835121154785e-07;\r\n                float xmax = max(xs.x, xs.y);\r\n                float b = min(xmax, 1.0);\r\n                float c = max(b, 0.0);\r\n                float d = max(xmin, 0.0);\r\n                float a = ((b + (0.5 * ((d * d) - (c * c)))) - xmin) / (xmax - xmin);\r\n                area[k_1] += (a * (window.x - window.y));\r\n            }\r\n            area[k_1] += (sign(seg.vector.x) * clamp((my_xy.y - seg.y_edge) + 1.0, 0.0, 1.0));\r\n        }\r\n        tile_seg_ref = seg.next;\r\n    } while (tile_seg_ref.offset != 0u);\r\n    for (uint k_2 = 0u; k_2 < 8u; k_2++)\r\n    {\r\n        area[k_2] = min(abs(area[k_2]), 1.0);\r\n    }\r\n    return area;\r\n}\r\n\r\nCmdFillTexture CmdFillTexture_read(Alloc a, CmdFillTextureRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    Alloc param_10 = a;\r\n    uint param_11 = ix + 5u;\r\n    uint raw5 = read_mem(param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 6u;\r\n    uint raw6 = read_mem(param_12, param_13);\r\n    Alloc param_14 = a;\r\n    uint param_15 = ix + 7u;\r\n    uint raw7 = read_mem(param_14, param_15);\r\n    Alloc param_16 = a;\r\n    uint param_17 = ix + 8u;\r\n    uint raw8 = read_mem(param_16, param_17);\r\n    Alloc param_18 = a;\r\n    uint param_19 = ix + 9u;\r\n    uint raw9 = read_mem(param_18, param_19);\r\n    CmdFillTexture s;\r\n    s.tile_ref = raw0;\r\n    s.backdrop = int(raw1);\r\n    s.mat = vec4(uintBitsToFloat(raw2), uintBitsToFloat(raw3), uintBitsToFloat(raw4), uintBitsToFloat(raw5));\r\n    s.translate = vec2(uintBitsToFloat(raw6), uintBitsToFloat(raw7));\r\n    s.uv_bounds = uvec2(raw8, raw9);\r\n    return s;\r\n}\r\n\r\nCmdFillTexture Cmd_FillTexture_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdFillTextureRef param_1 = CmdFillTextureRef(ref.offset + 4u);\r\n    return CmdFillTexture_read(param, param_1);\r\n}\r\n\r\nvec4[8] fillTexture(vec2 xy, CmdSolidTexture cmd_tex)\r\n{\r\n    vec2 uvmin = unpackUnorm2x16(cmd_tex.uv_bounds.x);\r\n    vec2 uvmax = unpackUnorm2x16(cmd_tex.uv_bounds.y);\r\n    vec4 rgba[8];\r\n    for (uint i = 0u; i < 8u; i++)\r\n    {\r\n        float dy = float(i * 4u);\r\n        vec2 uv = vec2(xy.x, xy.y + dy) + vec2(0.5);\r\n        uv = ((cmd_tex.mat.xy * uv.x) + (cmd_tex.mat.zw * uv.y)) + cmd_tex.translate;\r\n        uv = clamp(uv, uvmin, uvmax);\r\n        vec4 fg_rgba = textureGrad(atlas, uv, cmd_tex.mat.xy, cmd_tex.mat.zw);\r\n        rgba[i] = fg_rgba;\r\n    }\r\n    return rgba;\r\n}\r\n\r\nMallocResult malloc(uint size)\r\n{\r\n    MallocResult r;\r\n    r.failed = false;\r\n    uint _264 = atomicAdd(_258.mem_offset, size);\r\n    uint offset = _264;\r\n    uint param = offset;\r\n    uint param_1 = size;\r\n    r.alloc = new_alloc(param, param_1);\r\n    if ((offset + size) > uint(int(uint(_258.memory.length())) * 4))\r\n    {\r\n        r.failed = true;\r\n        uint _285 = atomicMax(_258.mem_error, 1u);\r\n        return r;\r\n    }\r\n    return r;\r\n}\r\n\r\nvoid write_mem(Alloc alloc, uint offset, uint val)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return;\r\n    }\r\n    _258.memory[offset] = val;\r\n}\r\n\r\nMallocResult alloc_clip_buf(uint link)\r\n{\r\n    bool _967 = gl_LocalInvocationID.x == 0u;\r\n    bool _973;\r\n    if (_967)\r\n    {\r\n        _973 = gl_LocalInvocationID.y == 0u;\r\n    }\r\n    else\r\n    {\r\n        _973 = _967;\r\n    }\r\n    if (_973)\r\n    {\r\n        uint param = 4100u;\r\n        MallocResult _979 = malloc(param);\r\n        MallocResult m = _979;\r\n        if (!m.failed)\r\n        {\r\n            Alloc param_1 = m.alloc;\r\n            uint param_2 = (m.alloc.offset >> uint(2)) + 1024u;\r\n            uint param_3 = link;\r\n            write_mem(param_1, param_2, param_3);\r\n        }\r\n        sh_clip_alloc = m;\r\n    }\r\n    barrier();\r\n    return sh_clip_alloc;\r\n}\r\n\r\nCmdBeginClip CmdBeginClip_read(Alloc a, CmdBeginClipRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    CmdBeginClip s;\r\n    s.tile_ref = raw0;\r\n    s.backdrop = int(raw1);\r\n    return s;\r\n}\r\n\r\nCmdBeginClip Cmd_BeginClip_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdBeginClipRef param_1 = CmdBeginClipRef(ref.offset + 4u);\r\n    return CmdBeginClip_read(param, param_1);\r\n}\r\n\r\nvec3 tosRGB(vec3 rgb)\r\n{\r\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));\r\n    vec3 below = vec3(12.9200000762939453125) * rgb;\r\n    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);\r\n    return mix(below, above, cutoff);\r\n}\r\n\r\nuint packsRGB(inout vec4 rgba)\r\n{\r\n    vec3 param = rgba.xyz;\r\n    rgba = vec4(tosRGB(param), rgba.w);\r\n    return packUnorm4x8(rgba.wzyx);\r\n}\r\n\r\nCmdBeginSolidClip CmdBeginSolidClip_read(Alloc a, CmdBeginSolidClipRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    CmdBeginSolidClip s;\r\n    s.alpha = uintBitsToFloat(raw0);\r\n    return s;\r\n}\r\n\r\nCmdBeginSolidClip Cmd_BeginSolidClip_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdBeginSolidClipRef param_1 = CmdBeginSolidClipRef(ref.offset + 4u);\r\n    return CmdBeginSolidClip_read(param, param_1);\r\n}\r\n\r\nCmdEndClip CmdEndClip_read(Alloc a, CmdEndClipRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    CmdEndClip s;\r\n    s.alpha = uintBitsToFloat(raw0);\r\n    return s;\r\n}\r\n\r\nCmdEndClip Cmd_EndClip_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdEndClipRef param_1 = CmdEndClipRef(ref.offset + 4u);\r\n    return CmdEndClip_read(param, param_1);\r\n}\r\n\r\nCmdSolid CmdSolid_read(Alloc a, CmdSolidRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    CmdSolid s;\r\n    s.rgba_color = raw0;\r\n    return s;\r\n}\r\n\r\nCmdSolid Cmd_Solid_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdSolidRef param_1 = CmdSolidRef(ref.offset + 4u);\r\n    return CmdSolid_read(param, param_1);\r\n}\r\n\r\nCmdSolidTexture CmdSolidTexture_read(Alloc a, CmdSolidTextureRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    Alloc param_10 = a;\r\n    uint param_11 = ix + 5u;\r\n    uint raw5 = read_mem(param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 6u;\r\n    uint raw6 = read_mem(param_12, param_13);\r\n    Alloc param_14 = a;\r\n    uint param_15 = ix + 7u;\r\n    uint raw7 = read_mem(param_14, param_15);\r\n    CmdSolidTexture s;\r\n    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\r\n    s.uv_bounds = uvec2(raw6, raw7);\r\n    return s;\r\n}\r\n\r\nCmdSolidTexture Cmd_SolidTexture_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdSolidTextureRef param_1 = CmdSolidTextureRef(ref.offset + 4u);\r\n    return CmdSolidTexture_read(param, param_1);\r\n}\r\n\r\nCmdSolidMask CmdSolidMask_read(Alloc a, CmdSolidMaskRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    CmdSolidMask s;\r\n    s.mask = uintBitsToFloat(raw0);\r\n    return s;\r\n}\r\n\r\nCmdSolidMask Cmd_SolidMask_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdSolidMaskRef param_1 = CmdSolidMaskRef(ref.offset + 4u);\r\n    return CmdSolidMask_read(param, param_1);\r\n}\r\n\r\nCmdJump CmdJump_read(Alloc a, CmdJumpRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    CmdJump s;\r\n    s.new_ref = raw0;\r\n    return s;\r\n}\r\n\r\nCmdJump Cmd_Jump_read(Alloc a, CmdRef ref)\r\n{\r\n    Alloc param = a;\r\n    CmdJumpRef param_1 = CmdJumpRef(ref.offset + 4u);\r\n    return CmdJump_read(param, param_1);\r\n}\r\n\r\nvoid main()\r\n{\r\n    if (_258.mem_error != 0u)\r\n    {\r\n        return;\r\n    }\r\n    uint tile_ix = (gl_WorkGroupID.y * _1374.conf.width_in_tiles) + gl_WorkGroupID.x;\r\n    Alloc param;\r\n    param.offset = _1374.conf.ptcl_alloc.offset;\r\n    uint param_1 = tile_ix * 1024u;\r\n    uint param_2 = 1024u;\r\n    Alloc cmd_alloc = slice_mem(param, param_1, param_2);\r\n    CmdRef cmd_ref = CmdRef(cmd_alloc.offset);\r\n    uvec2 xy_uint = uvec2(gl_GlobalInvocationID.x, gl_LocalInvocationID.y + (32u * gl_WorkGroupID.y));\r\n    vec2 xy = vec2(xy_uint);\r\n    uint blend_spill = 0u;\r\n    uint blend_sp = 0u;\r\n    uint param_3 = 0u;\r\n    uint param_4 = 0u;\r\n    Alloc clip_tos = new_alloc(param_3, param_4);\r\n    vec3 rgb[8];\r\n    float mask[8];\r\n    for (uint i = 0u; i < 8u; i++)\r\n    {\r\n        rgb[i] = vec3(0.5);\r\n        mask[i] = 1.0;\r\n    }\r\n    vec4 fg_rgba;\r\n    float df[8];\r\n    float area[8];\r\n    vec4 rgba[8];\r\n    uint blend_slot;\r\n    uint blend_stack[4][8];\r\n    while (true)\r\n    {\r\n        Alloc param_5 = cmd_alloc;\r\n        CmdRef param_6 = cmd_ref;\r\n        uint tag = Cmd_tag(param_5, param_6);\r\n        if (tag == 0u)\r\n        {\r\n            break;\r\n        }\r\n        switch (tag)\r\n        {\r\n            case 1u:\r\n            {\r\n                Alloc param_7 = cmd_alloc;\r\n                CmdRef param_8 = cmd_ref;\r\n                CmdCircle circle = Cmd_Circle_read(param_7, param_8);\r\n                uint param_9 = circle.rgba_color;\r\n                fg_rgba = unpacksRGB(param_9);\r\n                for (uint i_1 = 0u; i_1 < 8u; i_1++)\r\n                {\r\n                    float dy = float(i_1 * 4u);\r\n                    float r = length((vec2(xy.x, xy.y + dy) + vec2(0.5)) - circle.center);\r\n                    float alpha = clamp((0.5 + circle.radius) - r, 0.0, 1.0);\r\n                    rgb[i_1] = mix(rgb[i_1], fg_rgba.xyz, vec3((mask[i_1] * alpha) * fg_rgba.w));\r\n                }\r\n                break;\r\n            }\r\n            case 8u:\r\n            {\r\n                Alloc param_10 = cmd_alloc;\r\n                CmdRef param_11 = cmd_ref;\r\n                CmdStroke stroke = Cmd_Stroke_read(param_10, param_11);\r\n                for (uint k = 0u; k < 8u; k++)\r\n                {\r\n                    df[k] = 1000000000.0;\r\n                }\r\n                TileSegRef tile_seg_ref = TileSegRef(stroke.tile_ref);\r\n                do\r\n                {\r\n                    uint param_12 = tile_seg_ref.offset;\r\n                    uint param_13 = 24u;\r\n                    Alloc param_14 = new_alloc(param_12, param_13);\r\n                    TileSegRef param_15 = tile_seg_ref;\r\n                    TileSeg seg = TileSeg_read(param_14, param_15);\r\n                    vec2 line_vec = seg.vector;\r\n                    for (uint k_1 = 0u; k_1 < 8u; k_1++)\r\n                    {\r\n                        vec2 dpos = (xy + vec2(0.5)) - seg.origin;\r\n                        dpos.y += float(k_1 * 4u);\r\n                        float t = clamp(dot(line_vec, dpos) / dot(line_vec, line_vec), 0.0, 1.0);\r\n                        df[k_1] = min(df[k_1], length((line_vec * t) - dpos));\r\n                    }\r\n                    tile_seg_ref = seg.next;\r\n                } while (tile_seg_ref.offset != 0u);\r\n                uint param_16 = stroke.rgba_color;\r\n                fg_rgba = unpacksRGB(param_16);\r\n                for (uint k_2 = 0u; k_2 < 8u; k_2++)\r\n                {\r\n                    float alpha_1 = clamp((stroke.half_width + 0.5) - df[k_2], 0.0, 1.0);\r\n                    rgb[k_2] = mix(rgb[k_2], fg_rgba.xyz, vec3((mask[k_2] * alpha_1) * fg_rgba.w));\r\n                }\r\n                break;\r\n            }\r\n            case 3u:\r\n            {\r\n                Alloc param_17 = cmd_alloc;\r\n                CmdRef param_18 = cmd_ref;\r\n                CmdFill fill = Cmd_Fill_read(param_17, param_18);\r\n                vec2 param_19 = xy;\r\n                int param_20 = fill.backdrop;\r\n                uint param_21 = fill.tile_ref;\r\n                area = computeArea(param_19, param_20, param_21);\r\n                uint param_22 = fill.rgba_color;\r\n                fg_rgba = unpacksRGB(param_22);\r\n                for (uint k_3 = 0u; k_3 < 8u; k_3++)\r\n                {\r\n                    rgb[k_3] = mix(rgb[k_3], fg_rgba.xyz, vec3((mask[k_3] * area[k_3]) * fg_rgba.w));\r\n                }\r\n                break;\r\n            }\r\n            case 4u:\r\n            {\r\n                Alloc param_23 = cmd_alloc;\r\n                CmdRef param_24 = cmd_ref;\r\n                CmdFillTexture fill_tex = Cmd_FillTexture_read(param_23, param_24);\r\n                vec2 param_25 = xy;\r\n                int param_26 = fill_tex.backdrop;\r\n                uint param_27 = fill_tex.tile_ref;\r\n                area = computeArea(param_25, param_26, param_27);\r\n                vec2 param_28 = xy;\r\n                CmdSolidTexture param_29 = CmdSolidTexture(fill_tex.mat, fill_tex.translate, fill_tex.uv_bounds);\r\n                rgba = fillTexture(param_28, param_29);\r\n                for (uint k_4 = 0u; k_4 < 8u; k_4++)\r\n                {\r\n                    rgb[k_4] = mix(rgb[k_4], rgba[k_4].xyz, vec3((mask[k_4] * area[k_4]) * rgba[k_4].w));\r\n                }\r\n                break;\r\n            }\r\n            case 5u:\r\n            case 6u:\r\n            {\r\n                blend_slot = blend_sp % 4u;\r\n                if (blend_sp == (blend_spill + 4u))\r\n                {\r\n                    uint param_30 = clip_tos.offset;\r\n                    MallocResult _1783 = alloc_clip_buf(param_30);\r\n                    MallocResult m = _1783;\r\n                    if (m.failed)\r\n                    {\r\n                        return;\r\n                    }\r\n                    clip_tos = m.alloc;\r\n                    uint base_ix = ((clip_tos.offset >> uint(2)) + gl_LocalInvocationID.x) + (32u * gl_LocalInvocationID.y);\r\n                    for (uint k_5 = 0u; k_5 < 8u; k_5++)\r\n                    {\r\n                        Alloc param_31 = clip_tos;\r\n                        uint param_32 = base_ix + ((k_5 * 32u) * 4u);\r\n                        uint param_33 = blend_stack[blend_slot][k_5];\r\n                        write_mem(param_31, param_32, param_33);\r\n                    }\r\n                    blend_spill++;\r\n                }\r\n                if (tag == 5u)\r\n                {\r\n                    Alloc param_34 = cmd_alloc;\r\n                    CmdRef param_35 = cmd_ref;\r\n                    CmdBeginClip begin_clip = Cmd_BeginClip_read(param_34, param_35);\r\n                    vec2 param_36 = xy;\r\n                    int param_37 = begin_clip.backdrop;\r\n                    uint param_38 = begin_clip.tile_ref;\r\n                    area = computeArea(param_36, param_37, param_38);\r\n                    for (uint k_6 = 0u; k_6 < 8u; k_6++)\r\n                    {\r\n                        vec4 param_39 = vec4(rgb[k_6], clamp(abs(area[k_6]), 0.0, 1.0));\r\n                        uint _1874 = packsRGB(param_39);\r\n                        blend_stack[blend_slot][k_6] = _1874;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    Alloc param_40 = cmd_alloc;\r\n                    CmdRef param_41 = cmd_ref;\r\n                    CmdBeginSolidClip begin_solid_clip = Cmd_BeginSolidClip_read(param_40, param_41);\r\n                    float solid_alpha = begin_solid_clip.alpha;\r\n                    for (uint k_7 = 0u; k_7 < 8u; k_7++)\r\n                    {\r\n                        vec4 param_42 = vec4(rgb[k_7], solid_alpha);\r\n                        uint _1907 = packsRGB(param_42);\r\n                        blend_stack[blend_slot][k_7] = _1907;\r\n                    }\r\n                }\r\n                blend_sp++;\r\n                break;\r\n            }\r\n            case 7u:\r\n            {\r\n                Alloc param_43 = cmd_alloc;\r\n                CmdRef param_44 = cmd_ref;\r\n                CmdEndClip end_clip = Cmd_EndClip_read(param_43, param_44);\r\n                blend_slot = (blend_sp - 1u) % 4u;\r\n                if (blend_sp == blend_spill)\r\n                {\r\n                    uint base_ix_1 = ((clip_tos.offset >> uint(2)) + gl_LocalInvocationID.x) + (32u * gl_LocalInvocationID.y);\r\n                    for (uint k_8 = 0u; k_8 < 8u; k_8++)\r\n                    {\r\n                        Alloc param_45 = clip_tos;\r\n                        uint param_46 = base_ix_1 + ((k_8 * 32u) * 4u);\r\n                        blend_stack[blend_slot][k_8] = read_mem(param_45, param_46);\r\n                    }\r\n                    Alloc param_47 = clip_tos;\r\n                    uint param_48 = (clip_tos.offset >> uint(2)) + 1024u;\r\n                    clip_tos.offset = read_mem(param_47, param_48);\r\n                    blend_spill--;\r\n                }\r\n                blend_sp--;\r\n                for (uint k_9 = 0u; k_9 < 8u; k_9++)\r\n                {\r\n                    uint param_49 = blend_stack[blend_slot][k_9];\r\n                    vec4 rgba_1 = unpacksRGB(param_49);\r\n                    rgb[k_9] = mix(rgba_1.xyz, rgb[k_9], vec3(end_clip.alpha * rgba_1.w));\r\n                }\r\n                break;\r\n            }\r\n            case 9u:\r\n            {\r\n                Alloc param_50 = cmd_alloc;\r\n                CmdRef param_51 = cmd_ref;\r\n                CmdSolid solid = Cmd_Solid_read(param_50, param_51);\r\n                uint param_52 = solid.rgba_color;\r\n                fg_rgba = unpacksRGB(param_52);\r\n                for (uint k_10 = 0u; k_10 < 8u; k_10++)\r\n                {\r\n                    rgb[k_10] = mix(rgb[k_10], fg_rgba.xyz, vec3(mask[k_10] * fg_rgba.w));\r\n                }\r\n                break;\r\n            }\r\n            case 11u:\r\n            {\r\n                Alloc param_53 = cmd_alloc;\r\n                CmdRef param_54 = cmd_ref;\r\n                CmdSolidTexture solid_tex = Cmd_SolidTexture_read(param_53, param_54);\r\n                vec2 param_55 = xy;\r\n                CmdSolidTexture param_56 = solid_tex;\r\n                rgba = fillTexture(param_55, param_56);\r\n                for (uint k_11 = 0u; k_11 < 8u; k_11++)\r\n                {\r\n                    rgb[k_11] = mix(rgb[k_11], rgba[k_11].xyz, vec3(mask[k_11] * rgba[k_11].w));\r\n                }\r\n                break;\r\n            }\r\n            case 10u:\r\n            {\r\n                Alloc param_57 = cmd_alloc;\r\n                CmdRef param_58 = cmd_ref;\r\n                CmdSolidMask solid_mask = Cmd_SolidMask_read(param_57, param_58);\r\n                for (uint k_12 = 0u; k_12 < 8u; k_12++)\r\n                {\r\n                    mask[k_12] = solid_mask.mask;\r\n                }\r\n                break;\r\n            }\r\n            case 12u:\r\n            {\r\n                Alloc param_59 = cmd_alloc;\r\n                CmdRef param_60 = cmd_ref;\r\n                cmd_ref = CmdRef(Cmd_Jump_read(param_59, param_60).new_ref);\r\n                cmd_alloc.offset = cmd_ref.offset;\r\n                continue;\r\n            }\r\n        }\r\n        cmd_ref.offset += 44u;\r\n    }\r\n    for (uint i_2 = 0u; i_2 < 8u; i_2++)\r\n    {\r\n        vec3 param_61 = rgb[i_2];\r\n        imageStore(image, ivec2(int(xy_uint.x), int(xy_uint.y + (4u * i_2))), vec4(tosRGB(param_61), 1.0));\r\n    }\r\n}\r\n\r\n",
	}
	shader_path_coarse_comp = backend.ShaderSources{
		Name:      "path_coarse.comp",
		GLSL310ES: "#version 310 es\r\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;\r\n\r\nstruct Alloc\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct MallocResult\r\n{\r\n    Alloc alloc;\r\n    bool failed;\r\n};\r\n\r\nstruct PathStrokeCubicRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct PathStrokeCubic\r\n{\r\n    vec2 p0;\r\n    vec2 p1;\r\n    vec2 p2;\r\n    vec2 p3;\r\n    uint path_ix;\r\n    vec2 stroke;\r\n};\r\n\r\nstruct PathSegRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct TileRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct PathRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Path\r\n{\r\n    uvec4 bbox;\r\n    TileRef tiles;\r\n};\r\n\r\nstruct TileSegRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct TileSeg\r\n{\r\n    vec2 origin;\r\n    vec2 vector;\r\n    float y_edge;\r\n    TileSegRef next;\r\n};\r\n\r\nstruct SubdivResult\r\n{\r\n    float val;\r\n    float a0;\r\n    float a2;\r\n};\r\n\r\nstruct Config\r\n{\r\n    uint n_elements;\r\n    uint n_pathseg;\r\n    uint width_in_tiles;\r\n    uint height_in_tiles;\r\n    Alloc tile_alloc;\r\n    Alloc bin_alloc;\r\n    Alloc ptcl_alloc;\r\n    Alloc pathseg_alloc;\r\n    Alloc anno_alloc;\r\n};\r\n\r\nlayout(binding = 0, std430) buffer Memory\r\n{\r\n    uint mem_offset;\r\n    uint mem_error;\r\n    uint memory[];\r\n} _135;\r\n\r\nlayout(binding = 1, std430) readonly buffer ConfigBuf\r\n{\r\n    Config conf;\r\n} _685;\r\n\r\nbool touch_mem(Alloc alloc, uint offset)\r\n{\r\n    return true;\r\n}\r\n\r\nuint read_mem(Alloc alloc, uint offset)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return 0u;\r\n    }\r\n    uint v = _135.memory[offset];\r\n    return v;\r\n}\r\n\r\nuint PathSeg_tag(Alloc a, PathSegRef ref)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    return read_mem(param, param_1);\r\n}\r\n\r\nPathStrokeCubic PathStrokeCubic_read(Alloc a, PathStrokeCubicRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    Alloc param_10 = a;\r\n    uint param_11 = ix + 5u;\r\n    uint raw5 = read_mem(param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 6u;\r\n    uint raw6 = read_mem(param_12, param_13);\r\n    Alloc param_14 = a;\r\n    uint param_15 = ix + 7u;\r\n    uint raw7 = read_mem(param_14, param_15);\r\n    Alloc param_16 = a;\r\n    uint param_17 = ix + 8u;\r\n    uint raw8 = read_mem(param_16, param_17);\r\n    Alloc param_18 = a;\r\n    uint param_19 = ix + 9u;\r\n    uint raw9 = read_mem(param_18, param_19);\r\n    Alloc param_20 = a;\r\n    uint param_21 = ix + 10u;\r\n    uint raw10 = read_mem(param_20, param_21);\r\n    PathStrokeCubic s;\r\n    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\r\n    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\r\n    s.p3 = vec2(uintBitsToFloat(raw6), uintBitsToFloat(raw7));\r\n    s.path_ix = raw8;\r\n    s.stroke = vec2(uintBitsToFloat(raw9), uintBitsToFloat(raw10));\r\n    return s;\r\n}\r\n\r\nPathStrokeCubic PathSeg_StrokeCubic_read(Alloc a, PathSegRef ref)\r\n{\r\n    Alloc param = a;\r\n    PathStrokeCubicRef param_1 = PathStrokeCubicRef(ref.offset + 4u);\r\n    return PathStrokeCubic_read(param, param_1);\r\n}\r\n\r\nvec2 eval_cubic(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\r\n{\r\n    float mt = 1.0 - t;\r\n    return (p0 * ((mt * mt) * mt)) + (((p1 * ((mt * mt) * 3.0)) + (((p2 * (mt * 3.0)) + (p3 * t)) * t)) * t);\r\n}\r\n\r\nfloat approx_parabola_integral(float x)\r\n{\r\n    return x * inversesqrt(sqrt(0.3300000131130218505859375 + (0.201511204242706298828125 + ((0.25 * x) * x))));\r\n}\r\n\r\nSubdivResult estimate_subdiv(vec2 p0, vec2 p1, vec2 p2, float sqrt_tol)\r\n{\r\n    vec2 d01 = p1 - p0;\r\n    vec2 d12 = p2 - p1;\r\n    vec2 dd = d01 - d12;\r\n    float _cross = ((p2.x - p0.x) * dd.y) - ((p2.y - p0.y) * dd.x);\r\n    float x0 = ((d01.x * dd.x) + (d01.y * dd.y)) / _cross;\r\n    float x2 = ((d12.x * dd.x) + (d12.y * dd.y)) / _cross;\r\n    float scale = abs(_cross / (length(dd) * (x2 - x0)));\r\n    float param = x0;\r\n    float a0 = approx_parabola_integral(param);\r\n    float param_1 = x2;\r\n    float a2 = approx_parabola_integral(param_1);\r\n    float val = 0.0;\r\n    if (scale < 1000000000.0)\r\n    {\r\n        float da = abs(a2 - a0);\r\n        float sqrt_scale = sqrt(scale);\r\n        if (sign(x0) == sign(x2))\r\n        {\r\n            val = da * sqrt_scale;\r\n        }\r\n        else\r\n        {\r\n            float xmin = sqrt_tol / sqrt_scale;\r\n            float param_2 = xmin;\r\n            val = (sqrt_tol * da) / approx_parabola_integral(param_2);\r\n        }\r\n    }\r\n    return SubdivResult(val, a0, a2);\r\n}\r\n\r\nPath Path_read(Alloc a, PathRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Path s;\r\n    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));\r\n    s.tiles = TileRef(raw2);\r\n    return s;\r\n}\r\n\r\nAlloc new_alloc(uint offset, uint size)\r\n{\r\n    Alloc a;\r\n    a.offset = offset;\r\n    return a;\r\n}\r\n\r\nfloat approx_parabola_inv_integral(float x)\r\n{\r\n    return x * sqrt(0.61000001430511474609375 + (0.1520999968051910400390625 + ((0.25 * x) * x)));\r\n}\r\n\r\nvec2 eval_quad(vec2 p0, vec2 p1, vec2 p2, float t)\r\n{\r\n    float mt = 1.0 - t;\r\n    return (p0 * (mt * mt)) + (((p1 * (mt * 2.0)) + (p2 * t)) * t);\r\n}\r\n\r\nMallocResult malloc(uint size)\r\n{\r\n    MallocResult r;\r\n    r.failed = false;\r\n    uint _141 = atomicAdd(_135.mem_offset, size);\r\n    uint offset = _141;\r\n    uint param = offset;\r\n    uint param_1 = size;\r\n    r.alloc = new_alloc(param, param_1);\r\n    if ((offset + size) > uint(int(uint(_135.memory.length())) * 4))\r\n    {\r\n        r.failed = true;\r\n        uint _162 = atomicMax(_135.mem_error, 1u);\r\n        return r;\r\n    }\r\n    return r;\r\n}\r\n\r\nTileRef Tile_index(TileRef ref, uint index)\r\n{\r\n    return TileRef(ref.offset + (index * 8u));\r\n}\r\n\r\nvoid write_mem(Alloc alloc, uint offset, uint val)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return;\r\n    }\r\n    _135.memory[offset] = val;\r\n}\r\n\r\nvoid TileSeg_write(Alloc a, TileSegRef ref, TileSeg s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = floatBitsToUint(s.origin.x);\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = floatBitsToUint(s.origin.y);\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = floatBitsToUint(s.vector.x);\r\n    write_mem(param_6, param_7, param_8);\r\n    Alloc param_9 = a;\r\n    uint param_10 = ix + 3u;\r\n    uint param_11 = floatBitsToUint(s.vector.y);\r\n    write_mem(param_9, param_10, param_11);\r\n    Alloc param_12 = a;\r\n    uint param_13 = ix + 4u;\r\n    uint param_14 = floatBitsToUint(s.y_edge);\r\n    write_mem(param_12, param_13, param_14);\r\n    Alloc param_15 = a;\r\n    uint param_16 = ix + 5u;\r\n    uint param_17 = s.next.offset;\r\n    write_mem(param_15, param_16, param_17);\r\n}\r\n\r\nvoid main()\r\n{\r\n    if (_135.mem_error != 0u)\r\n    {\r\n        return;\r\n    }\r\n    uint element_ix = gl_GlobalInvocationID.x;\r\n    PathSegRef ref = PathSegRef(_685.conf.pathseg_alloc.offset + (element_ix * 48u));\r\n    uint tag = 0u;\r\n    if (element_ix < _685.conf.n_pathseg)\r\n    {\r\n        Alloc param;\r\n        param.offset = _685.conf.pathseg_alloc.offset;\r\n        PathSegRef param_1 = ref;\r\n        tag = PathSeg_tag(param, param_1);\r\n    }\r\n    switch (tag)\r\n    {\r\n        case 3u:\r\n        case 4u:\r\n        {\r\n            Alloc param_2;\r\n            param_2.offset = _685.conf.pathseg_alloc.offset;\r\n            PathSegRef param_3 = ref;\r\n            PathStrokeCubic cubic = PathSeg_StrokeCubic_read(param_2, param_3);\r\n            vec2 err_v = (((cubic.p2 - cubic.p1) * 3.0) + cubic.p0) - cubic.p3;\r\n            float err = (err_v.x * err_v.x) + (err_v.y * err_v.y);\r\n            uint n_quads = max(uint(ceil(pow(err * 3.7037036418914794921875, 0.16666667163372039794921875))), 1u);\r\n            float val = 0.0;\r\n            vec2 qp0 = cubic.p0;\r\n            float _step = 1.0 / float(n_quads);\r\n            for (uint i = 0u; i < n_quads; i++)\r\n            {\r\n                float t = float(i + 1u) * _step;\r\n                vec2 param_4 = cubic.p0;\r\n                vec2 param_5 = cubic.p1;\r\n                vec2 param_6 = cubic.p2;\r\n                vec2 param_7 = cubic.p3;\r\n                float param_8 = t;\r\n                vec2 qp2 = eval_cubic(param_4, param_5, param_6, param_7, param_8);\r\n                vec2 param_9 = cubic.p0;\r\n                vec2 param_10 = cubic.p1;\r\n                vec2 param_11 = cubic.p2;\r\n                vec2 param_12 = cubic.p3;\r\n                float param_13 = t - (0.5 * _step);\r\n                vec2 qp1 = eval_cubic(param_9, param_10, param_11, param_12, param_13);\r\n                qp1 = (qp1 * 2.0) - ((qp0 + qp2) * 0.5);\r\n                vec2 param_14 = qp0;\r\n                vec2 param_15 = qp1;\r\n                vec2 param_16 = qp2;\r\n                float param_17 = 0.4743416607379913330078125;\r\n                SubdivResult params = estimate_subdiv(param_14, param_15, param_16, param_17);\r\n                val += params.val;\r\n                qp0 = qp2;\r\n            }\r\n            uint n = max(uint(ceil((val * 0.5) / 0.4743416607379913330078125)), 1u);\r\n            uint path_ix = cubic.path_ix;\r\n            Alloc param_18;\r\n            param_18.offset = _685.conf.tile_alloc.offset;\r\n            PathRef param_19 = PathRef(_685.conf.tile_alloc.offset + (path_ix * 12u));\r\n            Path path = Path_read(param_18, param_19);\r\n            uint param_20 = path.tiles.offset;\r\n            uint param_21 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;\r\n            Alloc path_alloc = new_alloc(param_20, param_21);\r\n            ivec4 bbox = ivec4(path.bbox);\r\n            vec2 p0 = cubic.p0;\r\n            qp0 = cubic.p0;\r\n            float v_step = val / float(n);\r\n            int n_out = 1;\r\n            float val_sum = 0.0;\r\n            vec2 p1;\r\n            float _1103;\r\n            TileSeg tile_seg;\r\n            for (uint i_1 = 0u; i_1 < n_quads; i_1++)\r\n            {\r\n                float t_1 = float(i_1 + 1u) * _step;\r\n                vec2 param_22 = cubic.p0;\r\n                vec2 param_23 = cubic.p1;\r\n                vec2 param_24 = cubic.p2;\r\n                vec2 param_25 = cubic.p3;\r\n                float param_26 = t_1;\r\n                vec2 qp2_1 = eval_cubic(param_22, param_23, param_24, param_25, param_26);\r\n                vec2 param_27 = cubic.p0;\r\n                vec2 param_28 = cubic.p1;\r\n                vec2 param_29 = cubic.p2;\r\n                vec2 param_30 = cubic.p3;\r\n                float param_31 = t_1 - (0.5 * _step);\r\n                vec2 qp1_1 = eval_cubic(param_27, param_28, param_29, param_30, param_31);\r\n                qp1_1 = (qp1_1 * 2.0) - ((qp0 + qp2_1) * 0.5);\r\n                vec2 param_32 = qp0;\r\n                vec2 param_33 = qp1_1;\r\n                vec2 param_34 = qp2_1;\r\n                float param_35 = 0.4743416607379913330078125;\r\n                SubdivResult params_1 = estimate_subdiv(param_32, param_33, param_34, param_35);\r\n                float param_36 = params_1.a0;\r\n                float u0 = approx_parabola_inv_integral(param_36);\r\n                float param_37 = params_1.a2;\r\n                float u2 = approx_parabola_inv_integral(param_37);\r\n                float uscale = 1.0 / (u2 - u0);\r\n                float target = float(n_out) * v_step;\r\n                for (;;)\r\n                {\r\n                    bool _996 = uint(n_out) == n;\r\n                    bool _1006;\r\n                    if (!_996)\r\n                    {\r\n                        _1006 = target < (val_sum + params_1.val);\r\n                    }\r\n                    else\r\n                    {\r\n                        _1006 = _996;\r\n                    }\r\n                    if (_1006)\r\n                    {\r\n                        if (uint(n_out) == n)\r\n                        {\r\n                            p1 = cubic.p3;\r\n                        }\r\n                        else\r\n                        {\r\n                            float u = (target - val_sum) / params_1.val;\r\n                            float a = mix(params_1.a0, params_1.a2, u);\r\n                            float param_38 = a;\r\n                            float au = approx_parabola_inv_integral(param_38);\r\n                            float t_2 = (au - u0) * uscale;\r\n                            vec2 param_39 = qp0;\r\n                            vec2 param_40 = qp1_1;\r\n                            vec2 param_41 = qp2_1;\r\n                            float param_42 = t_2;\r\n                            p1 = eval_quad(param_39, param_40, param_41, param_42);\r\n                        }\r\n                        float xmin = min(p0.x, p1.x) - cubic.stroke.x;\r\n                        float xmax = max(p0.x, p1.x) + cubic.stroke.x;\r\n                        float ymin = min(p0.y, p1.y) - cubic.stroke.y;\r\n                        float ymax = max(p0.y, p1.y) + cubic.stroke.y;\r\n                        float dx = p1.x - p0.x;\r\n                        float dy = p1.y - p0.y;\r\n                        if (abs(dy) < 9.999999717180685365747194737196e-10)\r\n                        {\r\n                            _1103 = 1000000000.0;\r\n                        }\r\n                        else\r\n                        {\r\n                            _1103 = dx / dy;\r\n                        }\r\n                        float invslope = _1103;\r\n                        float c = (cubic.stroke.x + (abs(invslope) * (16.0 + cubic.stroke.y))) * 0.03125;\r\n                        float b = invslope;\r\n                        float a_1 = (p0.x - ((p0.y - 16.0) * b)) * 0.03125;\r\n                        int x0 = int(floor(xmin * 0.03125));\r\n                        int x1 = int(floor(xmax * 0.03125) + 1.0);\r\n                        int y0 = int(floor(ymin * 0.03125));\r\n                        int y1 = int(floor(ymax * 0.03125) + 1.0);\r\n                        x0 = clamp(x0, bbox.x, bbox.z);\r\n                        y0 = clamp(y0, bbox.y, bbox.w);\r\n                        x1 = clamp(x1, bbox.x, bbox.z);\r\n                        y1 = clamp(y1, bbox.y, bbox.w);\r\n                        float xc = a_1 + (b * float(y0));\r\n                        int stride = bbox.z - bbox.x;\r\n                        int base = ((y0 - bbox.y) * stride) - bbox.x;\r\n                        uint n_tile_alloc = uint((x1 - x0) * (y1 - y0));\r\n                        uint param_43 = n_tile_alloc * 24u;\r\n                        MallocResult _1219 = malloc(param_43);\r\n                        MallocResult tile_alloc = _1219;\r\n                        if (tile_alloc.failed)\r\n                        {\r\n                            return;\r\n                        }\r\n                        uint tile_offset = tile_alloc.alloc.offset;\r\n                        int xray = int(floor(p0.x * 0.03125));\r\n                        int last_xray = int(floor(p1.x * 0.03125));\r\n                        if (p0.y > p1.y)\r\n                        {\r\n                            int tmp = xray;\r\n                            xray = last_xray;\r\n                            last_xray = tmp;\r\n                        }\r\n                        for (int y = y0; y < y1; y++)\r\n                        {\r\n                            float tile_y0 = float(y * 32);\r\n                            int xbackdrop = max((xray + 1), bbox.x);\r\n                            bool _1273 = tag == 3u;\r\n                            bool _1283;\r\n                            if (_1273)\r\n                            {\r\n                                _1283 = min(p0.y, p1.y) < tile_y0;\r\n                            }\r\n                            else\r\n                            {\r\n                                _1283 = _1273;\r\n                            }\r\n                            bool _1290;\r\n                            if (_1283)\r\n                            {\r\n                                _1290 = xbackdrop < bbox.z;\r\n                            }\r\n                            else\r\n                            {\r\n                                _1290 = _1283;\r\n                            }\r\n                            if (_1290)\r\n                            {\r\n                                int backdrop = (p1.y < p0.y) ? 1 : (-1);\r\n                                TileRef param_44 = path.tiles;\r\n                                uint param_45 = uint(base + xbackdrop);\r\n                                TileRef tile_ref = Tile_index(param_44, param_45);\r\n                                uint tile_el = tile_ref.offset >> uint(2);\r\n                                Alloc param_46 = path_alloc;\r\n                                uint param_47 = tile_el + 1u;\r\n                                if (touch_mem(param_46, param_47))\r\n                                {\r\n                                    uint _1328 = atomicAdd(_135.memory[tile_el + 1u], uint(backdrop));\r\n                                }\r\n                            }\r\n                            int next_xray = last_xray;\r\n                            if (y < (y1 - 1))\r\n                            {\r\n                                float tile_y1 = float((y + 1) * 32);\r\n                                float x_edge = mix(p0.x, p1.x, (tile_y1 - p0.y) / dy);\r\n                                next_xray = int(floor(x_edge * 0.03125));\r\n                            }\r\n                            int min_xray = min(xray, next_xray);\r\n                            int max_xray = max(xray, next_xray);\r\n                            int xx0 = min(int(floor(xc - c)), min_xray);\r\n                            int xx1 = max(int(ceil(xc + c)), (max_xray + 1));\r\n                            xx0 = clamp(xx0, x0, x1);\r\n                            xx1 = clamp(xx1, x0, x1);\r\n                            for (int x = xx0; x < xx1; x++)\r\n                            {\r\n                                float tile_x0 = float(x * 32);\r\n                                TileRef param_48 = TileRef(path.tiles.offset);\r\n                                uint param_49 = uint(base + x);\r\n                                TileRef tile_ref_1 = Tile_index(param_48, param_49);\r\n                                uint tile_el_1 = tile_ref_1.offset >> uint(2);\r\n                                uint old = 0u;\r\n                                Alloc param_50 = path_alloc;\r\n                                uint param_51 = tile_el_1;\r\n                                if (touch_mem(param_50, param_51))\r\n                                {\r\n                                    uint _1431 = atomicExchange(_135.memory[tile_el_1], tile_offset);\r\n                                    old = _1431;\r\n                                }\r\n                                tile_seg.origin = p0;\r\n                                tile_seg.vector = p1 - p0;\r\n                                float y_edge = 0.0;\r\n                                if (tag == 3u)\r\n                                {\r\n                                    y_edge = mix(p0.y, p1.y, (tile_x0 - p0.x) / dx);\r\n                                    if (min(p0.x, p1.x) < tile_x0)\r\n                                    {\r\n                                        vec2 p = vec2(tile_x0, y_edge);\r\n                                        if (p0.x > p1.x)\r\n                                        {\r\n                                            tile_seg.vector = p - p0;\r\n                                        }\r\n                                        else\r\n                                        {\r\n                                            tile_seg.origin = p;\r\n                                            tile_seg.vector = p1 - p;\r\n                                        }\r\n                                        if (tile_seg.vector.x == 0.0)\r\n                                        {\r\n                                            tile_seg.vector.x = sign(p1.x - p0.x) * 9.999999717180685365747194737196e-10;\r\n                                        }\r\n                                    }\r\n                                    if ((x <= min_xray) || (max_xray < x))\r\n                                    {\r\n                                        y_edge = 1000000000.0;\r\n                                    }\r\n                                }\r\n                                tile_seg.y_edge = y_edge;\r\n                                tile_seg.next.offset = old;\r\n                                Alloc param_52 = tile_alloc.alloc;\r\n                                TileSegRef param_53 = TileSegRef(tile_offset);\r\n                                TileSeg param_54 = tile_seg;\r\n                                TileSeg_write(param_52, param_53, param_54);\r\n                                tile_offset += 24u;\r\n                            }\r\n                            xc += b;\r\n                            base += stride;\r\n                            xray = next_xray;\r\n                        }\r\n                        n_out++;\r\n                        target += v_step;\r\n                        p0 = p1;\r\n                        continue;\r\n                    }\r\n                    else\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n                val_sum += params_1.val;\r\n                qp0 = qp2_1;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n",
	}
	shader_stencil_frag = backend.ShaderSources{
		Name:      "stencil.frag",
		GLSL100ES: "precision mediump float;\nprecision highp int;\n\nvarying vec2 vTo;\nvarying vec2 vFrom;\nvarying vec2 vCtrl;\n\nvoid main()\n{\n    float dx = vTo.x - vFrom.x;\n    bool increasing = vTo.x >= vFrom.x;\n    bvec2 _35 = bvec2(increasing);\n    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);\n    bvec2 _41 = bvec2(increasing);\n    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);\n    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));\n    float midx = mix(extent.x, extent.y, 0.5);\n    float x0 = midx - left.x;\n    vec2 p1 = vCtrl - left;\n    vec2 v = right - vCtrl;\n    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));\n    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);\n    vec2 d_half = mix(p1, v, vec2(t));\n    float dy = d_half.y / d_half.x;\n    float width = extent.y - extent.x;\n    dy = abs(dy * width);\n    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);\n    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));\n    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));\n    area *= width;\n    if (width == 0.0)\n    {\n        area = 0.0;\n    }\n    gl_FragData[0].x = area;\n}\n\n",
		GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nin vec2 vTo;\nin vec2 vFrom;\nin vec2 vCtrl;\nlayout(location = 0) out vec4 fragCover;\n\nvoid main()\n{\n    float dx = vTo.x - vFrom.x;\n    bool increasing = vTo.x >= vFrom.x;\n    bvec2 _35 = bvec2(increasing);\n    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);\n    bvec2 _41 = bvec2(increasing);\n    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);\n    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));\n    float midx = mix(extent.x, extent.y, 0.5);\n    float x0 = midx - left.x;\n    vec2 p1 = vCtrl - left;\n    vec2 v = right - vCtrl;\n    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));\n    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);\n    vec2 d_half = mix(p1, v, vec2(t));\n    float dy = d_half.y / d_half.x;\n    float width = extent.y - extent.x;\n    dy = abs(dy * width);\n    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);\n    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));\n    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));\n    area *= width;\n    if (width == 0.0)\n    {\n        area = 0.0;\n    }\n    fragCover.x = area;\n}\n\n",
		GLSL130:   "#version 130\n\nin vec2 vTo;\nin vec2 vFrom;\nin vec2 vCtrl;\nout vec4 fragCover;\n\nvoid main()\n{\n    float dx = vTo.x - vFrom.x;\n    bool increasing = vTo.x >= vFrom.x;\n    bvec2 _35 = bvec2(increasing);\n    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);\n    bvec2 _41 = bvec2(increasing);\n    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);\n    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));\n    float midx = mix(extent.x, extent.y, 0.5);\n    float x0 = midx - left.x;\n    vec2 p1 = vCtrl - left;\n    vec2 v = right - vCtrl;\n    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));\n    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);\n    vec2 d_half = mix(p1, v, vec2(t));\n    float dy = d_half.y / d_half.x;\n    float width = extent.y - extent.x;\n    dy = abs(dy * width);\n    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);\n    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));\n    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));\n    area *= width;\n    if (width == 0.0)\n    {\n        area = 0.0;\n    }\n    fragCover.x = area;\n}\n\n",
		GLSL150:   "#version 150\n\nin vec2 vTo;\nin vec2 vFrom;\nin vec2 vCtrl;\nout vec4 fragCover;\n\nvoid main()\n{\n    float dx = vTo.x - vFrom.x;\n    bool increasing = vTo.x >= vFrom.x;\n    bvec2 _35 = bvec2(increasing);\n    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);\n    bvec2 _41 = bvec2(increasing);\n    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);\n    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));\n    float midx = mix(extent.x, extent.y, 0.5);\n    float x0 = midx - left.x;\n    vec2 p1 = vCtrl - left;\n    vec2 v = right - vCtrl;\n    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));\n    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);\n    vec2 d_half = mix(p1, v, vec2(t));\n    float dy = d_half.y / d_half.x;\n    float width = extent.y - extent.x;\n    dy = abs(dy * width);\n    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);\n    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));\n    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));\n    area *= width;\n    if (width == 0.0)\n    {\n        area = 0.0;\n    }\n    fragCover.x = area;\n}\n\n",
		/*
		   static float2 vTo;
		   static float2 vFrom;
		   static float2 vCtrl;
		   static float4 fragCover;

		   struct SPIRV_Cross_Input
		   {
		       float2 vFrom : TEXCOORD0;
		       float2 vCtrl : TEXCOORD1;
		       float2 vTo : TEXCOORD2;
		   };

		   struct SPIRV_Cross_Output
		   {
		       float4 fragCover : SV_Target0;
		   };

		   void frag_main()
		   {
		       float dx = vTo.x - vFrom.x;
		       bool increasing = vTo.x >= vFrom.x;
		       bool2 _35 = increasing.xx;
		       float2 left = float2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);
		       bool2 _41 = increasing.xx;
		       float2 right = float2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);
		       float2 extent = clamp(float2(vFrom.x, vTo.x), (-0.5f).xx, 0.5f.xx);
		       float midx = lerp(extent.x, extent.y, 0.5f);
		       float x0 = midx - left.x;
		       float2 p1 = vCtrl - left;
		       float2 v = right - vCtrl;
		       float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));
		       float y = lerp(lerp(left.y, vCtrl.y, t), lerp(vCtrl.y, right.y, t), t);
		       float2 d_half = lerp(p1, v, t.xx);
		       float dy = d_half.y / d_half.x;
		       float width = extent.y - extent.x;
		       dy = abs(dy * width);
		       float4 sides = float4((dy * 0.5f) + y, (dy * (-0.5f)) + y, (0.5f - y) / dy, ((-0.5f) - y) / dy);
		       sides = clamp(sides + 0.5f.xxxx, 0.0f.xxxx, 1.0f.xxxx);
		       float area = 0.5f * ((((sides.z - (sides.z * sides.y)) + 1.0f) - sides.x) + (sides.x * sides.w));
		       area *= width;
		       if (width == 0.0f)
		       {
		           area = 0.0f;
		       }
		       fragCover.x = area;
		   }

		   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
		   {
		       vTo = stage_input.vTo;
		       vFrom = stage_input.vFrom;
		       vCtrl = stage_input.vCtrl;
		       frag_main();
		       SPIRV_Cross_Output stage_output;
		       stage_output.fragCover = fragCover;
		       return stage_output;
		   }

		*/
		HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0x94, 0x21, 0xb9, 0x13, 0x4c, 0xba, 0xd, 0x11, 0x8f, 0xc7, 0xce, 0xe, 0x41, 0x73, 0xec, 0xe1, 0x1, 0x0, 0x0, 0x0, 0x5c, 0xa, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x9c, 0x3, 0x0, 0x0, 0xfc, 0x8, 0x0, 0x0, 0x78, 0x9, 0x0, 0x0, 0xc4, 0x9, 0x0, 0x0, 0x28, 0xa, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x5c, 0x3, 0x0, 0x0, 0x5c, 0x3, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x38, 0x3, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x2, 0xff, 0xff, 0x51, 0x0, 0x0, 0x5, 0x0, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x3, 0xb0, 0xb, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0xb0, 0x0, 0x0, 0x0, 0xa0, 0xb, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0x0, 0xb0, 0x0, 0x0, 0x0, 0xa0, 0xa, 0x0, 0x0, 0x3, 0x1, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x81, 0x1, 0x0, 0x55, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0xa, 0x0, 0x0, 0x3, 0x2, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0xb0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x81, 0xb, 0x0, 0x0, 0x3, 0x3, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0xb0, 0x1, 0x0, 0x0, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x4, 0x80, 0x1, 0x0, 0x0, 0x81, 0x1, 0x0, 0x0, 0xb0, 0x58, 0x0, 0x0, 0x4, 0x3, 0x0, 0x2, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x55, 0xb0, 0x1, 0x0, 0x55, 0x80, 0x58, 0x0, 0x0, 0x4, 0x2, 0x0, 0x2, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x55, 0x80, 0x1, 0x0, 0x55, 0xb0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0xc, 0x80, 0x3, 0x0, 0x1b, 0x80, 0x0, 0x0, 0xe4, 0xb1, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x3, 0x80, 0x2, 0x0, 0xe4, 0x81, 0x0, 0x0, 0x1b, 0xb0, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0xff, 0x80, 0x1, 0x0, 0x0, 0x81, 0x5, 0x0, 0x0, 0x3, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x7, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x6, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x0, 0x80, 0x6, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0x55, 0x80, 0x2, 0x0, 0x55, 0x80, 0x12, 0x0, 0x0, 0x4, 0x2, 0x0, 0x3, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x1b, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x0, 0x0, 0xaa, 0xb0, 0x12, 0x0, 0x0, 0x4, 0x2, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x6, 0x0, 0x0, 0x2, 0x0, 0x0, 0x2, 0x80, 0x2, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x2, 0x0, 0x55, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x55, 0x80, 0x23, 0x0, 0x0, 0x2, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x1, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x2, 0x0, 0xaa, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x0, 0xa0, 0x2, 0x0, 0xaa, 0x80, 0x6, 0x0, 0x0, 0x2, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0xc, 0x80, 0x2, 0x0, 0xaa, 0x81, 0x0, 0x0, 0x1b, 0xa0, 0x5, 0x0, 0x0, 0x3, 0x1, 0x0, 0x8, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xff, 0x80, 0x5, 0x0, 0x0, 0x3, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x1f, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x55, 0x81, 0x1, 0x0, 0xaa, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xaa, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0x0, 0x81, 0x0, 0x0, 0x55, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0xff, 0x80, 0x0, 0x0, 0x55, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x58, 0x0, 0x0, 0x4, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x81, 0x0, 0x0, 0xff, 0xa0, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xe, 0x80, 0x0, 0x0, 0xff, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x58, 0x5, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x56, 0x1, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0xc2, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x3, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0xa, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0xa, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x7, 0x32, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x7, 0x32, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1d, 0x0, 0x0, 0x7, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x42, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1a, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x42, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0xa6, 0x1b, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0x9, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa6, 0x1e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xb2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa6, 0xe, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4b, 0x0, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0xc2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0xd, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa6, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x7, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3a, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb, 0x32, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xd, 0x32, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0xa6, 0xa, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x6, 0x4, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa6, 0xa, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x3f, 0x32, 0x0, 0x0, 0xa, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x0, 0x0, 0x7, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x37, 0x0, 0x0, 0x9, 0x12, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xe2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x29, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x5c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xc, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
	}
	shader_stencil_vert = backend.ShaderSources{
		Name:   "stencil.vert",
		Inputs: []backend.InputLocation{{Name: "corner", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 1}, {Name: "maxy", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 1}, {Name: "from", Location: 2, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "ctrl", Location: 3, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}, {Name: "to", Location: 4, Semantic: "TEXCOORD", SemanticIndex: 2, Type: 0x0, Size: 2}},
		Uniforms: backend.UniformsReflection{
			Blocks:    []backend.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []backend.UniformLocation{{Name: "_16.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_16.pathOffset", Type: 0x0, Size: 2, Offset: 16}},
			Size:      24,
		},
		GLSL100ES: "\nstruct Block\n{\n    vec4 transform;\n    vec2 pathOffset;\n};\n\nuniform Block _16;\n\nattribute vec2 from;\nattribute vec2 ctrl;\nattribute vec2 to;\nattribute float maxy;\nattribute float corner;\nvarying vec2 vFrom;\nvarying vec2 vCtrl;\nvarying vec2 vTo;\n\nvoid main()\n{\n    vec2 from_1 = from + _16.pathOffset;\n    vec2 ctrl_1 = ctrl + _16.pathOffset;\n    vec2 to_1 = to + _16.pathOffset;\n    float maxy_1 = maxy + _16.pathOffset.y;\n    float c = corner;\n    vec2 pos;\n    if (c >= 0.375)\n    {\n        c -= 0.5;\n        pos.y = maxy_1 + 1.0;\n    }\n    else\n    {\n        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;\n    }\n    if (c >= 0.125)\n    {\n        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;\n    }\n    else\n    {\n        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;\n    }\n    vFrom = from_1 - pos;\n    vCtrl = ctrl_1 - pos;\n    vTo = to_1 - pos;\n    pos = (pos * _16.transform.xy) + _16.transform.zw;\n    gl_Position = vec4(pos, 1.0, 1.0);\n}\n\n",
		GLSL300ES: "#version 300 es\n\nlayout(std140) uniform Block\n{\n    vec4 transform;\n    vec2 pathOffset;\n} _16;\n\nlayout(location = 2) in vec2 from;\nlayout(location = 3) in vec2 ctrl;\nlayout(location = 4) in vec2 to;\nlayout(location = 1) in float maxy;\nlayout(location = 0) in float corner;\nout vec2 vFrom;\nout vec2 vCtrl;\nout vec2 vTo;\n\nvoid main()\n{\n    vec2 from_1 = from + _16.pathOffset;\n    vec2 ctrl_1 = ctrl + _16.pathOffset;\n    vec2 to_1 = to + _16.pathOffset;\n    float maxy_1 = maxy + _16.pathOffset.y;\n    float c = corner;\n    vec2 pos;\n    if (c >= 0.375)\n    {\n        c -= 0.5;\n        pos.y = maxy_1 + 1.0;\n    }\n    else\n    {\n        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;\n    }\n    if (c >= 0.125)\n    {\n        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;\n    }\n    else\n    {\n        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;\n    }\n    vFrom = from_1 - pos;\n    vCtrl = ctrl_1 - pos;\n    vTo = to_1 - pos;\n    pos = (pos * _16.transform.xy) + _16.transform.zw;\n    gl_Position = vec4(pos, 1.0, 1.0);\n}\n\n",
		GLSL130:   "#version 130\n\nstruct Block\n{\n    vec4 transform;\n    vec2 pathOffset;\n};\n\nuniform Block _16;\n\nin vec2 from;\nin vec2 ctrl;\nin vec2 to;\nin float maxy;\nin float corner;\nout vec2 vFrom;\nout vec2 vCtrl;\nout vec2 vTo;\n\nvoid main()\n{\n    vec2 from_1 = from + _16.pathOffset;\n    vec2 ctrl_1 = ctrl + _16.pathOffset;\n    vec2 to_1 = to + _16.pathOffset;\n    float maxy_1 = maxy + _16.pathOffset.y;\n    float c = corner;\n    vec2 pos;\n    if (c >= 0.375)\n    {\n        c -= 0.5;\n        pos.y = maxy_1 + 1.0;\n    }\n    else\n    {\n        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;\n    }\n    if (c >= 0.125)\n    {\n        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;\n    }\n    else\n    {\n        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;\n    }\n    vFrom = from_1 - pos;\n    vCtrl = ctrl_1 - pos;\n    vTo = to_1 - pos;\n    pos = (pos * _16.transform.xy) + _16.transform.zw;\n    gl_Position = vec4(pos, 1.0, 1.0);\n}\n\n",
		GLSL150:   "#version 150\n\nstruct Block\n{\n    vec4 transform;\n    vec2 pathOffset;\n};\n\nuniform Block _16;\n\nin vec2 from;\nin vec2 ctrl;\nin vec2 to;\nin float maxy;\nin float corner;\nout vec2 vFrom;\nout vec2 vCtrl;\nout vec2 vTo;\n\nvoid main()\n{\n    vec2 from_1 = from + _16.pathOffset;\n    vec2 ctrl_1 = ctrl + _16.pathOffset;\n    vec2 to_1 = to + _16.pathOffset;\n    float maxy_1 = maxy + _16.pathOffset.y;\n    float c = corner;\n    vec2 pos;\n    if (c >= 0.375)\n    {\n        c -= 0.5;\n        pos.y = maxy_1 + 1.0;\n    }\n    else\n    {\n        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;\n    }\n    if (c >= 0.125)\n    {\n        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;\n    }\n    else\n    {\n        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;\n    }\n    vFrom = from_1 - pos;\n    vCtrl = ctrl_1 - pos;\n    vTo = to_1 - pos;\n    pos = (pos * _16.transform.xy) + _16.transform.zw;\n    gl_Position = vec4(pos, 1.0, 1.0);\n}\n\n",
		/*
		   cbuffer Block : register(b0)
		   {
		       float4 _16_transform : packoffset(c0);
		       float2 _16_pathOffset : packoffset(c1);
		   };


		   static float4 gl_Position;
		   static float2 from;
		   static float2 ctrl;
		   static float2 to;
		   static float maxy;
		   static float corner;
		   static float2 vFrom;
		   static float2 vCtrl;
		   static float2 vTo;

		   struct SPIRV_Cross_Input
		   {
		       float corner : POSITION;
		       float maxy : NORMAL;
		       float2 from : TEXCOORD0;
		       float2 ctrl : TEXCOORD1;
		       float2 to : TEXCOORD2;
		   };

		   struct SPIRV_Cross_Output
		   {
		       float2 vFrom : TEXCOORD0;
		       float2 vCtrl : TEXCOORD1;
		       float2 vTo : TEXCOORD2;
		       float4 gl_Position : SV_Position;
		   };

		   void vert_main()
		   {
		       float2 from_1 = from + _16_pathOffset;
		       float2 ctrl_1 = ctrl + _16_pathOffset;
		       float2 to_1 = to + _16_pathOffset;
		       float maxy_1 = maxy + _16_pathOffset.y;
		       float c = corner;
		       float2 pos;
		       if (c >= 0.375f)
		       {
		           c -= 0.5f;
		           pos.y = maxy_1 + 1.0f;
		       }
		       else
		       {
		           pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0f;
		       }
		       if (c >= 0.125f)
		       {
		           pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0f;
		       }
		       else
		       {
		           pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0f;
		       }
		       vFrom = from_1 - pos;
		       vCtrl = ctrl_1 - pos;
		       vTo = to_1 - pos;
		       pos = (pos * _16_transform.xy) + _16_transform.zw;
		       gl_Position = float4(pos, 1.0f, 1.0f);
		   }

		   SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
		   {
		       from = stage_input.from;
		       ctrl = stage_input.ctrl;
		       to = stage_input.to;
		       maxy = stage_input.maxy;
		       corner = stage_input.corner;
		       vert_main();
		       SPIRV_Cross_Output stage_output;
		       stage_output.gl_Position = gl_Position;
		       stage_output.vFrom = vFrom;
		       stage_output.vCtrl = vCtrl;
		       stage_output.vTo = vTo;
		       return stage_output;
		   }

		*/
		HLSL: []byte{0x44, 0x58, 0x42, 0x43, 0x99, 0xea, 0x97, 0xb5, 0xa8, 0xd5, 0x84, 0x5e, 0x4b, 0x12, 0x14, 0x56, 0xdd, 0xee, 0xfc, 0x44, 0x1, 0x0, 0x0, 0x0, 0x18, 0x8, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x4c, 0x2, 0x0, 0x0, 0x74, 0x5, 0x0, 0x0, 0xf0, 0x5, 0x0, 0x0, 0xec, 0x6, 0x0, 0x0, 0x90, 0x7, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xc, 0x2, 0x0, 0x0, 0xc, 0x2, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0xd8, 0x1, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x3, 0x0, 0xf, 0xa0, 0x0, 0x0, 0xc0, 0x3e, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x0, 0xbf, 0x51, 0x0, 0x0, 0x5, 0x4, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x2, 0x80, 0x2, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x3, 0x80, 0x3, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x4, 0x80, 0x4, 0x0, 0xf, 0x90, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x90, 0x2, 0x0, 0x55, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x4, 0x80, 0x0, 0x0, 0x0, 0x80, 0x3, 0x0, 0x55, 0xa0, 0xd, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x90, 0x3, 0x0, 0x0, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0x0, 0x90, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x0, 0x90, 0x3, 0x0, 0xff, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x2, 0x0, 0x3, 0x80, 0x2, 0x0, 0xe4, 0x90, 0x2, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x2, 0x0, 0xc, 0x80, 0x3, 0x0, 0x14, 0x90, 0x2, 0x0, 0x14, 0xa0, 0xa, 0x0, 0x0, 0x3, 0x3, 0x0, 0x3, 0x80, 0x2, 0x0, 0xee, 0x80, 0x2, 0x0, 0xe1, 0x80, 0x2, 0x0, 0x0, 0x3, 0x3, 0x0, 0xc, 0x80, 0x4, 0x0, 0x44, 0x90, 0x2, 0x0, 0x44, 0xa0, 0xa, 0x0, 0x0, 0x3, 0x3, 0x0, 0x3, 0x80, 0x3, 0x0, 0xeb, 0x80, 0x3, 0x0, 0xe4, 0x80, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x3, 0x80, 0x3, 0x0, 0xe4, 0x80, 0x3, 0x0, 0xaa, 0xa0, 0x12, 0x0, 0x0, 0x4, 0x4, 0x0, 0x6, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x1, 0x0, 0xc8, 0x80, 0xd, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x4, 0x0, 0x55, 0x80, 0x4, 0x0, 0x0, 0xa0, 0xb, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x2, 0x0, 0xff, 0x80, 0x2, 0x0, 0x0, 0x80, 0xb, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x3, 0x0, 0xaa, 0x80, 0x0, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x3, 0x0, 0x55, 0xa0, 0x12, 0x0, 0x0, 0x4, 0x4, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0xe0, 0x2, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x28, 0x81, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x3, 0xe0, 0x3, 0x0, 0xee, 0x80, 0x4, 0x0, 0xe8, 0x81, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x4, 0x0, 0xe8, 0x80, 0x1, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0xee, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xc, 0xc0, 0x3, 0x0, 0x55, 0xa0, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x20, 0x3, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0xc8, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x12, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x12, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x4, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xc2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1a, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x1d, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x3e, 0x0, 0x0, 0x0, 0x7, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbf, 0x36, 0x0, 0x0, 0x5, 0x42, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x32, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x6, 0x14, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x6, 0x84, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x7, 0x32, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0xb6, 0xf, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x16, 0x5, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x6, 0x14, 0x10, 0x0, 0x4, 0x0, 0x0, 0x0, 0x6, 0x84, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x7, 0x32, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0xb6, 0xf, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x32, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x62, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0x6, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa6, 0x8, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1d, 0x0, 0x0, 0x7, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x34, 0x0, 0x0, 0x7, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x7, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x37, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x86, 0x8, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x86, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0xa, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x86, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xc2, 0x20, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x16, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xf4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xac, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xbc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x36, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x36, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x0, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x9c, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x89, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x80, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x68, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x3, 0x0, 0x0, 0x68, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x71, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_tile_alloc_comp = backend.ShaderSources{
		Name:      "tile_alloc.comp",
		GLSL310ES: "#version 310 es\r\nlayout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;\r\n\r\nstruct Alloc\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct MallocResult\r\n{\r\n    Alloc alloc;\r\n    bool failed;\r\n};\r\n\r\nstruct AnnoFillRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct AnnoFill\r\n{\r\n    vec4 bbox;\r\n    uint rgba_color;\r\n};\r\n\r\nstruct AnnotatedRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct PathRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct TileRef\r\n{\r\n    uint offset;\r\n};\r\n\r\nstruct Path\r\n{\r\n    uvec4 bbox;\r\n    TileRef tiles;\r\n};\r\n\r\nstruct Config\r\n{\r\n    uint n_elements;\r\n    uint n_pathseg;\r\n    uint width_in_tiles;\r\n    uint height_in_tiles;\r\n    Alloc tile_alloc;\r\n    Alloc bin_alloc;\r\n    Alloc ptcl_alloc;\r\n    Alloc pathseg_alloc;\r\n    Alloc anno_alloc;\r\n};\r\n\r\nlayout(binding = 0, std430) buffer Memory\r\n{\r\n    uint mem_offset;\r\n    uint mem_error;\r\n    uint memory[];\r\n} _95;\r\n\r\nlayout(binding = 1, std430) readonly buffer ConfigBuf\r\n{\r\n    Config conf;\r\n} _310;\r\n\r\nshared uint sh_tile_count[128];\r\nshared MallocResult sh_tile_alloc;\r\n\r\nbool touch_mem(Alloc alloc, uint offset)\r\n{\r\n    return true;\r\n}\r\n\r\nuint read_mem(Alloc alloc, uint offset)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return 0u;\r\n    }\r\n    uint v = _95.memory[offset];\r\n    return v;\r\n}\r\n\r\nuint Annotated_tag(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    uint param_1 = ref.offset >> uint(2);\r\n    return read_mem(param, param_1);\r\n}\r\n\r\nAnnoFill AnnoFill_read(Alloc a, AnnoFillRef ref)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint raw0 = read_mem(param, param_1);\r\n    Alloc param_2 = a;\r\n    uint param_3 = ix + 1u;\r\n    uint raw1 = read_mem(param_2, param_3);\r\n    Alloc param_4 = a;\r\n    uint param_5 = ix + 2u;\r\n    uint raw2 = read_mem(param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 3u;\r\n    uint raw3 = read_mem(param_6, param_7);\r\n    Alloc param_8 = a;\r\n    uint param_9 = ix + 4u;\r\n    uint raw4 = read_mem(param_8, param_9);\r\n    AnnoFill s;\r\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\r\n    s.rgba_color = raw4;\r\n    return s;\r\n}\r\n\r\nAnnoFill Annotated_Fill_read(Alloc a, AnnotatedRef ref)\r\n{\r\n    Alloc param = a;\r\n    AnnoFillRef param_1 = AnnoFillRef(ref.offset + 4u);\r\n    return AnnoFill_read(param, param_1);\r\n}\r\n\r\nAlloc new_alloc(uint offset, uint size)\r\n{\r\n    Alloc a;\r\n    a.offset = offset;\r\n    return a;\r\n}\r\n\r\nMallocResult malloc(uint size)\r\n{\r\n    MallocResult r;\r\n    r.failed = false;\r\n    uint _101 = atomicAdd(_95.mem_offset, size);\r\n    uint offset = _101;\r\n    uint param = offset;\r\n    uint param_1 = size;\r\n    r.alloc = new_alloc(param, param_1);\r\n    if ((offset + size) > uint(int(uint(_95.memory.length())) * 4))\r\n    {\r\n        r.failed = true;\r\n        uint _122 = atomicMax(_95.mem_error, 1u);\r\n        return r;\r\n    }\r\n    return r;\r\n}\r\n\r\nAlloc slice_mem(Alloc a, uint offset, uint size)\r\n{\r\n    uint param = a.offset + offset;\r\n    uint param_1 = size;\r\n    return new_alloc(param, param_1);\r\n}\r\n\r\nvoid write_mem(Alloc alloc, uint offset, uint val)\r\n{\r\n    Alloc param = alloc;\r\n    uint param_1 = offset;\r\n    if (!touch_mem(param, param_1))\r\n    {\r\n        return;\r\n    }\r\n    _95.memory[offset] = val;\r\n}\r\n\r\nvoid Path_write(Alloc a, PathRef ref, Path s)\r\n{\r\n    uint ix = ref.offset >> uint(2);\r\n    Alloc param = a;\r\n    uint param_1 = ix + 0u;\r\n    uint param_2 = s.bbox.x | (s.bbox.y << uint(16));\r\n    write_mem(param, param_1, param_2);\r\n    Alloc param_3 = a;\r\n    uint param_4 = ix + 1u;\r\n    uint param_5 = s.bbox.z | (s.bbox.w << uint(16));\r\n    write_mem(param_3, param_4, param_5);\r\n    Alloc param_6 = a;\r\n    uint param_7 = ix + 2u;\r\n    uint param_8 = s.tiles.offset;\r\n    write_mem(param_6, param_7, param_8);\r\n}\r\n\r\nvoid main()\r\n{\r\n    if (_95.mem_error != 0u)\r\n    {\r\n        return;\r\n    }\r\n    uint th_ix = gl_LocalInvocationID.x;\r\n    uint element_ix = gl_GlobalInvocationID.x;\r\n    PathRef path_ref = PathRef(_310.conf.tile_alloc.offset + (element_ix * 12u));\r\n    AnnotatedRef ref = AnnotatedRef(_310.conf.anno_alloc.offset + (element_ix * 52u));\r\n    uint tag = 0u;\r\n    if (element_ix < _310.conf.n_elements)\r\n    {\r\n        Alloc param;\r\n        param.offset = _310.conf.anno_alloc.offset;\r\n        AnnotatedRef param_1 = ref;\r\n        tag = Annotated_tag(param, param_1);\r\n    }\r\n    int x0 = 0;\r\n    int y0 = 0;\r\n    int x1 = 0;\r\n    int y1 = 0;\r\n    switch (tag)\r\n    {\r\n        case 2u:\r\n        case 3u:\r\n        case 1u:\r\n        case 4u:\r\n        case 5u:\r\n        {\r\n            Alloc param_2;\r\n            param_2.offset = _310.conf.anno_alloc.offset;\r\n            AnnotatedRef param_3 = ref;\r\n            AnnoFill fill = Annotated_Fill_read(param_2, param_3);\r\n            x0 = int(floor(fill.bbox.x * 0.03125));\r\n            y0 = int(floor(fill.bbox.y * 0.03125));\r\n            x1 = int(ceil(fill.bbox.z * 0.03125));\r\n            y1 = int(ceil(fill.bbox.w * 0.03125));\r\n            break;\r\n        }\r\n    }\r\n    x0 = clamp(x0, 0, int(_310.conf.width_in_tiles));\r\n    y0 = clamp(y0, 0, int(_310.conf.height_in_tiles));\r\n    x1 = clamp(x1, 0, int(_310.conf.width_in_tiles));\r\n    y1 = clamp(y1, 0, int(_310.conf.height_in_tiles));\r\n    Path path;\r\n    path.bbox = uvec4(uint(x0), uint(y0), uint(x1), uint(y1));\r\n    uint tile_count = uint((x1 - x0) * (y1 - y0));\r\n    if (tag == 5u)\r\n    {\r\n        tile_count = 0u;\r\n    }\r\n    sh_tile_count[th_ix] = tile_count;\r\n    uint total_tile_count = tile_count;\r\n    for (uint i = 0u; i < 7u; i++)\r\n    {\r\n        barrier();\r\n        if (th_ix >= uint(1 << int(i)))\r\n        {\r\n            total_tile_count += sh_tile_count[th_ix - uint(1 << int(i))];\r\n        }\r\n        barrier();\r\n        sh_tile_count[th_ix] = total_tile_count;\r\n    }\r\n    if (th_ix == 127u)\r\n    {\r\n        uint param_4 = total_tile_count * 8u;\r\n        MallocResult _483 = malloc(param_4);\r\n        sh_tile_alloc = _483;\r\n    }\r\n    barrier();\r\n    MallocResult alloc_start = sh_tile_alloc;\r\n    if (alloc_start.failed)\r\n    {\r\n        return;\r\n    }\r\n    if (element_ix < _310.conf.n_elements)\r\n    {\r\n        uint _500;\r\n        if (th_ix > 0u)\r\n        {\r\n            _500 = sh_tile_count[th_ix - 1u];\r\n        }\r\n        else\r\n        {\r\n            _500 = 0u;\r\n        }\r\n        uint tile_subix = _500;\r\n        Alloc param_5 = alloc_start.alloc;\r\n        uint param_6 = 8u * tile_subix;\r\n        uint param_7 = 8u * tile_count;\r\n        Alloc tiles_alloc = slice_mem(param_5, param_6, param_7);\r\n        path.tiles = TileRef(tiles_alloc.offset);\r\n        Alloc param_8;\r\n        param_8.offset = _310.conf.tile_alloc.offset;\r\n        PathRef param_9 = path_ref;\r\n        Path param_10 = path;\r\n        Path_write(param_8, param_9, param_10);\r\n    }\r\n    uint total_count = sh_tile_count[127] * 2u;\r\n    uint start_ix = alloc_start.alloc.offset >> uint(2);\r\n    for (uint i_1 = th_ix; i_1 < total_count; i_1 += 128u)\r\n    {\r\n        Alloc param_11 = alloc_start.alloc;\r\n        uint param_12 = start_ix + i_1;\r\n        uint param_13 = 0u;\r\n        write_mem(param_11, param_12, param_13);\r\n    }\r\n}\r\n\r\n",
	}
)
