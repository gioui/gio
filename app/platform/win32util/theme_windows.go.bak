 //go:build windows

package desktop

import (
	"fmt"
	"log/slog"
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows/registry"
)

const (
	themeRegKey  = `Software\Microsoft\Windows\CurrentVersion\Themes\Personalize` // in HKCU
	themeRegName = `AppsUseLightTheme`                                            // <- For apps. Use SystemUsesLightTheme for taskbar and tray
)

// IsDark returns whether the system color theme is dark (as opposed to light).
func (app *App) IsDark() bool {
	k, err := registry.OpenKey(registry.CURRENT_USER, themeRegKey, registry.QUERY_VALUE)
	if err != nil {
		slog.Error("error opening theme registry key: " + err.Error())
		return false
	}
	defer k.Close()
	val, _, err := k.GetIntegerValue(themeRegName)
	if err != nil {
		slog.Error("error getting theme registry value: " + err.Error())
		return false
	}
	// dark mode is 0
	return val == 0
}

// TODO(kai): fix IsDarkMonitor on windows

// IsDarkMonitor monitors the state of the dark mode and calls the given function
// with the new value whenever it changes. It returns a channel that will
// receive any errors that occur during the monitoring, as it happens in a
// separate goroutine. It also returns any error that occurred during the
// initial set up of the monitoring. If the error is non-nil, the error channel
// will be nil. It also takes a done channel, and it will stop monitoring when
// that done channel is closed.
func (app *App) IsDarkMonitor(fn func(isDark bool), done chan struct{}) (chan error, error) {
	var regNotifyChangeKeyValue *syscall.Proc

	if advapi32, err := syscall.LoadDLL("Advapi32.dll"); err == nil {
		if p, err := advapi32.FindProc("RegNotifyChangeKeyValue"); err == nil {
			regNotifyChangeKeyValue = p
		} else {
			return nil, fmt.Errorf("error finding function RegNotifyChangeKeyValue in Advapi32.dll: %w", err)
		}
	}

	ec := make(chan error)
	if regNotifyChangeKeyValue != nil {
		go func() {
			k, err := registry.OpenKey(registry.CURRENT_USER, themeRegKey, syscall.KEY_NOTIFY|registry.QUERY_VALUE)
			if err != nil {
				ec <- fmt.Errorf("error opening theme registry key: %w", err)
				return
			}
			// need haveSetWasDark to capture first change correctly
			var wasDark, haveSetWasDark bool
			for {
				select {
				case <-done:
					// if done is closed, we return
					return
				default:
					regNotifyChangeKeyValue.Call(uintptr(k), 0, 0x00000001|0x00000004, 0, 0)
					val, _, err := k.GetIntegerValue(themeRegName)
					if err != nil {
						ec <- fmt.Errorf("error getting theme registry value: %w", err)
						return
					}
					// dark mode is 0
					isDark := val == 0

					if isDark != wasDark || !haveSetWasDark {
						fn(isDark)
						wasDark = isDark
						haveSetWasDark = true
					}
				}
			}
		}()
	}
	return ec, nil
}

func (w *Window) SetTitleBarIsDark(isDark bool) {
	if !w.IsVisible() {
		return
	}
	hwnd := w.Glw.GetWin32Window()

	dwm := syscall.NewLazyDLL("dwmapi.dll")
	setAtt := dwm.NewProc("DwmSetWindowAttribute")
	ret, _, err := setAtt.Call(uintptr(unsafe.Pointer(hwnd)), // window handle
		20,                               // DWMWA_USE_IMMERSIVE_DARK_MODE
		uintptr(unsafe.Pointer(&isDark)), // on or off
		8)                                // sizeof(darkMode)

	if ret != 0 { // err is always non-nil, we check return value
		slog.Error("failed to set window title bar color", "err", err)
	}
}
